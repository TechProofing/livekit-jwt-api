{"version":3,"file":"iframe.d496656a.js","sources":["../../iframe/AuthHandler.ts","../../iframe/index.ts"],"sourcesContent":["import { AuxAuth, LoginStatus, LoginUIStatus } from '@casual-simulation/aux-vm';\nimport { AuthData } from '@casual-simulation/aux-common';\nimport {\n    listenForChannel,\n    listenForChannels,\n    setupChannel,\n    waitForLoad,\n} from '../../../aux-vm-browser/html/IFrameHelpers';\nimport { authManager } from '../shared/index';\nimport {\n    CreatePublicRecordKeyResult,\n    PublicRecordKeyPolicy,\n} from '@casual-simulation/aux-records';\nimport { parseSessionKey } from '@casual-simulation/aux-records/AuthUtils';\nimport { BehaviorSubject, Subject, merge, from, NEVER } from 'rxjs';\nimport {\n    first,\n    map,\n    tap,\n    share,\n    filter,\n    switchMap,\n    mergeAll,\n} from 'rxjs/operators';\n\ndeclare let ENABLE_SMS_AUTHENTICATION: boolean;\n\nconst REFRESH_LIFETIME_MS = 1000 * 60 * 60 * 24 * 7; // 1 week\n\n/**\n * Defines a class that implements the backend for an AuxAuth instance.\n */\nexport class AuthHandler implements AuxAuth {\n    private _loggedIn: boolean = false;\n    private _loginData: AuthData;\n    private _userId: string;\n    private _token: string;\n    private _refreshTimeout: any;\n    private _loginStatus: BehaviorSubject<LoginStatus> = new BehaviorSubject(\n        {}\n    );\n    private _loginUIStatus: BehaviorSubject<LoginUIStatus> =\n        new BehaviorSubject({ page: false });\n    private _useCustomUI: boolean = false;\n    private _providedEmails: Subject<string> = new Subject();\n    private _providedSms: Subject<string> = new Subject();\n    private _canceledLogins: Subject<void> = new Subject();\n    private _providedCodes: Subject<string> = new Subject();\n\n    async isLoggedIn(): Promise<boolean> {\n        if (this._loggedIn) {\n            const expiry = this._getTokenExpirationTime(this._token);\n            if (Date.now() < expiry) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    async login(backgroundLogin?: boolean): Promise<AuthData> {\n        if (await this.isLoggedIn()) {\n            return this._loginData;\n        }\n        this._loginStatus.next({\n            isLoggingIn: true,\n        });\n\n        if (await this._checkLoginStatus()) {\n            console.log('[AuthHandler] Already logged in.');\n            await this._loadUserInfo();\n            return this._loginData;\n        } else if (!backgroundLogin) {\n            let userId: string;\n            if (this._useCustomUI) {\n                console.log('[AuthHandler] Attempting login with Custom UI.');\n                userId = await this._loginWithCustomUI();\n            } else {\n                console.log('[AuthHandler] Attempting login with new tab.');\n                userId = await this._loginWithNewTab();\n            }\n\n            if (userId) {\n                this._userId = userId;\n                await this._loadUserInfo();\n\n                this._loginStatus.next({\n                    authData: this._loginData,\n                });\n                return this._loginData;\n            } else {\n                this._loginStatus.next({\n                    authData: null,\n                });\n                return null;\n            }\n        } else {\n            console.log('[AuthHandler] Skipping login with UI.');\n        }\n\n        this._loginStatus.next({\n            authData: this._loginData,\n        });\n\n        return this._loginData;\n    }\n\n    async createPublicRecordKey(\n        recordName: string,\n        policy?: PublicRecordKeyPolicy\n    ): Promise<CreatePublicRecordKeyResult> {\n        console.log('[AuthHandler] Creating public record key:', recordName);\n        if (!(await this.isLoggedIn())) {\n            await this.login();\n        }\n\n        if (!(await this.isLoggedIn())) {\n            console.log(\n                '[AuthHandler] Unauthorized to create public record key.'\n            );\n            return {\n                success: false,\n                errorCode: 'not_logged_in',\n                errorMessage: 'User is not logged in.',\n                errorReason: 'not_logged_in',\n            };\n        }\n\n        const key = await authManager.createPublicRecordKey(recordName, policy);\n        console.log('[AuthHandler] Record key created.');\n\n        if (key.success === false) {\n            if (\n                key.errorCode === 'not_logged_in' ||\n                key.errorCode === 'unacceptable_session_key' ||\n                key.errorCode === 'invalid_key' ||\n                key.errorCode === 'session_expired'\n            ) {\n                this._loggedIn = false;\n                this._token = null;\n                await authManager.logout(false);\n                return await this.createPublicRecordKey(recordName, policy);\n            }\n        }\n\n        return key;\n    }\n\n    async getAuthToken(): Promise<string> {\n        if (await this.isLoggedIn()) {\n            return this._token;\n        }\n\n        return null;\n    }\n\n    async getProtocolVersion() {\n        return 6;\n    }\n\n    async getRecordsOrigin(): Promise<string> {\n        return Promise.resolve(authManager.apiEndpoint);\n    }\n\n    async openAccountPage(): Promise<void> {\n        const url = new URL('/', location.origin);\n        window.open(url.href, '_blank');\n    }\n\n    async addLoginStatusCallback(\n        callback: (status: LoginStatus) => void\n    ): Promise<void> {\n        this._loginStatus.subscribe((status) => callback(status));\n    }\n\n    async addLoginUICallback(callback: (status: LoginUIStatus) => void) {\n        this._loginUIStatus.subscribe((status) => callback(status));\n    }\n\n    async setUseCustomUI(useCustomUI: boolean) {\n        this._useCustomUI = !!useCustomUI;\n    }\n\n    async provideEmailAddress(\n        email: string,\n        acceptedTermsOfService: boolean\n    ): Promise<void> {\n        if (!acceptedTermsOfService) {\n            this._loginUIStatus.next({\n                page: 'enter_address',\n                siteName: this.siteName,\n                termsOfServiceUrl: this.termsOfServiceUrl,\n                showAcceptTermsOfServiceError: true,\n                errorCode: 'terms_not_accepted',\n                errorMessage: 'You must accept the terms of service.',\n                supportsSms: this._supportsSms,\n            });\n            return;\n        }\n        if (!email) {\n            this._loginUIStatus.next({\n                page: 'enter_address',\n                siteName: this.siteName,\n                termsOfServiceUrl: this.termsOfServiceUrl,\n                showEnterEmailError: true,\n                errorCode: 'email_not_provided',\n                errorMessage: 'You must provide an email address.',\n                supportsSms: this._supportsSms,\n            });\n            return;\n        }\n        if (!(await authManager.validateEmail(email))) {\n            this._loginUIStatus.next({\n                page: 'enter_address',\n                siteName: this.siteName,\n                termsOfServiceUrl: this.termsOfServiceUrl,\n                showInvalidEmailError: true,\n                errorCode: 'invalid_email',\n                errorMessage: 'The provided email is not accepted.',\n                supportsSms: this._supportsSms,\n            });\n            return;\n        }\n\n        console.log('[AuthHandler] Got email.');\n        this._providedEmails.next(email);\n    }\n\n    async provideSmsNumber(\n        sms: string,\n        acceptedTermsOfService: boolean\n    ): Promise<void> {\n        if (!acceptedTermsOfService) {\n            this._loginUIStatus.next({\n                page: 'enter_address',\n                siteName: this.siteName,\n                termsOfServiceUrl: this.termsOfServiceUrl,\n                showAcceptTermsOfServiceError: true,\n                errorCode: 'terms_not_accepted',\n                errorMessage: 'You must accept the terms of service.',\n                supportsSms: this._supportsSms,\n            });\n            return;\n        }\n        if (!sms) {\n            this._loginUIStatus.next({\n                page: 'enter_address',\n                siteName: this.siteName,\n                termsOfServiceUrl: this.termsOfServiceUrl,\n                showEnterSmsError: true,\n                errorCode: 'sms_not_provided',\n                errorMessage: 'You must provide an SMS number.',\n                supportsSms: this._supportsSms,\n            });\n            return;\n        }\n\n        sms = sms.trim();\n        if (!sms.startsWith('+')) {\n            this._loginUIStatus.next({\n                page: 'enter_address',\n                siteName: this.siteName,\n                termsOfServiceUrl: this.termsOfServiceUrl,\n                showInvalidSmsError: true,\n                errorCode: 'invalid_sms',\n                errorMessage: 'The phone number must include the country code.',\n                supportsSms: this._supportsSms,\n            });\n            return;\n        }\n\n        if (!(await authManager.validateSmsNumber(sms))) {\n            this._loginUIStatus.next({\n                page: 'enter_address',\n                siteName: this.siteName,\n                termsOfServiceUrl: this.termsOfServiceUrl,\n                showInvalidSmsError: true,\n                errorCode: 'invalid_sms',\n                errorMessage: 'The provided phone number is not accepted.',\n                supportsSms: this._supportsSms,\n            });\n            return;\n        }\n\n        console.log('[AuthHandler] Got SMS number.');\n        this._providedSms.next(sms);\n    }\n\n    async provideCode(code: string): Promise<void> {\n        console.log('[AuthHandler] Got login code.');\n        this._providedCodes.next(code);\n    }\n\n    async cancelLogin() {\n        console.log('[AuthHandler] Canceling login.');\n        this._canceledLogins.next();\n    }\n\n    private _getTokenExpirationTime(token: string): number {\n        const parsed = parseSessionKey(token);\n        if (!parsed) {\n            return -1;\n        }\n        return parsed[3];\n    }\n\n    private async _checkLoginStatus() {\n        console.log('[AuthHandler] Checking login status...');\n        const loggedIn = authManager.isLoggedIn();\n\n        if (loggedIn && !authManager.userInfoLoaded) {\n            return await authManager.loadUserInfo();\n        }\n        return loggedIn;\n    }\n\n    private async _loadUserInfo() {\n        if (!authManager.userInfoLoaded) {\n            await authManager.loadUserInfo();\n        }\n        authManager.loadUserInfo;\n        this._token = authManager.savedSessionKey;\n        this._loginData = {\n            userId: this._userId ?? authManager.userId,\n            avatarUrl: authManager.avatarUrl,\n            avatarPortraitUrl: authManager.avatarPortraitUrl,\n            name: authManager.name,\n        };\n\n        this._queueTokenRefresh(this._token);\n        this._loggedIn = true;\n        console.log('[AuthHandler] Logged In!');\n\n        this._loginStatus.next({\n            authData: this._loginData,\n        });\n    }\n\n    private async _loginWithCustomUI(): Promise<string> {\n        try {\n            let canceled = this._canceledLogins\n                .pipe(\n                    first(),\n                    map(() => null as string)\n                )\n                .toPromise();\n            let cancelSignal = {\n                canceled: false,\n            };\n            canceled.then(() => {\n                cancelSignal.canceled = true;\n                return null;\n            });\n\n            return await Promise.race<string>([\n                canceled,\n                this._tryLoginWithCustomUI(cancelSignal),\n            ]);\n        } finally {\n            this._loginUIStatus.next({\n                page: false,\n            });\n        }\n    }\n\n    private async _tryLoginWithCustomUI(cancelSignal: {\n        canceled: boolean;\n    }): Promise<string> {\n        this._loginUIStatus.next({\n            page: 'enter_address',\n            termsOfServiceUrl: this.termsOfServiceUrl,\n            siteName: this.siteName,\n            supportsSms: this._supportsSms,\n        });\n\n        const loginRequests = merge(\n            this._providedEmails.pipe(\n                filter((email) => !cancelSignal.canceled),\n                map((email) => from(authManager.loginWithEmail(email)))\n            ),\n            this._providedSms.pipe(\n                filter((email) => !cancelSignal.canceled),\n                map((phone) => from(authManager.loginWithPhoneNumber(phone)))\n            )\n        ).pipe(mergeAll(), share());\n\n        const logins = loginRequests.pipe(\n            switchMap((result) => {\n                if (result.success === true) {\n                    const address = result.address;\n                    const addressType = result.addressType;\n                    console.log('[AuthHandler] Email sent.');\n                    this._loginUIStatus.next({\n                        page: 'check_address',\n                        address: result.address,\n                        addressType: result.addressType,\n                        enterCode: true,\n                    });\n\n                    return this._providedCodes.pipe(\n                        switchMap((code) =>\n                            authManager.completeLogin(\n                                result.userId,\n                                result.requestId,\n                                code\n                            )\n                        ),\n                        tap((result) => {\n                            if (result.success == false) {\n                                if (result.errorCode === 'invalid_code') {\n                                    this._loginUIStatus.next({\n                                        page: 'check_address',\n                                        address: address,\n                                        addressType: addressType,\n                                        enterCode: true,\n                                        showInvalidCodeError: true,\n                                    });\n                                }\n                            }\n                        })\n                    );\n                } else {\n                    console.log('[AuthHandler] Unable to send email.');\n                    if (result.errorCode === 'unacceptable_address') {\n                        this._loginUIStatus.next({\n                            page: 'enter_address',\n                            siteName: this.siteName,\n                            termsOfServiceUrl: this.termsOfServiceUrl,\n                            showInvalidEmailError: true,\n                            errorCode: 'invalid_email',\n                            errorMessage:\n                                'Unable to send an email to the provided email address.',\n                            supportsSms: this._supportsSms,\n                        });\n                    } else if (\n                        result.errorCode === 'address_type_not_supported'\n                    ) {\n                        this._loginUIStatus.next({\n                            page: 'enter_address',\n                            siteName: this.siteName,\n                            termsOfServiceUrl: this.termsOfServiceUrl,\n                            showInvalidEmailError: true,\n                            errorCode: 'invalid_email',\n                            errorMessage: 'Email addresses are not supported',\n                            supportsSms: this._supportsSms,\n                        });\n                    }\n\n                    return NEVER;\n                }\n            }),\n            first((result) => result.success)\n        );\n\n        const login = await logins.toPromise();\n\n        if (login.success === false) {\n            return null;\n        }\n\n        await authManager.loadUserInfo();\n        await this._loadUserInfo();\n\n        return authManager.userId;\n    }\n\n    private _loginWithNewTab(): Promise<string> {\n        console.log('[AuthHandler] Opening login tab...');\n        const url = new URL('/', location.origin);\n        const newTab = window.open(url.href, '_blank');\n\n        return new Promise((resolve, reject) => {\n            let handled = false;\n            let userId: string;\n            const sub = listenForChannels(newTab.origin).subscribe((port) => {\n                const handleClose = () => {\n                    if (!handled) {\n                        console.log('[AuthHandler] Login canceled.');\n                        sub.unsubscribe();\n                        reject(new Error('Login failed'));\n                    }\n                };\n\n                newTab.onclose = () => {\n                    handleClose();\n                };\n\n                port.addEventListener('message', (message) => {\n                    if (message.data.type === 'close') {\n                        handleClose();\n                    } else if (message.data.type === 'login') {\n                        console.log('[AuthHandler] Got User ID.');\n                        userId = message.data.userId;\n                        handled = true;\n                        sub.unsubscribe();\n                        newTab.close();\n                        resolve(userId);\n                    } else if (message.data.type === 'token') {\n                        console.log('[AuthHandler] Got token.');\n                    }\n                });\n\n                if (port.start) {\n                    port.start();\n                }\n            });\n        });\n    }\n\n    private _queueTokenRefresh(token: string) {\n        if (this._refreshTimeout) {\n            clearTimeout(this._refreshTimeout);\n        }\n        const expiry = this._getTokenExpirationTime(token);\n        const now = Date.now();\n        const lifetimeMs = expiry - now;\n        const refreshTimeMs = Math.max(lifetimeMs - REFRESH_LIFETIME_MS, 0);\n        console.log(\n            '[AuthHandler] Refreshing token in',\n            refreshTimeMs / 1000,\n            'seconds'\n        );\n        this._refreshTimeout = setTimeout(() => {\n            this._refreshToken();\n        }, refreshTimeMs);\n    }\n\n    private async _refreshToken() {\n        console.log('[AuthHandler] Refreshing token...');\n        if (!this._loginData) {\n            console.log('[AuthHandler] Unable to refresh. No login data.');\n            return;\n        }\n        const result = await authManager.replaceSession();\n        if (result.success) {\n            this._token = result.sessionKey;\n            console.log('[AuthHandler] Token refreshed!');\n        } else {\n            console.error('[AuthHandler] Failed to refresh token.', result);\n        }\n    }\n\n    private get siteName() {\n        return location.host;\n    }\n\n    private get termsOfServiceUrl() {\n        return new URL('/terms', location.origin).href;\n    }\n\n    private get _supportsSms() {\n        return ENABLE_SMS_AUTHENTICATION === true;\n    }\n}\n","/**\n * MIT License\n *\n * Copyright (c) 2019 Casual Simulation, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n * @license MIT\n */\nimport { expose } from 'comlink';\nimport { AuthHandler } from './AuthHandler';\nimport { listenForChannel } from '@casual-simulation/aux-vm-browser/html/IFrameHelpers';\n\nlistenForChannel().then((port) => {\n    console.log('[aux-auth/iframe/index] Got port, exposing API');\n    expose(AuthHandler, port);\n});\n\nconsole.log('[aux-auth/iframe/index] Listening for port...');\n"],"names":[],"mappings":"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"}
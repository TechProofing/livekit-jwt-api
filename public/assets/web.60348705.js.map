{"version":3,"file":"web.60348705.js","sources":["../../../../aux-components/SVGPolyfill.ts","../../../../aux-components/EventBus.ts","../../../../aux-common/utils.ts","../../../../aux-common/bots/Bot.ts","../../../../crypto/Encryption.ts","../../../../aux-common/math/Vector2.ts","../../../../aux-common/math/Vector3.ts","../../../../aux-common/math/Quaternion.ts","../../../../aux-common/math/Rotation.ts","../../../../aux-common/bots/BotCalculations.ts","../../../../aux-common/aux-format-2/AuxOpTypes.ts","../../../../aux-common/runtime/RuntimeBot.ts","../../../../aux-common/runtime/AuxRealtimeEditModeProvider.ts","../../../../aux-common/runtime/BlobPolyfill.ts","../../../../aux-common/runtime/Transpiler.ts","../../../../aux-common/runtime/PerformanceNowPolyfill.ts","../../../../aux-common/polyfill/Array.first.polyfill.ts","../../../../aux-common/polyfill/Array.last.polyfill.ts","../../../../chalk/ansi-styles.ts","../../../../chalk/util.ts","../../../../chalk/index.ts","../../../../expect/src/get-type/index.ts","../../../../expect/src/pretty-format/collections.ts","../../../../expect/src/pretty-format/plugins/AsymmetricMatcher.ts","../../../../chalk/ansi-regex.ts","../../../../expect/src/pretty-format/plugins/ConvertAnsi.ts","../../../../expect/src/pretty-format/plugins/DOMCollection.ts","../../../../expect/src/pretty-format/plugins/lib/escapeHTML.ts","../../../../expect/src/pretty-format/plugins/lib/markup.ts","../../../../expect/src/pretty-format/plugins/DOMElement.ts","../../../../expect/src/pretty-format/plugins/Immutable.ts","../../../../expect/src/pretty-format/plugins/ReactTestComponent.ts","../../../../expect/src/pretty-format/index.ts","../../../../expect/src/diff/cleanupSemantic.ts","../../../../expect/src/diff/constants.ts","../../../../expect/src/diff-sequences/index.ts","../../../../expect/src/diff/joinAlignedDiffs.ts","../../../../expect/src/diff/normalizeDiffOptions.ts","../../../../expect/src/diff/diffLines.ts","../../../../expect/src/diff/diffStrings.ts","../../../../expect/src/diff/getAlignedDiffs.ts","../../../../expect/src/diff/printDiffs.ts","../../../../expect/src/diff/index.ts","../../../../expect/src/matcher-utils/Replaceable.ts","../../../../expect/src/matcher-utils/deepCyclicCopyReplaceable.ts","../../../../expect/src/matcher-utils/index.ts","../../../../expect/src/jasmineUtils.ts","../../../../expect/src/jestMatchersObject.ts","../../../../expect/src/utils.ts","../../../../expect/src/asymmetricMatchers.ts","../../../../expect/src/extractExpectedAssertionsErrors.ts","../../../../expect/src/print.ts","../../../../expect/src/matchers.ts","../../../../expect/src/spyMatchers.ts","../../../../expect/src/message-util/index.ts","../../../../expect/src/toThrowMatchers.ts","../../../../expect/src/index.ts","../../../../aux-common/runtime/AuxLibrary.ts","../../../../aux-components/components/Tagline/Tagline.ts?vue&type=script&src&lang.ts","../../../../aux-components/components/Tagline/Tagline.vue?vue&type=template&lang.js","../../../../aux-components/components/Loading/Loading.ts?vue&type=script&src&lang.ts","../../../../aux-components/components/Loading/Loading.vue?vue&type=template&lang.js","../../../../aux-components/components/SvgIcon/SvgIcon.ts?vue&type=script&src&lang.ts","../../../../aux-components/components/SvgIcon/SvgIcon.vue?vue&type=template&lang.js","../../site/AuthApp/AuthApp.ts?vue&type=script&src&lang.ts","../../site/AuthApp/AuthApp.vue?vue&type=template&lang.js","../../site/AuthAvatar/AuthAvatar.ts?vue&type=script&src&lang.ts","../../site/AuthAvatar/AuthAvatar.vue?vue&type=template&lang.js","../../site/SessionLocation/SessionLocation.ts?vue&type=script&src&lang.ts","../../site/SessionLocation/SessionLocation.vue?vue&type=template&lang.js","../../site/RelativeTime/RelativeTime.ts?vue&type=script&src&lang.ts","../../site/RelativeTime/RelativeTime.vue?vue&type=template&lang.js","../../site/AuthSecurity/AuthSecurity.ts?vue&type=script&src&lang.ts","../../site/AuthSecurity/AuthSecurity.vue?vue&type=template&lang.js","../../site/AuthHome/AuthHome.ts?vue&type=script&src&lang.ts","../../site/AuthHome/AuthHome.vue?vue&type=template&lang.js","../../site/AuthLogin/AuthLogin.ts?vue&type=script&src&lang.ts","../../site/AuthLogin/AuthLogin.vue?vue&type=template&lang.js","../../site/AuthEnterCode/AuthEnterCode.ts?vue&type=script&src&lang.ts","../../site/AuthEnterCode/AuthEnterCode.vue?vue&type=template&lang.js","../../site/AuthLoading/AuthLoading.ts?vue&type=script&src&lang.ts","../../site/AuthLoading/AuthLoading.vue?vue&type=template&lang.js","../../site/AuthTerms/AuthTerms.ts?vue&type=script&src&lang.ts","../../site/AuthTerms/AuthTerms.vue?vue&type=template&lang.js","../../site/AuthPrivacyPolicy/AuthPrivacyPolicy.ts?vue&type=script&src&lang.ts","../../site/AuthPrivacyPolicy/AuthPrivacyPolicy.vue?vue&type=template&lang.js","../../site/AuthAcceptableUsePolicy/AuthAcceptableUsePolicy.ts?vue&type=script&src&lang.ts","../../site/AuthAcceptableUsePolicy/AuthAcceptableUsePolicy.vue?vue&type=template&lang.js","../../../virtual:svg-icons-register","../../site/index.ts"],"sourcesContent":["import '@casual-simulation/aux-vm/globalThis-polyfill';\nif (!globalThis.SVGElement) {\n    console.warn(\n        \"[SVGPolyfill] Polyfilling SVGElement since browser doesn't implement it.\"\n    );\n    class SVGElementImpl extends Element {}\n    globalThis.SVGElement = <any>SVGElementImpl;\n}\n","import Vue from 'vue';\nexport const EventBus = new Vue();\n","import { union, keys, every, some, isObject, mapValues } from 'lodash';\nimport { v4 as uuid } from 'uuid';\n\n/**\n * Merges the two objects and returns a new object that contains the combination of the two.\n * This is a sane merge. That means arrays are copied and if nothing needs merging then nothing changes.\n * @param obj\n * @param next\n */\nexport function merge<T1, T2>(first: T1, second: T2): T1 & T2;\nexport function merge<T1, T2, T3>(\n    first: T1,\n    second: T2,\n    third: T3\n): T1 & T2 & T3;\nexport function merge(...objs: any[]): any {\n    let result: any = {};\n    const objKeys = objs.map((o) => keys(o));\n    const allKeys = union(...objKeys);\n\n    allKeys.forEach((k) => {\n        result[k] = decide(...objs.map((o) => o[k]));\n    });\n\n    return result;\n}\n\nfunction decide(...vals: any[]) {\n    const undefed = vals.filter((v) => typeof v !== 'undefined');\n    if (undefed.length === 1) {\n        return undefed[0];\n    } else {\n        if (\n            every(\n                undefed,\n                (v) => typeof v === 'object' && !Array.isArray(v) && v !== null\n            ) &&\n            some(undefed, (v) => v !== undefed[0])\n        ) {\n            return (<any>merge)(...undefed);\n        } else {\n            return undefed[undefed.length - 1];\n        }\n    }\n}\n\n/**\n * Maps all the values of the given object.\n * @param value The object to map.\n * @param callback The callback that transforms one value into another.\n */\nexport function mapValuesDeep(value: any, callback: (v: any) => any): any {\n    return isObject(value)\n        ? mapValues(value, (v) => mapValuesDeep(v, callback))\n        : callback(value);\n}\n\n/**\n * Splices the given string and returns the final result.\n * @param str The string to splice.\n * @param index The index that the splice should be started at.\n * @param deleteCount The number of characters to delete.\n * @param text The text to insert.\n */\nexport function splice(\n    str: string,\n    index: number,\n    deleteCount: number,\n    text: string\n) {\n    return str.slice(0, index) + text + str.slice(index + deleteCount);\n}\n\nexport function lerp(start: number, end: number, t: number): number {\n    return (1.0 - t) * start + t * end;\n}\n\nexport function clamp(value: number, min: number, max: number): number {\n    return Math.max(min, Math.min(max, value));\n}\n\nexport function normalize(value: number, min: number, max: number): number {\n    value = clamp(value, min, max);\n    return (value - min) / (max - min);\n}\n\nexport function unnormalize(normal: number, min: number, max: number): number {\n    normal = clamp(normal, 0.0, 1.0);\n    return normal * (max - min) + min;\n}\n\n/**\n * Creates and returns a short 8 character UUID (no dashes).\n */\nexport function shortUuid() {\n    return uuid().substr(0, 8);\n}\n\n/**\n * Parses the given RealtimeChannelInfo ID to the ID of the aux.\n * @param id The id to parse.\n */\nexport function parseRealtimeChannelId(id: string): string {\n    return id.substring(4);\n}\n\n/**\n * Converts the given string from dot case (dot.case) to camel case (camelCase).\n * @param dotCase The string to convert.\n */\nexport function dotCaseToCamelCase(dotCase: string): string {\n    const split = dotCase.split('.');\n    if (split.length <= 0) {\n        return '';\n    } else if (split.length === 1) {\n        return split[0];\n    } else {\n        let [isTagHidden, first] = isHidden(split[0]);\n        let others = split.slice(1);\n        let uppercased = [] as string[];\n        for (let str of others) {\n            let [hidden, updated] = isHidden(str);\n            str = updated;\n            if (hidden) {\n                isTagHidden = true;\n            }\n\n            uppercased.push(capitalizeFirstLetter(str));\n        }\n        let joined = uppercased.join('');\n\n        if (isTagHidden) {\n            return '_' + first + joined;\n        } else {\n            return first + joined;\n        }\n    }\n}\n\nfunction capitalizeFirstLetter(str: string): string {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nfunction isHidden(str: string): [boolean, string] {\n    const hidden = str.indexOf('_') === 0;\n    if (hidden) {\n        return [hidden, str.slice(1)];\n    } else {\n        return [hidden, str];\n    }\n}\n\n/**\n * Determines if the given value might represent an email address.\n * @param value The value to check.\n */\nexport function mightBeEmailAddress(value: string): boolean {\n    // Test that the value ends with an @ symbol and some characters and a dot (.) and some more characters.\n    const emailTest = /\\@.+\\.\\w{2,}$/;\n    return emailTest.test(value);\n}\n\n/**\n * Trims the given value and removes characters that are not valid in a phone number.\n * Returns null if the value is definitely not a phone number.\n * @param value The value that should be cleaned.\n */\nexport function cleanPhoneNumber(value: string): string {\n    let sms = value.trim().replace(/[^\\d+]/g, '');\n\n    if (!sms) {\n        return null;\n    }\n\n    if (!sms.startsWith('+')) {\n        if (sms.length > 10) {\n            // for US phone numbers, 10 characters make up a country-code less phone number\n            // 3 for area code,\n            sms = '+' + sms;\n        } else if (sms.length > 7) {\n            sms = '+1' + sms;\n        } else {\n            sms = '+1616' + sms;\n        }\n    }\n\n    return sms;\n}\n","import { TagEditOp } from '../aux-format-2';\n\nexport type PartialBot = Partial<Bot>;\n\nexport type AuxDomain = 'builder' | 'player';\n\nexport type Workspace = Bot;\n\n/**\n * Defines a symbol that is used to clear changes on a runtime bot.\n */\nexport const CLEAR_CHANGES_SYMBOL = Symbol('clear_changes');\n\n/**\n * Defines a symbol that is used to set a tag mask on a runtime bot.\n */\nexport const SET_TAG_MASK_SYMBOL = Symbol('set_tag_mask');\n\n/**\n * Defines a symbol that is used to get a tag mask on a runtime bot.\n */\nexport const GET_TAG_MASK_SYMBOL = Symbol('get_tag_mask');\n\n/**\n * Defines a symbol that is used to get all the tag masks on a runtime bot.\n */\nexport const CLEAR_TAG_MASKS_SYMBOL = Symbol('clear_tag_masks');\n\n/**\n * Defines a symbol that is used to edit a tag.\n */\nexport const EDIT_TAG_SYMBOL = Symbol('edit_tag');\n\n/**\n * Defines a symbol that is used to edit a  tag mask.\n */\nexport const EDIT_TAG_MASK_SYMBOL = Symbol('edit_tag_mask');\n\n/**\n * Defines a symbol that is used to get tag masks for a bot.\n */\nexport const GET_TAG_MASKS_SYMBOL = Symbol('get_tag_masks');\n\n/**\n * Defines an interface for a bot in a script/formula.\n *\n * The difference between this and Bot is that the tags\n * are calculated values and raw is the original tag values.\n *\n * i.e. tags will evaluate formulas while raw will return the formula scripts themselves.\n */\nexport interface RuntimeBot {\n    id: string;\n    link: string;\n    space?: BotSpace;\n\n    /**\n     * The calculated tag values.\n     * This lets you get the calculated values from formulas.\n     */\n    tags: ScriptTags;\n\n    /**\n     * The raw tag values. This lets you get the raw script text from formulas.\n     */\n    raw: BotTags;\n\n    /**\n     * The tag masks that have been applied to this bot.\n     */\n    masks: BotTags;\n\n    /**\n     * The tags on the bot that link to other bots.\n     */\n    links: RuntimeBotLinks;\n\n    /**\n     * The variables that the bot contains.\n     */\n    vars: RuntimeBotVars;\n\n    /**\n     * The changes that have been made to the bot.\n     */\n    changes: BotTags;\n\n    /**\n     * The tag mask changes that have been made to the bot.\n     */\n    maskChanges: BotTagMasks;\n\n    /**\n     * The signatures that are on the bot.\n     */\n    signatures: BotSignatures;\n\n    /**\n     * The calculated listener functions.\n     * This lets you get the compiled listener functions.\n     */\n    listeners: CompiledBotListeners;\n\n    /**\n     * A function that can clear all the changes from the runtime bot.\n     */\n    [CLEAR_CHANGES_SYMBOL]: () => void;\n\n    /**\n     * A function that can set a tag mask on the bot.\n     */\n    [SET_TAG_MASK_SYMBOL]: (tag: string, value: any, space?: string) => void;\n\n    /**\n     * A function that can be used to get the tag masks for a bot.\n     */\n    [GET_TAG_MASKS_SYMBOL]: () => BotTagMasks;\n\n    /**\n     * A function that can clear the tag masks from the bot.\n     * @param space The space that the masks should be cleared from. If not specified then all tag masks in all spaces will be cleared.\n     */\n    [CLEAR_TAG_MASKS_SYMBOL]: (space?: string) => any;\n\n    /**\n     * A function that can manipulate a tag using the given edit operations.\n     */\n    [EDIT_TAG_SYMBOL]: (tag: string, ops: TagEditOp[]) => any;\n\n    /**\n     * A function that can manipulate a tag mask using the given edit operations.\n     */\n    [EDIT_TAG_MASK_SYMBOL]: (\n        tag: string,\n        ops: TagEditOp[],\n        space: string\n    ) => any;\n\n    /**\n     * Gets the listener with the given name.\n     */\n    [listener: string]: CompiledBotListener | any;\n}\n\n/**\n * Defines an interface that represents a bot link that was parsed from a tag.\n */\nexport interface ParsedBotLink {\n    /**\n     * The tag that the link was parsed from.\n     */\n    tag: string;\n\n    /**\n     * The bot IDs that the link references.\n     */\n    botIDs: string[];\n}\n\n/**\n * Defines an interface that represents the bot links a bot can have.\n */\nexport interface RuntimeBotLinks {\n    [tag: string]: RuntimeBot | RuntimeBot[];\n}\n\n/**\n * Defines an interface that represents the variables a bot can have.\n */\nexport interface RuntimeBotVars {\n    [variable: string]: any;\n}\n\n/**\n * An interface that maps tag names to compiled listener functions.\n */\nexport interface CompiledBotListeners {\n    [tag: string]: CompiledBotListener;\n}\n\n/**\n * The type of a compiled bot listener.\n */\nexport type CompiledBotListener = (arg?: any) => any;\n\n/**\n * Defines an interface for a bot that is precalculated.\n */\nexport interface PrecalculatedBot extends Bot {\n    /**\n     * Flag indicating that the bot is precalculated.\n     */\n    precalculated: true;\n\n    /**\n     * The precalculated tags.\n     */\n    values: PrecalculatedTags;\n}\n\n/**\n * Defines an interface for an object that holds a set of tags that have been precalculated.\n */\nexport interface PrecalculatedTags {\n    [key: string]: any;\n}\n\n/**\n * Defines an interface for a bot.\n */\nexport interface Bot {\n    /**\n     * The ID of the bot.\n     */\n    id: string;\n\n    /**\n     * The space the bot lives in.\n     */\n    space?: BotSpace;\n\n    /**\n     * The set of tags that the bot contains.\n     */\n    tags: BotTags;\n\n    /**\n     * The set of signatures that the bot contains.\n     */\n    signatures?: BotSignatures;\n\n    /**\n     * The set of tag masks that have been applied to the bot.\n     */\n    masks?: BotTagMasks;\n}\n\n/**\n * Defines an interface for a record.\n */\nexport interface Record {\n    /**\n     * The address that the record was published at.\n     */\n    address: string;\n\n    /**\n     * The space that the record was published to.\n     */\n    space: RecordSpace;\n\n    /**\n     * The auth ID that published the record.\n     */\n    authID: string;\n\n    /**\n     * The data that was stored in the record.\n     */\n    data?: any;\n    dataURL?: string;\n}\n\n/**\n * Defines an interface for an object that represents a reference to a specific record.\n */\nexport interface RecordReference {\n    /**\n     * The ID of the user that published the record.\n     */\n    authID: string;\n\n    /**\n     * The space that the record lives in.\n     */\n    space: RecordSpace;\n\n    /**\n     * The address that the record was published to.\n     */\n    address: string;\n}\n\n/**\n * Defines an interface that indicates a bot was updated.\n */\nexport interface UpdatedBot {\n    /**\n     * The updated bot.\n     */\n    bot: Bot;\n\n    /**\n     * The tags that were updated on the bot.\n     */\n    tags: string[];\n\n    /**\n     * The signatures that were updated on the bot.\n     */\n    signatures?: string[];\n}\n\n/**\n * The possible bot types.\n *\n * - \"shared\" means that the bot is a normal bot.\n * - \"local\" means that the bot is stored in the local storage partition.\n * - \"tempLocal\" means that the bot is stored in the temporary partition.\n * - \"history\" means that the bot represents a version of another space.\n * - \"admin\" means that the bot is shared across all instances.\n * - \"tempShared\" means that the bot is temporary and shared with other devices.\n * - \"remoteTempShared\" means that the bot is temporary and shared with this device from a remote device.\n * - \"certified\" means that the bot is a certificate.\n */\nexport type BotSpace =\n    | 'shared'\n    | 'local'\n    | 'tempLocal'\n    | 'history'\n    | 'admin'\n    | 'tempShared'\n    | 'remoteTempShared'\n    | 'certified';\n\n/**\n * The possible spaces that records can be stored in.\n *\n * - \"tempGlobal\" means that the record is temporary and available to anyone.\n * - \"tempRestricted\" means that the record is temporary and available to a specific user.\n * - \"permanentGlobal\" means that the record is permanent and available to anyone.\n * - \"permanentRestricted\" means that the record is permanent and available to a specific user.\n */\nexport type RecordSpace =\n    | 'tempGlobal'\n    | 'tempRestricted'\n    | 'permanentGlobal'\n    | 'permanentRestricted';\n\n/**\n * The space that records should be published to by default.\n */\nexport const DEFAULT_RECORD_SPACE: RecordSpace = 'tempRestricted';\n\n/**\n * The possible portal types.\n */\nexport type PortalType =\n    | 'grid'\n    | 'miniGrid'\n    | 'menu'\n    | 'sheet'\n    | 'meet'\n    | string;\n\nexport interface ScriptTags extends PrecalculatedTags {\n    toJSON(): any;\n}\n\n/**\n * Defines an interface for a map of tag+value hashes to tag names.\n *\n * Each key in the object is the hash of an array with the tag name as the first value\n * and the value as the second value using the getHash() function from the crypto package.\n *\n * This means that you can lookup if a tag/value pair has a hash by simply calculating the hash for it and then checking if the corresponding value\n * in the object is set to true.\n */\nexport interface BotSignatures {\n    [hash: string]: string;\n}\n\n/**\n * Defines an interface for a map of tag masks to tag names.\n *\n * Tag masks are special tags that can exist in a different space from the bot they are applied to.\n * This makes it possible to have some local-only data applied to a shared bot for example.\n *\n * The actual data structure is similar to the bot tags structure except that tags are additionally\n * split by the space that they originated from. This makes it possible to identify which space a tag came from and also\n * prevents cross-space conflicts.\n */\nexport interface BotTagMasks {\n    [space: string]: BotTags;\n}\n\nexport interface BotTags {\n    // Normal bot tags\n    ['color']?: unknown;\n    ['draggable']?: unknown;\n    ['draggableMode']?: unknown;\n    ['destroyable']?: unknown;\n    ['editable']?: unknown;\n    ['strokeColor']?: unknown;\n    ['strokeWidth']?: unknown;\n    ['scale']?: number;\n    ['scaleX']?: number;\n    ['scaleY']?: number;\n    ['scaleZ']?: number;\n    ['scaleMode']?: BotScaleMode | null | string;\n    ['lineTo']?: unknown;\n    ['lineWidth']?: number;\n    ['lineStyle']?: unknown;\n    ['lineColor']?: unknown;\n    ['label']?: unknown;\n    ['labelColor']?: unknown;\n    ['labelSize']?: unknown;\n    ['labelSizeMode']?: 'auto' | null;\n    ['labelPosition']?: BotLabelAnchor | null | string;\n    ['labelAlignment']?: BotLabelAlignment | null | string;\n    ['labelFontAddress']?: BotLabelFontAddress;\n    ['listening']?: unknown;\n    ['form']?: BotShape;\n    ['formAnimation']?: string;\n    ['formAddress']?: string;\n    ['orientationMode']?: string;\n    ['anchorPoint']?: string;\n    ['creator']?: string;\n    ['progressBar']?: unknown;\n    ['progressBarColor']?: unknown;\n    ['progressBarBackgroundColor']?: unknown;\n    ['progressBarPosition']?: unknown;\n    ['pointable']?: unknown;\n    ['focusable']?: unknown;\n\n    // User tags\n    ['auxPlayerActive']?: boolean;\n    ['gridPortal']?: string | boolean;\n    ['sheetPortal']?: string | boolean;\n    ['inst']?: string | string[];\n    ['miniGridPortal']?: string;\n    ['menuPortal']?: string;\n    ['leftWristPortal']?: string;\n    ['rightWristPortal']?: string;\n    ['editingBot']?: string;\n    cursorStartIndex?: number;\n    cursorEndIndex?: number;\n    ['pixelWidth']?: number;\n    ['pixelHeight']?: number;\n\n    // Admin channel task tags\n    ['auxRunningTasks']?: boolean;\n    ['auxFinishedTasks']?: boolean;\n    ['taskOutput']?: unknown;\n    ['taskError']?: unknown;\n    ['taskTime']?: unknown;\n    ['taskShell']?: string;\n    ['taskBackup']?: boolean;\n    ['taskBackupType']?: BackupType;\n    ['taskBackupUrl']?: string;\n\n    // Context related tags\n    ['portalColor']?: string;\n    ['portalLocked']?: unknown;\n    ['portalGridScale']?: number;\n    ['portalSurfaceScale']?: number;\n    ['portalCameraRotationX']?: number;\n    ['portalCameraRotationY']?: number;\n    ['portalCameraZoom']?: number;\n    ['portalPannable']?: number | null;\n    [`portalPannableMinX`]?: number | null;\n    [`portalPannableMaxX`]?: number | null;\n    [`portalPannableMinY`]?: number | null;\n    [`portalPannableMaxY`]?: number | null;\n    ['portalZoomable']?: number | null;\n    [`portalZoomableMin`]?: number | null;\n    [`portalZoomableMax`]?: number | null;\n    ['portalRotatable']?: number | null;\n    ['portalShowFocusPoint']?: boolean | null;\n    ['portalDisableCanvasTransparency']?: boolean;\n    ['miniPortalHeight']?: unknown;\n    ['miniPortalResizable']?: boolean;\n    ['wristPortalHeight']?: number;\n    ['wristPortalWidth']?: number;\n\n    // Stripe tags\n    ['stripeCharges']?: boolean;\n    ['stripeSuccessfulCharges']?: boolean;\n    ['stripeFailedCharges']?: boolean;\n    ['stripeCharge']?: string;\n    ['stripeChargeReceiptUrl']?: string;\n    ['stripeChargeReceiptNumber']?: string;\n    ['stripeChargeDescription']?: string;\n    ['stripeOutcomeNetworkStatus']?: string;\n    ['stripeOutcomeReason']?: string;\n    ['stripeOutcomeRiskLevel']?: string;\n    ['stripeOutcomeRiskScore']?: number;\n    ['stripeOutcomeRule']?: string | string[];\n    ['stripeOutcomeSellerMessage']?: string;\n    ['stripeOutcomeType']?: string;\n    ['stripeErrors']?: boolean;\n    ['stripeError']?: string;\n    ['stripeErrorType']?: string;\n\n    [key: string]: any;\n}\n\n/**\n * Defines an interface for the state that an AUX bot can contain.\n */\nexport interface BotsState {\n    [id: string]: Bot;\n}\n\n/**\n * Defines an interface for a partial bot state.\n */\nexport interface PartialBotsState {\n    [id: string]: PartialBot;\n}\n\n/**\n * Defines an interface for a set of bots that have precalculated formulas.\n */\nexport interface PrecalculatedBotsState {\n    [id: string]: PrecalculatedBot;\n}\n\n/**\n * Defines an interface for a partial set of bots that have precalculated formulas.\n */\nexport interface PartialPrecalculatedBotsState {\n    [id: string]: Partial<PrecalculatedBot>;\n}\n\n/**\n * Defines an interface for a hex in a workspace.\n */\nexport interface WorkspaceHex {\n    height: number;\n}\n\n/**\n * Defines the possible shapes that a bot can appear as.\n */\nexport type BotShape =\n    | 'cube'\n    | 'circle'\n    | 'sphere'\n    | 'sprite'\n    | 'mesh'\n    | 'iframe'\n    | 'frustum'\n    | 'helix'\n    | 'egg'\n    | 'hex'\n    | 'cursor'\n    | 'portal'\n    | 'dimension'\n    | 'nothing'\n    | 'keyboard';\n\n/**\n * Defines the possible forms that a menu bot can appear as.\n */\nexport type MenuBotForm = 'button' | 'input';\n\n/**\n * Defines the possible hover styles that can be used for a menu bot.\n * Currently only applies to button menu bots.\n */\nexport type MenuBotHoverStyle = 'auto' | 'hover' | 'none';\n\n/**\n * Defines the possible hover styles that have been resolved from a bot.\n */\nexport type MenuBotResolvedHoverStyle = 'hover' | 'none';\n\n/**\n * Defines the possible subtypes for shapes that a bot can appear as.\n */\nexport type BotSubShape = 'gltf' | 'src' | 'html' | null;\n\n/**\n * Defines the possible drag modes that a bot can have.\n *\n * \"all\" means that the bot is able to be dragged freely inside and across contexts.\n * \"none\" means that the bot is not able to be dragged at all.\n * \"pickupOnly\" means that the bot should be able to be dragged across contexts but not within a dimension.\n * \"moveOnly\" means that the bot should be able to be dragged within a dimension but not across contexts.\n */\nexport type BotDragMode = 'all' | 'none' | 'moveOnly' | 'pickupOnly';\n\n/**\n * Defines the possible positioning modes that a bot can have.\n *\n * \"stack\" means the bot is able to stack with other bots.\n * \"absolute\" means the bot will ignore other bots.\n */\nexport type BotPositioningMode = 'stack' | 'absolute';\n\n/**\n * Defines the possible scaling modes that a bot's mesh can have.\n *\n * \"fit\" means that the mesh is scaled to fit inside its bot unit cube.\n * \"absolute\" means that the mesh is not scaled to fit inside the bot unit cube.\n */\nexport type BotScaleMode = 'fit' | 'absolute';\n\n/**\n * Defines the possible anchor positions for a label.\n */\nexport type BotLabelAnchor =\n    | 'top'\n    | 'front'\n    | 'back'\n    | 'left'\n    | 'right'\n    | 'floating';\n\n/**\n * Defines the possible label alignment types.\n */\nexport type BotLabelAlignment = 'center' | 'left' | 'right';\n\n/**\n * Defines the possible label font addresses.\n */\nexport type BotLabelFontAddress = 'roboto' | 'noto-sans-kr' | string;\n\n/**\n * Defines the possible label font sizes.\n */\nexport type BotLabelFontSize = 'auto' | number;\n\nexport type BotLabelWordWrap = 'breakWords' | 'breakCharacters' | 'none';\n\n/**\n * Defines the possible bot orientation modes.\n */\nexport type BotOrientationMode =\n    | 'absolute'\n    | 'billboard'\n    | 'billboardTop'\n    | 'billboardFront';\n\n/**\n * Defines the possible bot anchor points.\n */\nexport type BotAnchorPoint =\n    | 'top'\n    | 'front'\n    | 'back'\n    | 'left'\n    | 'right'\n    | 'bottom'\n    | 'center'\n    | readonly [number, number, number];\n\n/**\n * Defines the possible meet portal anchor points.\n */\nexport type MeetPortalAnchorPoint =\n    | 'fullscreen'\n    | 'top'\n    | 'topRight'\n    | 'topLeft'\n    | 'bottom'\n    | 'bottomRight'\n    | 'bottomLeft'\n    | 'left'\n    | 'right'\n    | [number | string]\n    | [number | string, number | string]\n    | [number | string, number | string, number | string]\n    | [number | string, number | string, number | string, number | string];\n\n/**\n * Defines the possible backup types.\n */\nexport type BackupType = 'github' | 'download';\n\n/**\n * Defines the possible dimension visualize modes.\n *\n * true means that the dimension is visible.\n * false means the dimension is not visible.\n * \"surface\" means the dimension is visible and renders a worksurface.\n */\nexport type DimensionVisualizeMode = true | false | 'surface';\n\n/**\n * The possible LODs for a bot.\n */\nexport type BotLOD = 'normal' | 'min' | 'max';\n\n/**\n * The possible camera control modes.\n */\nexport type PortalCameraControlsMode = 'player' | false;\n\n/**\n * The possible camera types.\n */\nexport type PortalCameraType = 'orthographic' | 'perspective';\n\n/**\n * The possible bot cursors.\n */\nexport type BotCursorType =\n    | 'auto'\n    | 'default'\n    | 'none'\n    | 'context-menu'\n    | 'help'\n    | 'pointer'\n    | 'progress'\n    | 'wait'\n    | 'cell'\n    | 'crosshair'\n    | 'text'\n    | 'vertical-text'\n    | 'alias'\n    | 'copy'\n    | 'move'\n    | 'no-drop'\n    | 'not-allowed'\n    | 'grab'\n    | 'grabbing'\n    | 'all-scroll'\n    | 'col-resize'\n    | 'row-resize'\n    | 'n-resize'\n    | 'e-resize'\n    | 's-resize'\n    | 'w-resize'\n    | 'ne-resize'\n    | 'nw-resize'\n    | 'se-resize'\n    | 'sw-resize'\n    | 'ew-resize'\n    | 'ns-resize'\n    | 'nesw-resize'\n    | 'nwse-resize'\n    | 'zoom-in'\n    | 'zoom-out'\n    | BotCursorLink;\n\nexport interface BotCursorLink {\n    type: 'link';\n    url: string;\n    x: number;\n    y: number;\n}\n\n/**\n * Defines an interface that represents the padding that a bot label should have.\n */\nexport interface BotLabelPadding {\n    /**\n     * The horizontal padding that the label should have.\n     */\n    horizontal: number;\n\n    /**\n     * The vertical padding that the label should have.\n     */\n    vertical: number;\n}\n\n/**\n * The default bot cursor.\n */\nexport const DEFAULT_BOT_CURSOR: BotCursorType = 'auto';\n\n/**\n * The default bot shape.\n */\nexport const DEFAULT_BOT_SHAPE: BotShape = 'cube';\n\n/**\n * The default menu bot form.\n */\nexport const DEFAULT_MENU_BOT_FORM: MenuBotForm = 'button';\n\n/**\n * The default menu bot hover style.\n */\nexport const DEFAULT_MENU_BOT_HOVER_STYLE: MenuBotHoverStyle = 'auto';\n\n/**\n * The default bot label anchor.\n */\nexport const DEFAULT_LABEL_ANCHOR: BotLabelAnchor = 'top';\n\n/**\n * The default bot label alignment.\n */\nexport const DEFAULT_LABEL_ALIGNMENT: BotLabelAlignment = 'center';\n\n/**\n * The default bot scale mode.\n */\nexport const DEFAULT_SCALE_MODE: BotScaleMode = 'fit';\n\n/**\n * The default bot orientation mode.\n */\nexport const DEFAULT_ORIENTATION_MODE: BotOrientationMode = 'absolute';\n\n/**\n * The default bot orientation mode.\n */\nexport const DEFAULT_ANCHOR_POINT: BotAnchorPoint = 'bottom';\n\n/**\n * The default portal camera controls mode.\n */\nexport const DEFAULT_PORTAL_CAMERA_CONTROLS_MODE: PortalCameraControlsMode =\n    'player';\n\n/**\n * The default bot label font address.\n */\nexport const DEFAULT_LABEL_FONT_ADDRESS: BotLabelFontAddress = 'rotobo';\n\n/**\n * The default bot label font address.\n */\nexport const DEFAULT_LABEL_FONT_SIZE: BotLabelFontSize = 'auto';\n\n/**\n * The default bot label word wrapping mode.\n */\nexport const DEFAULT_LABEL_WORD_WRAP_MODE: BotLabelWordWrap = 'breakCharacters';\n\n/**\n * Whether canvas transparency is disabled by default.\n */\nexport const DEFAULT_PORTAL_DISABLE_CANVAS_TRANSPARENCY: boolean = false;\n\n/**\n * The default height for workspaces.\n */\nexport const DEFAULT_WORKSPACE_HEIGHT = 0.1;\n\n/**\n * The default size for workspaces.\n */\nexport const DEFAULT_WORKSPACE_SIZE = 1;\n\n/**\n * The default scale for workspaces.\n */\nexport const DEFAULT_WORKSPACE_SCALE = 2;\n\n/**\n * The default scale for mini workspaces.\n */\nexport const DEFAULT_MINI_WORKSPACE_SCALE = DEFAULT_WORKSPACE_SCALE / 3;\n\n/**\n * The default grid scale for workspaces.\n */\nexport const DEFAULT_WORKSPACE_GRID_SCALE = 0.2;\n\n/**\n * The amount that a hex's height is allowed to change by in a single increment.\n */\nexport const DEFAULT_WORKSPACE_HEIGHT_INCREMENT = 0.1;\n\n/**\n * The minimum height that hexes in a workspace can be.\n */\nexport const DEFAULT_WORKSPACE_MIN_HEIGHT = 0.1;\n\n/**\n * The default color for workspaces.\n */\nexport const DEFAULT_WORKSPACE_COLOR = '#999999';\n\n/**\n * The default color for scene background.\n */\nexport const DEFAULT_SCENE_BACKGROUND_COLOR = '#263238';\n\n/**\n * The default color for users in AUX Builder.\n */\nexport const DEFAULT_BUILDER_USER_COLOR = '#00D000';\n\n/**\n * The default color for users in AUX Player.\n */\nexport const DEFAULT_PLAYER_USER_COLOR = '#DDDD00';\n\n/**\n * The amount of time that a user needs to be inactive for\n * in order to hide their bot.\n */\nexport const DEFAULT_USER_INACTIVE_TIME = 1000 * 60;\n\n/**\n * The amount of time that a user needs to be inactive for\n * in order to delete their bot.\n */\nexport const DEFAULT_USER_DELETION_TIME = 1000 * 60 * 60;\n\n/**\n * Whether the miniGridPortal is visible by default.\n */\nexport const DEFAULT_MINI_PORTAL_VISIBLE = false;\n\n/**\n * Whether the map portal is visible by default.\n */\nexport const DEFAULT_MAP_PORTAL_VISIBLE = false;\n\n/**\n * The default scale for the map portal grid.\n */\nexport const DEFAULT_MAP_PORTAL_SCALE = 1;\n\n/**\n * The default grid scale for the map portal.\n */\nexport const DEFAULT_MAP_PORTAL_GRID_SCALE = 10;\n\n/**\n * The default basemap that should be used for the map portal.\n * See https://developers.arcgis.com/javascript/latest/api-reference/esri-Map.html#basemap\n */\nexport const DEFAULT_MAP_PORTAL_BASEMAP = 'dark-gray';\n\n/**\n * The default longitude that the map portal should show.\n */\nexport const DEFAULT_MAP_PORTAL_LONGITUDE = -84.71112905478944;\n\n/**\n * The default latitude that the map portal should show.\n */\nexport const DEFAULT_MAP_PORTAL_LATITUDE = 43.152972972972975;\n\n/**\n * The default zoom that the map portal should show.\n */\nexport const DEFAULT_MAP_PORTAL_ZOOM = 7;\n\n/**\n * Whether portals are pannable by default.\n */\nexport const DEFAULT_PORTAL_PANNABLE = true;\n\n/**\n * Whether portals are rotatable by default.\n */\nexport const DEFAULT_PORTAL_ROTATABLE = true;\n\n/**\n * Whether portals are zoomable by default.\n */\nexport const DEFAULT_PORTAL_ZOOMABLE = true;\n\n/**\n * Whether portals should show their focus point.\n */\nexport const DEFAULT_PORTAL_SHOW_FOCUS_POINT = false;\n\n/**\n * Whether miniGridPortals are resizable by default.\n */\nexport const DEFAULT_MINI_PORTAL_RESIZABLE = true;\n\n/**\n * The default height for miniGridPortals.\n */\nexport const DEFAULT_MINI_PORTAL_HEIGHT = 0.2;\n\n/**\n * The default height for wrist portals.\n */\nexport const DEFAULT_WRIST_PORTAL_HEIGHT = 6;\n\n/**\n * The default width for wrist portals.\n */\nexport const DEFAULT_WRIST_PORTAL_WIDTH = 6;\n\n/**\n * The default grid scale for wrist portals.\n */\nexport const DEFAULT_WRIST_PORTAL_GRID_SCALE = 0.025;\n\n/**\n * The default anchor point for the meet portal.\n */\nexport const DEFAULT_MEET_PORTAL_ANCHOR_POINT: MeetPortalAnchorPoint =\n    'fullscreen';\n\n/**\n * The default anchor point for the tag portal.\n */\nexport const DEFAULT_TAG_PORTAL_ANCHOR_POINT: MeetPortalAnchorPoint =\n    'fullscreen';\n\n/**\n * The default anchor point for the bot portal.\n */\nexport const DEFAULT_BOT_PORTAL_ANCHOR_POINT: MeetPortalAnchorPoint =\n    'fullscreen';\n\n/**\n * The default anchor point for custom portals.\n */\nexport const DEFAULT_CUSTOM_PORTAL_ANCHOR_POINT: MeetPortalAnchorPoint = 'top';\n\n/**\n * The default bot LOD.\n */\nexport const DEFAULT_BOT_LOD: BotLOD = 'normal';\n\n/**\n * The default minimum LOD threshold.\n */\nexport const DEFAULT_BOT_LOD_MIN_THRESHOLD = 0.0005;\n\n/**\n * The default maximum LOD threshold.\n */\nexport const DEFAULT_BOT_LOD_MAX_THRESHOLD = 0.03;\n\n/**\n * The ID of the device configuration bot.\n */\nexport const DEVICE_BOT_ID = 'device';\n\n/**\n * The ID of the local configuration bot.\n */\nexport const LOCAL_BOT_ID = 'local';\n\n/**\n * The ID of the cookie configuration bot.\n */\nexport const COOKIE_BOT_ID = 'cookie';\n\n/**\n * THe partition ID for cookie bots.\n */\nexport const COOKIE_BOT_PARTITION_ID = 'local';\n\n/**\n * The partition ID for temporary bots.\n */\nexport const TEMPORARY_BOT_PARTITION_ID = 'tempLocal';\n\n/**\n * The partition ID for admin bots.\n */\nexport const ADMIN_PARTITION_ID = 'admin';\n\n/**\n * The partition ID for temporary shared bots.\n */\nexport const TEMPORARY_SHARED_PARTITION_ID = 'tempShared';\n\n/**\n * The partition ID for bots that are automatically added to the instance.\n */\nexport const BOOTSTRAP_PARTITION_ID = 'bootstrap';\n\n/**\n * The partition ID for other temp shared bots.\n */\nexport const REMOTE_TEMPORARY_SHARED_PARTITION_ID = 'remoteTempShared';\n\n/**\n * The space that tag masks get placed in by default.\n */\nexport const DEFAULT_TAG_MASK_SPACE: BotSpace = 'tempLocal';\n\n/**\n * The list of spaces that tag masks should be prioritized by.\n * Listed in reverse order of where they actually end up applied.\n */\nexport const TAG_MASK_SPACE_PRIORITIES_REVERSE = [\n    'admin',\n    'shared',\n    'remoteTempShared',\n    'tempShared',\n    'local',\n    'tempLocal',\n] as BotSpace[];\n\n/**\n * The list of spaces that tag masks should be prioritized by.\n */\nexport const TAG_MASK_SPACE_PRIORITIES = [\n    'tempLocal',\n    'local',\n    'tempShared',\n    'remoteTempShared',\n    'shared',\n    'admin',\n] as BotSpace[];\n\n/**\n * The name of the branch that contains admin space.\n */\nexport const ADMIN_BRANCH_NAME = '$admin';\n\n/**\n * The name of the tag used to represent the space that the bot is\n * stored in.\n */\nexport const BOT_SPACE_TAG = 'space';\n\n/**\n * The name of the event that represents a bot being diffed into another bot.\n */\nexport const MOD_DROP_ACTION_NAME: string = 'onModDrop';\n\n/**\n * The name of the event that represents a bot being created.\n */\nexport const CREATE_ACTION_NAME: string = 'onCreate';\n\n/**\n * The name of the event that represents any bot being created.\n */\nexport const CREATE_ANY_ACTION_NAME: string = 'onAnyCreate';\n\n/**\n * The name of the event that represents a bot being destroyed.\n */\nexport const DESTROY_ACTION_NAME: string = 'onDestroy';\n\n/**\n * The name of the event that represents a bot being clicked.\n */\nexport const CLICK_ACTION_NAME: string = 'onClick';\n\n/**\n * The name of the event that represents any bot being clicked.\n */\nexport const ANY_CLICK_ACTION_NAME: string = 'onAnyBotClicked';\n\n/**\n * The name of the event that represents a bot entering over another bot.\n */\nexport const DROP_ENTER_ACTION_NAME: string = 'onDropEnter';\n\n/**\n * The name of the event that represents a bot exiting from over another bot.\n */\nexport const DROP_EXIT_ACTION_NAME: string = 'onDropExit';\n\n/**\n * The name of the event that represents a bot entering over another bot.\n */\nexport const ANY_DROP_ENTER_ACTION_NAME: string = 'onAnyBotDropEnter';\n\n/**\n * The name of the event that represents a bot exiting from over another bot.\n */\nexport const ANY_DROP_EXIT_ACTION_NAME: string = 'onAnyBotDropExit';\n\n/**\n * The name of the event that represents a bot being dropped onto a dimension.\n */\nexport const DROP_ACTION_NAME: string = 'onDrop';\n\n/**\n * The name of the event that represents any bot being dropped onto a dimension.\n */\nexport const DROP_ANY_ACTION_NAME: string = 'onAnyBotDrop';\n\n/**\n * The name of the event that represents a bot starting to be dragged.\n */\nexport const DRAG_ACTION_NAME: string = 'onDrag';\n\n/**\n * The name of the event that represents any bot starting to be dragged.\n */\nexport const DRAG_ANY_ACTION_NAME: string = 'onAnyBotDrag';\n\n/**\n * The name of the event that represents a bot being dragged.\n */\nexport const DRAGGING_ACTION_NAME: string = 'onDragging';\n\n/**\n * The name of the event that represents any bot being dragged.\n */\nexport const DRAGGING_ANY_ACTION_NAME: string = 'onAnyBotDragging';\n\n/**\n * The name of the event that represents a mod entering over a bot.\n */\nexport const MOD_DROP_ENTER_ACTION_NAME: string = 'onModDropEnter';\n\n/**\n * The name of the event that represents a mod exiting from over a bot.\n */\nexport const MOD_DROP_EXIT_ACTION_NAME: string = 'onModDropExit';\n\n/**\n * The name of the event that is triggered when a pointer starts hovering a bot.\n */\nexport const ON_POINTER_ENTER: string = 'onPointerEnter';\n\n/**\n * The name of the event that is triggered when a pointer stops hovering a bot.\n */\nexport const ON_POINTER_EXIT: string = 'onPointerExit';\n\n/**\n * The name of the event that is triggered when a pointer starts hovering any bot.\n */\nexport const ON_ANY_POINTER_ENTER: string = 'onAnyBotPointerEnter';\n\n/**\n * The name of the event that is triggered when a pointer stops hovering any bot.\n */\nexport const ON_ANY_POINTER_EXIT: string = 'onAnyBotPointerExit';\n\n/**\n * The name of the event that is triggered when a pointer starts clicking a bot.\n */\nexport const ON_POINTER_DOWN: string = 'onPointerDown';\n\n/**\n * The name of the event that is triggered when a pointer stops clicking a bot.\n */\nexport const ON_POINTER_UP: string = 'onPointerUp';\n\n/**\n * The name of the event that is triggered when a pointer starts hovering any bot.\n */\nexport const ON_ANY_POINTER_DOWN: string = 'onAnyBotPointerDown';\n\n/**\n * The name of the event that is triggered when a pointer stops hovering any bot.\n */\nexport const ON_ANY_POINTER_UP: string = 'onAnyBotPointerUp';\n\n/**\n * The name of the event that is triggered when a QR Code is scanned.\n */\nexport const ON_QR_CODE_SCANNED_ACTION_NAME: string = 'onQRCodeScanned';\n\n/**\n * The name of the event that is triggered when the QR Code scanner is closed.\n */\nexport const ON_QR_CODE_SCANNER_CLOSED_ACTION_NAME: string =\n    'onQRCodeScannerClosed';\n\n/**\n * The name of the event that is triggered when the QR Code scanner is opened.\n */\nexport const ON_QR_CODE_SCANNER_OPENED_ACTION_NAME: string =\n    'onQRCodeScannerOpened';\n\n/**\n * The name of the event that is triggered when the Barcode scanner is closed.\n */\nexport const ON_BARCODE_SCANNER_CLOSED_ACTION_NAME: string =\n    'onBarcodeScannerClosed';\n\n/**\n * The name of the event that is triggered when the Barcode scanner is opened.\n */\nexport const ON_BARCODE_SCANNER_OPENED_ACTION_NAME: string =\n    'onBarcodeScannerOpened';\n\n/**\n * The name of the event that is triggered when a Barcode is scanned.\n */\nexport const ON_BARCODE_SCANNED_ACTION_NAME: string = 'onBarcodeScanned';\n\n/**\n * The name of the event that is triggered when the image classifier is closed.\n */\nexport const ON_IMAGE_CLASSIFIER_CLOSED_ACTION_NAME: string =\n    'onImageClassifierClosed';\n\n/**\n * The name of the event that is triggered when the image classifier is opened.\n */\nexport const ON_IMAGE_CLASSIFIER_OPENED_ACTION_NAME: string =\n    'onImageClassifierOpened';\n\n/**\n * The name of the event that is triggered when an image is classified.\n */\nexport const ON_IMAGE_CLASSIFIED_ACTION_NAME: string = 'onImageClassified';\n\n/**\n * The name of the event that is triggered when the checkout process is completed.\n */\nexport const ON_CHECKOUT_ACTION_NAME: string = 'onCheckout';\n\n/**\n * The name of the event that is triggered when payment has been approved for the checkout.\n */\nexport const ON_PAYMENT_SUCCESSFUL_ACTION_NAME: string = 'onPaymentSuccessful';\n\n/**\n * The name of the event that is triggered when payment has been rejected for the checkout.\n */\nexport const ON_PAYMENT_FAILED_ACTION_NAME: string = 'onPaymentFailed';\n\n/**\n * The name of the event that is triggered when webhooks have been received.\n */\nexport const ON_WEBHOOK_ACTION_NAME: string = 'onWebhook';\n\n/**\n * The name of the event that is triggered on every bot when a shout has been executed.\n */\nexport const ON_ANY_SHOUT_ACTION_NAME: string = 'onAnyListen';\n\n/**\n * The name of the event that is triggered when a shout has been executed.\n */\nexport const ON_SHOUT_ACTION_NAME: string = 'onListen';\n\n/**\n * The name of the event that is triggered before an action is executed.\n */\nexport const ON_ACTION_ACTION_NAME: string = 'onAnyAction';\n\n/**\n * The name of the event that is triggered when a remote whisper is executed.\n */\n// TODO: Remove this action\nexport const ON_REMOTE_WHISPER_ACTION_NAME: string = 'onRemoteWhisper';\n\n/**\n * The name of the event that is triggered when a remote whisper is executed.\n */\nexport const ON_REMOTE_DATA_ACTION_NAME: string = 'onRemoteData';\n\n/**\n * The name of the event that is triggered when a channel becomes synced.\n */\nexport const ON_SERVER_STREAMING_ACTION_NAME: string = 'onServerStreaming';\n\n/**\n * The name of the event that is triggered when a channel has become unsynced.\n */\nexport const ON_SERVER_STREAM_LOST_ACTION_NAME: string = 'onServerStreamLost';\n\n/**\n * The name of the event that is triggered when a inst becomes synced.\n */\nexport const ON_INST_STREAMING_ACTION_NAME: string = 'onInstStreaming';\n\n/**\n * The name of the event that is triggered when a inst has become unsynced.\n */\nexport const ON_INST_STREAM_LOST_ACTION_NAME: string = 'onInstStreamLost';\n\n/**\n * The name of the event that is triggered when a channel is loaded.\n */\n// TODO: Remove this action\nexport const ON_SERVER_SUBSCRIBED_ACTION_NAME: string = 'onServerSubscribed';\n\n/**\n * The name of the event that is triggered when a channel is loaded.\n */\nexport const ON_SERVER_JOINED_ACTION_NAME: string = 'onServerJoined';\n\n/**\n * The name of the event that is triggered when a inst is loaded.\n */\nexport const ON_INST_JOINED_ACTION_NAME: string = 'onInstJoined';\n\n/**\n * The name of the event that is triggered when a channel is unloaded.\n */\n// TODO: Remove this action\nexport const ON_SERVER_UNSUBSCRIBED_ACTION_NAME: string =\n    'onServerUnsubscribed';\n\n/**\n * The name of the event that is triggered when a channel is unloaded.\n */\nexport const ON_SERVER_LEAVE_ACTION_NAME: string = 'onServerLeave';\n\n/**\n * The name of the event that is triggered when a channel is unloaded.\n */\nexport const ON_INST_LEAVE_ACTION_NAME: string = 'onInstLeave';\n\n/**\n * The name of the event that is triggered when portal tag is changed on the config bot.\n */\n// TODO: Remove this action\nexport const ON_PLAYER_PORTAL_CHANGED_ACTION_NAME: string =\n    'onPlayerPortalChanged';\n\n/**\n * The name of the event that is triggered when portal tag is changed on the config bot.\n */\nexport const ON_PORTAL_CHANGED_ACTION_NAME: string = 'onPortalChanged';\n\n/**\n * The name of the event that is triggered when a script is executed.\n */\nexport const ON_RUN_ACTION_NAME: string = 'onRun';\n\n/**\n * The name of the event that is triggered when the text in the chat bar is updated.\n */\nexport const ON_CHAT_TYPING_ACTION_NAME: string = 'onChatTyping';\n\n/**\n * The name of the event that is triggered when the text in the chat bar is submitted.\n */\nexport const ON_CHAT_ACTION_NAME: string = 'onChat';\n\n/**\n * The name of the event that is triggered when the text in a menu bot input is submitted.\n */\nexport const ON_SUBMIT_ACTION_NAME: string = 'onSubmit';\n\n/**\n * The name of the event that is triggered when the text in a menu bot input is updated.\n */\nexport const ON_INPUT_TYPING_ACTION_NAME: string = 'onInputTyping';\n\n/**\n * The name of the event that is triggered when text is pasted into aux.\n */\nexport const ON_PASTE_ACTION_NAME: string = 'onPaste';\n\n/**\n * The name of the event that is triggered when the maximum LOD is entered.\n */\nexport const ON_MAX_LOD_ENTER_ACTION_NAME: string = 'onMaxLODEnter';\n\n/**\n * The name of the event that is triggered when the minimum LOD is entered.\n */\nexport const ON_MIN_LOD_ENTER_ACTION_NAME: string = 'onMinLODEnter';\n\n/**\n * The name of the event that is triggered when the maximum LOD is exited.\n */\nexport const ON_MAX_LOD_EXIT_ACTION_NAME: string = 'onMaxLODExit';\n\n/**\n * The name of the event that is triggered when the minimum LOD is exited.\n */\nexport const ON_MIN_LOD_EXIT_ACTION_NAME: string = 'onMinLODExit';\n\n/**\n * The name of the event that is triggered when the maximum LOD is entered.\n */\nexport const ON_ANY_MAX_LOD_ENTER_ACTION_NAME: string = 'onAnyMaxLODEnter';\n\n/**\n * The name of the event that is triggered when the minimum LOD is entered.\n */\nexport const ON_ANY_MIN_LOD_ENTER_ACTION_NAME: string = 'onAnyMinLODEnter';\n\n/**\n * The name of the event that is triggered when the maximum LOD is exited.\n */\nexport const ON_ANY_MAX_LOD_EXIT_ACTION_NAME: string = 'onAnyMaxLODExit';\n\n/**\n * The name of the event that is triggered when the minimum LOD is exited.\n */\nexport const ON_ANY_MIN_LOD_EXIT_ACTION_NAME: string = 'onAnyMinLODExit';\n\n/**\n * The name of the event that is triggered when the grid is clicked.\n */\nexport const ON_GRID_CLICK_ACTION_NAME: string = 'onGridClick';\n\n/**\n * The name of the event that is triggered when the grid starts getting pressed.\n */\nexport const ON_GRID_UP_ACTION_NAME: string = 'onGridUp';\n\n/**\n * The name of the event that is triggered when the grid stops getting pressed.\n */\nexport const ON_GRID_DOWN_ACTION_NAME: string = 'onGridDown';\n\n/**\n * The name of the event that is triggered when a file is uploaded.\n */\nexport const ON_FILE_UPLOAD_ACTION_NAME: string = 'onFileUpload';\n\n/**\n * The name of the event that is triggerd when a bot gains camera focus.\n */\nexport const ON_FOCUS_ENTER_ACTION_NAME: string = 'onFocusEnter';\n\n/**\n * The name of the event that is triggerd when a bot loses camera focus.\n */\nexport const ON_FOCUS_EXIT_ACTION_NAME: string = 'onFocusExit';\n\n/**\n * The name of the event that is triggerd when a bot gains camera focus.\n */\nexport const ON_ANY_FOCUS_ENTER_ACTION_NAME: string = 'onAnyFocusEnter';\n\n/**\n * The name of the event that is triggerd when a bot loses camera focus.\n */\nexport const ON_ANY_FOCUS_EXIT_ACTION_NAME: string = 'onAnyFocusExit';\n\n/**\n * The name of the event that is triggered when a remote player joins the game.\n */\n// TODO: Remove this action\nexport const ON_REMOTE_PLAYER_SUBSCRIBED_ACTION_NAME: string =\n    'onRemotePlayerSubscribed';\n\n/**\n * The name of the event that is triggered when a remote player joins the game.\n */\nexport const ON_REMOTE_JOINED_ACTION_NAME: string = 'onRemoteJoined';\n\n/**\n * The name of the event that is triggered when a remote player leaves the game.\n */\n// TODO: Remove\nexport const ON_REMOTE_PLAYER_UNSUBSCRIBED_ACTION_NAME: string =\n    'onRemotePlayerUnsubscribed';\n\n/**\n * The name of the event that is triggered when a remote player leaves the game.\n */\nexport const ON_REMOTE_LEAVE_ACTION_NAME: string = 'onRemoteLeave';\n\n/**\n * The name of the event that is triggered when a bot is added to the local simulation.\n */\nexport const ON_BOT_ADDED_ACTION_NAME = 'onBotAdded';\n\n/**\n * The name of the event that is triggered when any bot is added to the local simulation.\n */\nexport const ON_ANY_BOTS_ADDED_ACTION_NAME = 'onAnyBotsAdded';\n\n/**\n * The name of the event that is triggered when any bot is removed from the local simulation.\n */\nexport const ON_ANY_BOTS_REMOVED_ACTION_NAME = 'onAnyBotsRemoved';\n\n/**\n * The name of the event that is triggered when a bot is changed.\n */\nexport const ON_BOT_CHANGED_ACTION_NAME = 'onBotChanged';\n\n/**\n * The name of the event that is triggered when any bot is changed in the local simulation.\n */\nexport const ON_ANY_BOTS_CHANGED_ACTION_NAME = 'onAnyBotsChanged';\n\n/**\n * The name of the event that is triggered when a tag is clicked in the sheet.\n */\nexport const ON_SHEET_TAG_CLICK = 'onSheetTagClick';\n\n/**\n * The name of the event that is triggered when a Bot's ID is clicked in the sheet.\n */\nexport const ON_SHEET_BOT_ID_CLICK = 'onSheetBotIDClick';\n\n/**\n * The name of the event that is triggered when a Bot is clicked in the sheet.\n */\nexport const ON_SHEET_BOT_CLICK = 'onSheetBotClick';\n\n/**\n * The name of the event that is triggered when a listen tag encounters an unhandled error.\n */\nexport const ON_ERROR = 'onError';\n\n/**\n * The name of the event that is triggered when a portal is being configured.\n */\nexport const ON_APP_SETUP_ACTION_NAME = 'onAppSetup';\n\n/**\n * The name of the event that is triggered when the root app has been setup.\n */\nexport const ON_DOCUMENT_AVAILABLE_ACTION_NAME: string = 'onDocumentAvailable';\n\n/**\n * The name of the event that is triggered when a keyboard button is clicked.\n */\nexport const ON_KEY_CLICK_ACTION_NAME = 'onKeyClick';\n\n/**\n * The tag used to set the space that the tag portal operates in.\n */\nexport const TAG_PORTAL_SPACE: string = 'tagPortalSpace';\n\n/**\n * The name of the event that is triggered when an audio sample is resolved.\n */\nexport const ON_AUDIO_SAMPLE: string = 'onAudioChunk';\n\n/**\n * The name of the event that is triggered when audio recording is started.\n */\nexport const ON_BEGIN_AUDIO_RECORDING: string = 'onBeginAudioRecording';\n\n/**\n * The name of the event that is triggered when audio recording is stopped.\n */\nexport const ON_END_AUDIO_RECORDING: string = 'onEndAudioRecording';\n\n/**\n * The name of the event that is triggered when VR is entered.\n */\nexport const ON_ENTER_VR: string = 'onEnterVR';\n\n/**\n * The name of the event that is triggered when VR is exited.\n */\nexport const ON_EXIT_VR: string = 'onExitVR';\n\n/**\n * The name of the event that is triggered when AR is entered.\n */\nexport const ON_ENTER_AR: string = 'onEnterAR';\n\n/**\n * The name of the event that is triggered when AR is exited.\n */\nexport const ON_EXIT_AR: string = 'onExitAR';\n\n/**\n * The name of the event that is triggered when the meet portal is finished loading.\n */\nexport const ON_MEET_LOADED: string = 'onMeetLoaded';\n\n/**\n * The name of the event that is triggered when the user meet portal is closed.\n */\nexport const ON_MEET_LEAVE: string = 'onMeetLeave';\n\n/**\n * The name of the event that is triggered when the user has entered a meet.\n */\nexport const ON_MEET_ENTERED: string = 'onMeetEntered';\n\n/**\n * The name of the event that is triggered when the user has exited a meet.\n */\nexport const ON_MEET_EXITED: string = 'onMeetExited';\n\n/**\n * The name of the event that is triggered when the user has joined a multimedia chat room.\n */\nexport const ON_ROOM_JOINED: string = 'onRoomJoined';\n\n/**\n * The name of the event that is triggered when the user has left a multimedia chat room.\n */\nexport const ON_ROOM_LEAVE: string = 'onRoomLeave';\n\n/**\n * The name of the event that is triggered when a multimedia track has been recieved.\n */\nexport const ON_ROOM_TRACK_SUBSCRIBED: string = 'onRoomTrackSubscribed';\n\n/**\n * The name of the event that is triggerd when a multimedia track has been lost.\n */\nexport const ON_ROOM_TRACK_UNSUBSCRIBED: string = 'onRoomTrackUnsubscribed';\n\n/**\n * The name of the event that is triggered when the user has become disconnected from a multimedia chat room.\n */\nexport const ON_ROOM_STREAM_LOST: string = 'onRoomStreamLost';\n\n/**\n * The name of the event that is triggered when the user has become connected to a multimedia chat room.\n */\nexport const ON_ROOM_STREAMING: string = 'onRoomStreaming';\n\n/**\n * The name of the event that is triggered when the list of active speakers has changed.\n */\nexport const ON_ROOM_SPEAKERS_CHANGED: string = 'onRoomSpeakersChanged';\n\n/**\n * The name of the event that is triggered when a remote user joins a multimedia chat room.\n */\nexport const ON_ROOM_REMOTE_JOINED: string = 'onRoomRemoteJoined';\n\n/**\n * The name of the event that is triggered when a remote user leaves a multimedia chat room.\n */\nexport const ON_ROOM_REMOTE_LEAVE: string = 'onRoomRemoteLeave';\n\n/**\n * The name of the event that is triggered when options for a multimedia chat room are changed.\n */\nexport const ON_ROOM_OPTIONS_CHANGED: string = 'onRoomOptionsChanged';\n\n/**\n * The name of the event that is triggered when a form animation is started.\n */\nexport const ON_FORM_ANIMATION_STARTED: string = 'onFormAnimationStarted';\n\n/**\n * The name of the event that is triggered for all bots when a form animation is started.\n */\nexport const ON_ANY_FORM_ANIMATION_STARTED: string =\n    'onAnyFormAnimationStarted';\n\n/**\n * The name of the event that is triggered when a form animation is finished.\n */\nexport const ON_FORM_ANIMATION_FINISHED: string = 'onFormAnimationFinished';\n\n/**\n * The name of the event that is triggered for all bots when a form animation is finished.\n */\nexport const ON_ANY_FORM_ANIMATION_FINISHED: string =\n    'onAnyFormAnimationFinished';\n\n/**\n * The name of the event that is triggered when a form animation is stopped.\n */\nexport const ON_FORM_ANIMATION_STOPPED: string = 'onFormAnimationStopped';\n\n/**\n * The name of the event that is triggered for all bots when a form animation is stopped.\n */\nexport const ON_ANY_FORM_ANIMATION_STOPPED: string =\n    'onAnyFormAnimationStopped';\n\n/**\n * The name of the event that is triggered when a form animation loops.\n */\nexport const ON_FORM_ANIMATION_LOOPED: string = 'onFormAnimationLooped';\n\n/**\n * The name of the event that is triggered for all bots when a form animation loops.\n */\nexport const ON_ANY_FORM_ANIMATION_LOOPED: string = 'onAnyFormAnimationLooped';\n\n/**\n * The current bot format version for AUX Bots.\n * This number increments whenever there are any changes between AUX versions.\n * As a result, it will allow us to make breaking changes but still upgrade people's bots\n * in the future.\n */\nexport const AUX_BOT_VERSION: number = 1;\n\n/**\n * The name of the miniGridPortal.\n */\nexport const MINI_PORTAL: string = 'miniGridPortal';\n\n/**\n * The name of the map portal.\n */\nexport const MAP_PORTAL: string = 'mapPortal';\n\n/**\n * The name of the mini map portal.\n */\nexport const MINI_MAP_PORTAL: string = 'miniMapPortal';\n\n/**\n * The name of the meet portal.\n */\nexport const MEET_PORTAL: string = 'meetPortal';\n\n/**\n * The name of the bot portal.\n */\nexport const BOT_PORTAL: string = 'botPortal';\n\n/**\n * The name of the tag portal.\n */\nexport const TAG_PORTAL: string = 'tagPortal';\n\n/**\n * The name of the data portal.\n */\nexport const DATA_PORTAL: string = 'dataPortal';\n\n/**\n * The name of the sheet portal.\n */\nexport const SHEET_PORTAL: string = 'sheetPortal';\n\n/**\n * The name of the IDE portal.\n */\nexport const IDE_PORTAL: string = 'idePortal';\n\n/**\n * The name of the system portal.\n */\nexport const SYSTEM_PORTAL: string = 'systemPortal';\n\n/**\n * The name of the system tag.\n */\nexport const SYSTEM_TAG: string = 'system';\n\n/**\n * The name of the tag that is used to determine which tag should be used for the system portal.\n */\nexport const SYSTEM_TAG_NAME: string = 'systemTagName';\n\n/**\n * The name of the tag that is used to search tags in the system portal.\n */\nexport const SYSTEM_PORTAL_SEARCH: string = 'systemPortalSearch';\n\n/**\n * The name of the tag used to keep track of the selected bot in the system portal..\n */\nexport const SYSTEM_PORTAL_BOT: string = 'systemPortalBot';\n\n/**\n * The name of the tag that is selected in the system portal.\n */\nexport const SYSTEM_PORTAL_TAG: string = 'systemPortalTag';\n\n/**\n * The space of the tag that is selected in the system portal.\n */\nexport const SYSTEM_PORTAL_TAG_SPACE: string = 'systemPortalTagSpace';\n\n/**\n * The name of the diff portal.\n */\nexport const SYSTEM_PORTAL_DIFF: string = 'systemPortalDiff';\n\n/**\n * The bot that is currently selected in the diff portal.\n */\nexport const SYSTEM_PORTAL_DIFF_BOT: string = 'systemPortalDiffBot';\n\n/**\n * The name of the tag that is selected in the diff portal.\n */\nexport const SYSTEM_PORTAL_DIFF_TAG: string = 'systemPortalDiffTag';\n\n/**\n * The space of the tag that is selected in the system portal.\n */\nexport const SYSTEM_PORTAL_DIFF_TAG_SPACE: string = 'systemPortalDiffTagSpace';\n\n/**\n * The name of the tag that is used to indicate which bot the player is currently editing.\n */\nexport const EDITING_BOT: string = 'editingBot';\n\n/**\n * The name of the tag that is used to indiciate which tag the player is currently editing.\n */\nexport const EDITING_TAG: string = 'editingTag';\n\n/**\n * The name of the tag that is used to indiciate which space the tag the player is currently editing is in.\n */\nexport const EDITING_TAG_SPACE: string = 'editingTagSpace';\n\n/**\n * The name of the IMU portal.\n */\nexport const IMU_PORTAL: string = 'imuPortal';\n\n/**\n * The prefix for DNA Tags.\n */\nexport const DNA_TAG_PREFIX: string = '';\n\n/**\n * The prefix for bot links.\n */\nexport const BOT_LINK_TAG_PREFIX: string = '';\n\n/**\n * The prefix for date tags.\n */\nexport const DATE_TAG_PREFIX: string = '';\n\n/**\n * The prefix for string tags.\n */\nexport const STRING_TAG_PREFIX: string = '';\n\n/*\n * The prefix for number tags.\n */\nexport const NUMBER_TAG_PREFIX: string = '';\n\n/**\n * The prefix for vector tags.\n */\nexport const VECTOR_TAG_PREFIX: string = '';\n\n/**\n * The prefix for rotation tags.\n */\nexport const ROTATION_TAG_PREFIX: string = '';\n\n/**\n * The default script prefixes for custom portals.\n */\nexport const DEFAULT_CUSTOM_PORTAL_SCRIPT_PREFIXES: string[] = [''];\n\n/**\n * The list of known tag prefixes.\n */\nexport const KNOWN_TAG_PREFIXES: string[] = [\n    '@',\n    DNA_TAG_PREFIX,\n    BOT_LINK_TAG_PREFIX,\n    DATE_TAG_PREFIX,\n    STRING_TAG_PREFIX,\n    NUMBER_TAG_PREFIX,\n    VECTOR_TAG_PREFIX,\n    ROTATION_TAG_PREFIX,\n];\n\n/**\n * The list of all portal tags.\n */\nexport const KNOWN_PORTALS: string[] = [\n    'gridPortal',\n    SHEET_PORTAL,\n    IDE_PORTAL,\n    IMU_PORTAL,\n    SYSTEM_PORTAL,\n    MINI_PORTAL,\n    'menuPortal',\n    'leftWristPortal',\n    'rightWristPortal',\n    MEET_PORTAL,\n    TAG_PORTAL,\n    MAP_PORTAL,\n    MINI_MAP_PORTAL,\n    BOT_PORTAL,\n];\n\n/**\n * The list of portal tags that should always be represented in the query string.\n */\nexport const QUERY_PORTALS: string[] = [\n    'gridPortal',\n    SHEET_PORTAL,\n    IDE_PORTAL,\n    MEET_PORTAL,\n    TAG_PORTAL,\n    TAG_PORTAL_SPACE,\n    MAP_PORTAL,\n    SYSTEM_PORTAL,\n    SYSTEM_TAG_NAME,\n    SYSTEM_PORTAL_DIFF,\n    BOT_PORTAL,\n];\n\n/**\n * The list of portal tags that should cause a new browser history entry to be added\n * when it is updated.\n */\nexport const QUERY_FULL_HISTORY_TAGS: Set<string> = new Set([\n    'gridPortal',\n    SHEET_PORTAL,\n    IDE_PORTAL,\n    MEET_PORTAL,\n    TAG_PORTAL,\n    TAG_PORTAL_SPACE,\n    MAP_PORTAL,\n]);\n\n/**\n * The list of portal tags that should cause a new browser history entry to be added\n * only when the tag itself is added or removed from the query.\n */\nexport const QUERY_PARTIAL_HISTORY_TAGS: Set<string> = new Set([\n    SYSTEM_PORTAL,\n    SYSTEM_PORTAL_DIFF,\n]);\n\n/*\n * The list of all tags that have existing functionality in casual sim\n */\nexport const KNOWN_TAGS: string[] = [\n    'playerActive',\n    'gridPortal',\n    SHEET_PORTAL,\n    IDE_PORTAL,\n    SYSTEM_PORTAL,\n    SYSTEM_PORTAL_BOT,\n    SYSTEM_PORTAL_TAG,\n    SYSTEM_PORTAL_TAG_SPACE,\n    SYSTEM_PORTAL_SEARCH,\n    SYSTEM_TAG,\n    SYSTEM_TAG_NAME,\n\n    SYSTEM_PORTAL_DIFF,\n    SYSTEM_PORTAL_DIFF_BOT,\n    SYSTEM_PORTAL_DIFF_TAG,\n    SYSTEM_PORTAL_DIFF_TAG_SPACE,\n\n    'inst',\n    MINI_PORTAL,\n    'menuPortal',\n    MAP_PORTAL,\n    MINI_MAP_PORTAL,\n    'leftWristPortal',\n    'rightWristPortal',\n\n    MEET_PORTAL,\n    DATA_PORTAL,\n    TAG_PORTAL,\n    TAG_PORTAL_SPACE,\n\n    IMU_PORTAL,\n    'imuSupported',\n    'deviceRotationX',\n    'deviceRotationY',\n    'deviceRotationZ',\n    'deviceRotationW',\n\n    BOT_PORTAL,\n    'botPortalStyle',\n    'botPortalAnchorPoint',\n\n    'cameraPositionX',\n    'cameraPositionY',\n    'cameraPositionZ',\n    'cameraPositionOffsetX',\n    'cameraPositionOffsetY',\n    'cameraPositionOffsetZ',\n\n    'cameraRotationX',\n    'cameraRotationY',\n    'cameraRotationZ',\n    'cameraRotationOffsetX',\n    'cameraRotationOffsetY',\n    'cameraRotationOffsetZ',\n    'cameraRotationOffsetW',\n\n    'cameraFocusX',\n    'cameraFocusY',\n    'cameraFocusZ',\n\n    'cameraZoom',\n    'cameraZoomOffset',\n\n    'pixelWidth',\n    'pixelHeight',\n    'pixelRatio',\n    'defaultPixelRatio',\n    'pageTitle',\n    'pointerPixelX',\n    'pointerPixelY',\n\n    'mousePointerPositionX',\n    'mousePointerPositionY',\n    'mousePointerPositionZ',\n    'rightPointerPositionX',\n    'rightPointerPositionY',\n    'rightPointerPositionZ',\n    'leftPointerPositionX',\n    'leftPointerPositionY',\n    'leftPointerPositionZ',\n\n    'mousePointerRotationX',\n    'mousePointerRotationY',\n    'mousePointerRotationZ',\n    'rightPointerRotationX',\n    'rightPointerRotationY',\n    'rightPointerRotationZ',\n    'leftPointerRotationX',\n    'leftPointerRotationY',\n    'leftPointerRotationZ',\n\n    'mousePointerPortal',\n    'rightPointerPortal',\n    'leftPointerPortal',\n\n    'mousePointer_left',\n    'mousePointer_right',\n    'mousePointer_middle',\n    'leftPointer_primary',\n    'leftPointer_squeeze',\n    'rightPointer_primary',\n    'rightPointer_squeeze',\n    'forceSignedScripts',\n\n    EDITING_BOT,\n    EDITING_TAG,\n    EDITING_TAG_SPACE,\n    'cursorStartIndex',\n    'cursorEndIndex',\n\n    'portalColor',\n    'portalCursor',\n    'portalCursorHotspotX',\n    'portalCursorHotspotY',\n    'portalBackgroundAddress',\n    'portalLocked',\n    'portalPannable',\n    `portalPannableMinX`,\n    `portalPannableMaxX`,\n    `portalPannableMinY`,\n    `portalPannableMaxY`,\n    'portalZoomable',\n    `portalZoomableMin`,\n    `portalZoomableMax`,\n    'portalRotatable',\n    'portalGridScale',\n    'portalSurfaceScale',\n    `portalCameraZoom`,\n    `portalCameraRotationX`,\n    `portalCameraRotationY`,\n    'portalCameraControls',\n    'portalShowFocusPoint',\n    'portalDisableCanvasTransparency',\n    'portalCameraType',\n    'miniPortalHeight',\n    'miniPortalWidth',\n    'miniPortalResizable',\n    'wristPortalHeight',\n    'wristPortalWidth',\n    'meetPortalAnchorPoint',\n    'meetPortalVisible',\n    'meetPortalStyle',\n    'meetPortalPrejoinEnabled',\n    'meetPortalStartWithVideoMuted',\n    'meetPortalStartWithAudioMuted',\n    'meetPortalRequireDisplayName',\n    'meetPortalJWT',\n    'mapPortalBasemap',\n\n    'tagPortalAnchorPoint',\n    'tagPortalStyle',\n    'tagPortalShowButton',\n    'tagPortalButtonIcon',\n    'tagPortalButtonHint',\n    'sheetPortalShowButton',\n    'sheetPortalButtonIcon',\n    'sheetPortalButtonHint',\n    'sheetPortalAllowedTags',\n    'sheetPortalAddedTags',\n    'portalShowButton',\n    'portalButtonIcon',\n    'portalButtonHint',\n    'menuPortalStyle',\n\n    'color',\n    'creator',\n    'cursor',\n    'cursorHotspotX',\n    'cursorHotspotY',\n    'draggable',\n    'destroyable',\n    'editable',\n    'strokeColor',\n    'strokeWidth',\n    'lineTo',\n    'lineStyle',\n    'lineWidth',\n    'lineColor',\n    'label',\n    'labelColor',\n    'labelFontSize',\n    'labelSize',\n    'labelSizeMode',\n    'labelOpacity',\n    'labelPadding',\n    'labelPaddingX',\n    'labelPaddingY',\n    'labelPosition',\n    'labelAlignment',\n    'labelWordWrapMode',\n    'labelFontAddress',\n    'listening',\n    'scale',\n    'scaleX',\n    'scaleY',\n    'scaleZ',\n    'scaleMode',\n    'formAddress',\n    'formAddressAspectRatio',\n    'formSubtype',\n    'form',\n    'formAnimation',\n    'formAnimationAddress',\n    'orientationMode',\n    'anchorPoint',\n    'gltfVersion',\n    'progressBar',\n    'progressBarColor',\n    'progressBarBackgroundColor',\n    'progressBarPosition',\n    'maxLODThreshold',\n    'minLODThreshold',\n    'pointable',\n    'focusable',\n    'transformer',\n    'menuItemStyle',\n    'menuItemLabelStyle',\n    'menuItemHoverMode',\n    'menuItemText',\n    'menuItemShowSubmitWhenEmpty',\n\n    'taskOutput',\n    'taskError',\n    'taskTime',\n    'taskShell',\n    'taskBackup',\n    'taskBackupType',\n    'taskBackupUrl',\n\n    'error',\n    'errorName',\n    'errorMessage',\n    'errorStack',\n    'errorBot',\n    'errorTag',\n\n    'avatarAddress',\n    'name',\n\n    CLICK_ACTION_NAME,\n    'onAnyBotClicked',\n    MOD_DROP_ENTER_ACTION_NAME,\n    MOD_DROP_EXIT_ACTION_NAME,\n    MOD_DROP_ACTION_NAME,\n    'onSaveInput',\n    'onCloseInput',\n    CREATE_ACTION_NAME,\n    CREATE_ANY_ACTION_NAME,\n    DESTROY_ACTION_NAME,\n    DROP_ENTER_ACTION_NAME,\n    DROP_EXIT_ACTION_NAME,\n    ANY_DROP_ENTER_ACTION_NAME,\n    ANY_DROP_EXIT_ACTION_NAME,\n    DROP_ACTION_NAME,\n    DROP_ANY_ACTION_NAME,\n    DRAG_ACTION_NAME,\n    DRAG_ANY_ACTION_NAME,\n    DRAGGING_ACTION_NAME,\n    DRAGGING_ANY_ACTION_NAME,\n    'onTapCode',\n    'onQRCodeScanned',\n    'onQRCodeScannerClosed',\n    'onQRCodeScannerOpened',\n    ON_BARCODE_SCANNED_ACTION_NAME,\n    ON_BARCODE_SCANNER_CLOSED_ACTION_NAME,\n    ON_BARCODE_SCANNER_OPENED_ACTION_NAME,\n\n    ON_IMAGE_CLASSIFIER_CLOSED_ACTION_NAME,\n    ON_IMAGE_CLASSIFIER_OPENED_ACTION_NAME,\n    ON_IMAGE_CLASSIFIED_ACTION_NAME,\n\n    ON_POINTER_ENTER,\n    ON_POINTER_EXIT,\n    ON_ANY_POINTER_ENTER,\n    ON_ANY_POINTER_EXIT,\n    ON_POINTER_DOWN,\n    ON_POINTER_UP,\n    ON_ANY_POINTER_DOWN,\n    ON_ANY_POINTER_UP,\n    ON_INST_STREAMING_ACTION_NAME,\n    ON_INST_STREAM_LOST_ACTION_NAME,\n\n    ON_INST_JOINED_ACTION_NAME,\n    ON_INST_LEAVE_ACTION_NAME,\n\n    ON_PORTAL_CHANGED_ACTION_NAME,\n    ON_APP_SETUP_ACTION_NAME,\n    ON_DOCUMENT_AVAILABLE_ACTION_NAME,\n    'onKeyDown',\n    'onKeyUp',\n    ON_KEY_CLICK_ACTION_NAME,\n    ON_GRID_CLICK_ACTION_NAME,\n    ON_GRID_UP_ACTION_NAME,\n    ON_GRID_DOWN_ACTION_NAME,\n    'onCheckout',\n    'onPaymentSuccessful',\n    'onPaymentFailed',\n    'onWebhook',\n    'onAnyListen',\n    'onListen',\n    ON_REMOTE_DATA_ACTION_NAME,\n    ON_ACTION_ACTION_NAME,\n    ON_RUN_ACTION_NAME,\n    ON_CHAT_TYPING_ACTION_NAME,\n    ON_CHAT_ACTION_NAME,\n    ON_SUBMIT_ACTION_NAME,\n    ON_INPUT_TYPING_ACTION_NAME,\n    ON_PASTE_ACTION_NAME,\n    ON_MAX_LOD_ENTER_ACTION_NAME,\n    ON_MIN_LOD_ENTER_ACTION_NAME,\n    ON_MAX_LOD_EXIT_ACTION_NAME,\n    ON_MIN_LOD_EXIT_ACTION_NAME,\n    ON_ANY_MAX_LOD_ENTER_ACTION_NAME,\n    ON_ANY_MIN_LOD_ENTER_ACTION_NAME,\n    ON_ANY_MAX_LOD_EXIT_ACTION_NAME,\n    ON_ANY_MIN_LOD_EXIT_ACTION_NAME,\n    ON_FILE_UPLOAD_ACTION_NAME,\n\n    ON_FOCUS_ENTER_ACTION_NAME,\n    ON_FOCUS_EXIT_ACTION_NAME,\n    ON_ANY_FOCUS_ENTER_ACTION_NAME,\n    ON_ANY_FOCUS_EXIT_ACTION_NAME,\n\n    ON_REMOTE_JOINED_ACTION_NAME,\n    ON_REMOTE_LEAVE_ACTION_NAME,\n\n    ON_BOT_ADDED_ACTION_NAME,\n    ON_ANY_BOTS_ADDED_ACTION_NAME,\n    ON_ANY_BOTS_REMOVED_ACTION_NAME,\n\n    ON_BOT_CHANGED_ACTION_NAME,\n    ON_ANY_BOTS_CHANGED_ACTION_NAME,\n\n    ON_SHEET_TAG_CLICK,\n    ON_SHEET_BOT_ID_CLICK,\n    ON_SHEET_BOT_CLICK,\n\n    ON_BEGIN_AUDIO_RECORDING,\n    ON_AUDIO_SAMPLE,\n    ON_END_AUDIO_RECORDING,\n    ON_ENTER_VR,\n    ON_EXIT_VR,\n    ON_ENTER_AR,\n    ON_EXIT_AR,\n    ON_MEET_LOADED,\n    ON_MEET_LEAVE,\n    ON_MEET_ENTERED,\n    ON_MEET_EXITED,\n\n    ON_ROOM_JOINED,\n    ON_ROOM_LEAVE,\n    ON_ROOM_TRACK_SUBSCRIBED,\n    ON_ROOM_TRACK_UNSUBSCRIBED,\n    ON_ROOM_STREAM_LOST,\n    ON_ROOM_STREAMING,\n    ON_ROOM_SPEAKERS_CHANGED,\n    ON_ROOM_REMOTE_JOINED,\n    ON_ROOM_REMOTE_LEAVE,\n    ON_ROOM_OPTIONS_CHANGED,\n\n    ON_FORM_ANIMATION_STARTED,\n    ON_ANY_FORM_ANIMATION_STARTED,\n    ON_FORM_ANIMATION_FINISHED,\n    ON_ANY_FORM_ANIMATION_FINISHED,\n    ON_FORM_ANIMATION_STOPPED,\n    ON_ANY_FORM_ANIMATION_STOPPED,\n    ON_FORM_ANIMATION_LOOPED,\n    ON_ANY_FORM_ANIMATION_LOOPED,\n];\n\nexport function onClickArg(\n    face: string,\n    dimension: string,\n    uv: string,\n    modality: string,\n    hand: string,\n    finger: string\n) {\n    return {\n        face,\n        dimension,\n        uv,\n        modality,\n        hand,\n        finger,\n    };\n}\n\nexport function onAnyClickArg(\n    face: string,\n    dimension: string,\n    bot: Bot,\n    uv: string,\n    modality: string,\n    hand: string,\n    finger: string\n) {\n    return {\n        ...onClickArg(face, dimension, uv, modality, hand, finger),\n        bot,\n    };\n}\n\nexport function onDragArg(\n    bot: Bot,\n    from: BotDropDestination,\n    face: string,\n    uv: string\n) {\n    return {\n        face,\n        bot,\n        from,\n        uv,\n    };\n}\n\nexport function onDraggingArg(\n    bot: Bot,\n    to: BotDropToDestination,\n    from: BotDropDestination\n) {\n    return {\n        bot,\n        to,\n        from,\n    };\n}\n\nexport function onModDropArg(mod: BotTags, dimension: string) {\n    return {\n        mod,\n        dimension,\n    };\n}\n\nexport function onDropArg(\n    dragBot: Bot,\n    to: BotDropToDestination,\n    from: BotDropDestination\n) {\n    return {\n        dragBot,\n        bot: dragBot,\n        to,\n        from,\n    };\n}\n\nexport function onServerStreamingArg(server: string) {\n    return {\n        server,\n        inst: server,\n    };\n}\n\nexport function onServerStreamLostArg(server: string) {\n    return {\n        server,\n        inst: server,\n    };\n}\n\nexport function onServerSubscribedArg(server: string) {\n    return {\n        server,\n        inst: server,\n    };\n}\n\nexport function onServerUnsubscribedArg(server: string) {\n    return {\n        server,\n        inst: server,\n    };\n}\n\nexport function onChatTypingArg(message: string) {\n    return {\n        message,\n    };\n}\n\nexport function onChatArg(message: string) {\n    return {\n        message,\n    };\n}\n\nexport function onPasteArg(text: string) {\n    return {\n        text,\n    };\n}\n\nexport function onLODArg(bot: Bot, dimension: string) {\n    return {\n        bot,\n        dimension,\n    };\n}\n\nexport function onPointerEnterExitArg(\n    bot: Bot,\n    dimension: string,\n    modality: string,\n    hand: string,\n    finger: string\n) {\n    return {\n        bot,\n        dimension,\n        modality,\n        hand,\n        finger,\n    };\n}\n\nexport function onPointerUpDownArg(bot: Bot, dimension: string) {\n    return {\n        bot,\n        dimension,\n    };\n}\n\nexport function onSubmitArg(text: string) {\n    return {\n        text,\n    };\n}\n\nexport interface BotDropDestination {\n    x: number;\n    y: number;\n    dimension: string;\n}\n\nexport interface BotDropToDestination extends BotDropDestination {\n    bot: Bot;\n}\n","import { randomBytes, secretbox, box } from 'tweetnacl';\nimport { syncScrypt } from 'scrypt-js';\nimport { fromByteArray, toByteArray } from 'base64-js';\n\ninterface DerivedKey {\n    salt: Uint8Array;\n    hash: Uint8Array;\n}\n\nconst ITERATIONS = 16384;\nconst BLOCK_SIZE = 8;\nconst PARALLELISM = 1;\nexport const KEY_LENGTH = secretbox.keyLength;\n\n/**\n * Derives a key from a password and salt.\n * @param password The pasword to derive the key from.\n * @param salt The salt to use.\n * @returns\n */\nexport function deriveKey(password: Uint8Array, salt: Uint8Array): DerivedKey {\n    const result = syncScrypt(\n        password,\n        salt,\n        ITERATIONS,\n        BLOCK_SIZE,\n        PARALLELISM,\n        KEY_LENGTH\n    );\n\n    return {\n        salt: salt,\n        hash: result,\n    };\n}\n\n/**\n * Encrypts the given data with the given password and returns the resulting cyphertext.\n *\n * The returned cyphertext contains a version number at the beginning which determines the format of the following data.\n *\n * v1 encryptions use XSalsa20 as the cipher and Poly1305 for authentication in addition to scrypt for password-based key derivation.\n * The output string is formatted as following with periods between the components:\n * 1. The version number (v1)\n * 2. The base64 of the salt used to derive the key from the password. (pseudorandom)\n * 3. The base64 of the nonce used by the cipher. (pseudorandom)\n * 4. The base64 of the encrypted data.\n *\n * @param password The password to use to encrypt.\n * @param data The data to encrypt.\n */\nexport function encrypt(password: string, data: Uint8Array): string {\n    return encryptV1(password, data);\n}\n\n/**\n * Decrypts the given cyphertext with the given password and returns the original plaintext.\n * Returns null if the data was unable to be decrypted.\n * @param password The password to use to decrypt.\n * @param cyphertext The data to decrypt.\n */\nexport function decrypt(password: string, cyphertext: string): Uint8Array {\n    if (!password) {\n        throw new Error('Invalid password. Must not be null or undefined.');\n    }\n    if (!cyphertext) {\n        throw new Error('Invalid cyphertext. Must not be null or undefined.');\n    }\n    if (cyphertext.startsWith('v1.')) {\n        return decryptV1(password, cyphertext);\n    }\n    return null;\n}\n\n/**\n * Encrypts the given data with the given password using version 1 of the encryption mechanisms in this file and returns the resulting\n * cyphertext.\n *\n * version 1 encryptions use XSalsa20 as the cipher and Poly1305 for authentication in addition to scrypt for password-based key derivation.\n * The output string is formatted as following with periods between the components:\n * 1. The version number (v1)\n * 2. The base64 of the salt used to derive the key from the password. (pseudorandom)\n * 3. The base64 of the nonce used by the cipher. (pseudorandom)\n * 4. The base64 of the encrypted data.\n *\n * @param password The password to use to encrypt the data.\n * @param data The data to encrypt.\n */\nexport function encryptV1(password: string, data: Uint8Array): string {\n    if (!password) {\n        throw new Error('Invalid password. Must not be null or undefined.');\n    }\n    if (!data) {\n        throw new Error('Invalid data. Must not be null or undefined.');\n    }\n    const nonce = randomBytes(secretbox.nonceLength);\n    const salt = randomBytes(secretbox.nonceLength);\n\n    const textEncoder = new TextEncoder();\n    const passwordBytes = textEncoder.encode(password);\n    const key = deriveKey(passwordBytes, salt);\n    const cypherBytes = secretbox(data, nonce, key.hash);\n    const cyphertext = `v1.${fromByteArray(salt)}.${fromByteArray(\n        nonce\n    )}.${fromByteArray(cypherBytes)}`;\n\n    return cyphertext;\n}\n\n/**\n * Decrypts the given data with the given password using version 1 of the encryption mechanisms in this file and returns the resulting\n * plaintext.\n *\n * version 1 encryptions use XSalsa20 as the cipher and Poly1305 for authentication in addition to scrypt for password-based key derivation.\n *\n * @param password The password to use to decrypt the data.\n * @param cyphertext The cyphertext produced from encryptV1().\n */\nexport function decryptV1(password: string, cyphertext: string): Uint8Array {\n    if (!password) {\n        throw new Error('Invalid password. Must not be null or undefined.');\n    }\n    if (!cyphertext) {\n        throw new Error('Invalid cyphertext. Must not be null or undefined.');\n    }\n    if (!cyphertext.startsWith('v1.')) {\n        throw new Error('Invalid cyphertext. Must start with \"v1.\"');\n    }\n\n    const withoutVersion = cyphertext.slice('v1.'.length);\n    let nextPeriod = withoutVersion.indexOf('.');\n    if (nextPeriod < 0) {\n        return null;\n    }\n    const saltBase64 = withoutVersion.slice(0, nextPeriod);\n    const withoutSalt = withoutVersion.slice(nextPeriod + 1);\n    nextPeriod = withoutSalt.indexOf('.');\n    if (nextPeriod < 0) {\n        return null;\n    }\n    const nonceBase64 = withoutSalt.slice(0, nextPeriod);\n    const dataBase64 = withoutSalt.slice(nextPeriod + 1);\n    if (dataBase64.length <= 0) {\n        return null;\n    }\n\n    const salt = toByteArray(saltBase64);\n    const nonce = toByteArray(nonceBase64);\n    const data = toByteArray(dataBase64);\n\n    const textEncoder = new TextEncoder();\n    const passwordBytes = textEncoder.encode(password);\n    const key = deriveKey(passwordBytes, salt);\n\n    return secretbox.open(data, nonce, key.hash);\n}\n\n/**\n * Determines whether the given keypair is a valid asymmetric keypair.\n * Note that this function only determines if the keypair could have been generated by asymmetricKeypair(),\n * not that it was or that it can be used to decrypt something.\n * @param keypair The keypair to test.\n */\nexport function isAsymmetricKeypair(keypair: string): boolean {\n    try {\n        const [publicKey, privateKey] = decodeAsymmetricKeypairV1(keypair);\n        return !!publicKey && !!privateKey;\n    } catch (ex) {\n        return false;\n    }\n}\n\n/**\n * Creates a keypair that can be used for public key authenticated encryption.\n *\n * The returned keypair contains a version number at the beginning which determines the format of the following data.\n *\n * vEK1 keypairs use x25519 with XSalsa20 and Poly1305.\n * The output string is formatting as following with periods between the components:\n * 1. The version number (vEK1) - the EK is for \"encryption keypair\".\n * 2. The base64 of the public key.\n * 3. The base64 of the encrypted private key.\n *\n * @param password The password that should be used to encrypt the private key of the keypair.\n */\nexport function asymmetricKeypair(password: string): string {\n    return asymmetricKeypairV1(password);\n}\n\n/**\n * Creates a version 1 keypair that can be used for public key authenticated encryption.\n *\n * The returned keypair contains a version number at the beginning which determines the format of the following data.\n *\n * vEK1 keypairs use x25519 with XSalsa20 and Poly1305.\n * The output string is formatting as following with periods between the components:\n * 1. The version number (vEK1) - the EK is for \"encryption keypair\".\n * 2. The base64 of the public key.\n * 3. The base64 of the encrypted private key.\n *\n * @param password The password that should be used to encrypt the private key of the keypair.\n */\nexport function asymmetricKeypairV1(password: string): string {\n    const pair = box.keyPair();\n    const encryptedPrivateKey = encrypt(password, pair.secretKey);\n    const encoder = new TextEncoder();\n    const privateKeyBytes = encoder.encode(encryptedPrivateKey);\n    return `vEK1.${fromByteArray(pair.publicKey)}.${fromByteArray(\n        privateKeyBytes\n    )}`;\n}\n\nfunction decodeAsymmetricKeypairV1(keypair: string): [Uint8Array, string] {\n    const withoutVersion = keypair.slice('vEK1.'.length);\n    let nextPeriod = withoutVersion.indexOf('.');\n    if (nextPeriod < 0) {\n        return [null, null];\n    }\n    const publicKeyBase64 = withoutVersion.slice(0, nextPeriod);\n    const withoutPublicKey = withoutVersion.slice(nextPeriod + 1);\n    const privateKeyBase64 = withoutPublicKey;\n    const publicKey = toByteArray(publicKeyBase64);\n    const privateKeyBytes = toByteArray(privateKeyBase64);\n    const decoder = new TextDecoder();\n    const privateKey = decoder.decode(privateKeyBytes);\n\n    return [publicKey, privateKey];\n}\n\n/**\n * Encrypts the given data with the given keypair and returns the resulting cyphertext.\n *\n * The returned cyphertext contains a version number at the beginning which determines the format of the following data.\n *\n * vA1 encryptions use x25519 for key exchange, XSalsa20 as the cipher and Poly1305 for authentication.\n *\n * vA1 encryptions technically use two keypairs for encryption/decryption. One for the local party and one for the remote party.\n * These two parties are used to calculate a shared key that is then used to encrypt and authenticate the data.\n * When encrypting, a new keypair is generated and used for the \"local\" party while the given keypair is used for the remote party.\n * The secret key is then discarded while the public key is included in the output to make it possible for the other party to decrypt the data.\n *\n * The output string is formatted as following with periods between the components:\n * 1. The version number (vA1). The \"A\" means \"asymmetric\".\n * 2. The base64 of the public key of the keypair used to encrypt the data.\n * 3. The base64 of the nonce used by the cipher. (pseudorandom)\n * 4. The base64 of the encrypted data.\n *\n * @param keypair The keypair to use to encrypt.\n * @param data The data to encrypt.\n */\nexport function asymmetricEncrypt(keypair: string, data: Uint8Array): string {\n    return asymmetricEncryptV1(keypair, data);\n}\n\n/**\n * Encrypts the given data with the given keypair and returns the resulting cyphertext.\n *\n * The returned cyphertext contains a version number at the beginning which determines the format of the following data.\n *\n * vA1 encryptions use x25519 for key exchange, XSalsa20 as the cipher and Poly1305 for authentication.\n *\n * vA1 encryptions technically use two keypairs for encryption/decryption. One for the local party and one for the remote party.\n * These two parties are used to calculate a shared key that is then used to encrypt and authenticate the data.\n * When encrypting, a new keypair is generated and used for the \"local\" party while the given keypair is used for the remote party.\n * The secret key is then discarded while the public key is included in the output to make it possible for the other party to decrypt the data.\n *\n * The output string is formatted as following with periods between the components:\n * 1. The version number (vA1). The \"A\" means \"asymmetric\".\n * 2. The base64 of the public key of the keypair used to encrypt the data.\n * 3. The base64 of the nonce used by the cipher. (pseudorandom)\n * 4. The base64 of the encrypted data.\n *\n * @param keypair The keypair to use to encrypt.\n * @param data The data to encrypt.\n */\nexport function asymmetricEncryptV1(keypair: string, data: Uint8Array): string {\n    if (!keypair) {\n        throw new Error('Invalid keypair. Must not be null or undefined.');\n    }\n    if (!data) {\n        throw new Error('Invalid data. Must not be null or undefined.');\n    }\n    if (!keypair.startsWith('vEK1.')) {\n        throw new Error('Invalid keypair. Must start with \"vEK1.\"');\n    }\n    const [theirPublicKey, theirPrivateKey] =\n        decodeAsymmetricKeypairV1(keypair);\n    if (!theirPublicKey || !theirPrivateKey) {\n        throw new Error('Invalid keypair. Unable to be decoded.');\n    }\n    const localKeypair = box.keyPair();\n    const myPublicKey = localKeypair.publicKey;\n    const myPrivateKey = localKeypair.secretKey;\n    const nonce = randomBytes(box.nonceLength);\n\n    const cypherBytes = box(data, nonce, theirPublicKey, myPrivateKey);\n\n    const cyphertext = `vA1.${fromByteArray(myPublicKey)}.${fromByteArray(\n        nonce\n    )}.${fromByteArray(cypherBytes)}`;\n\n    return cyphertext;\n}\n\n/**\n * Decrypts the given data with the given keypair and returns the resulting plaintext.\n * Returns null if the data was unable to be decrypted.\n *\n * vA1 encryptions use x25519 for key exchange, XSalsa20 as the cipher and Poly1305 for authentication.\n *\n * @param keypair The keypair to use to decrypt the data.\n * @param password The password that should be used to decrypt the keypair's private key.\n * @param cyphertext The data to decrypt.\n */\nexport function asymmetricDecrypt(\n    keypair: string,\n    password: string,\n    cyphertext: string\n): Uint8Array {\n    if (!keypair) {\n        throw new Error('Invalid keypair. Must not be null or undefined.');\n    }\n    if (!password) {\n        throw new Error('Invalid password. Must not be null or undefined.');\n    }\n    if (cyphertext.startsWith('vA1.')) {\n        return asymmetricDecryptV1(keypair, password, cyphertext);\n    }\n    return null;\n}\n\n/**\n * Decrypts the given data with the given keypair using version 1 of the asymmetric encryption mechanisms in this file and returns the resulting\n * plaintext. Returns null if the data was unable to be decrypted.\n *\n * vA1 encryptions use x25519 for key exchange, XSalsa20 as the cipher and Poly1305 for authentication.\n *\n * @param keypair The keypair to use to decrypt the data.\n * @param password The password that should be used to decrypt the keypair's private key.\n * @param cyphertext The data to decrypt.\n */\nexport function asymmetricDecryptV1(\n    keypair: string,\n    password: string,\n    cyphertext: string\n): Uint8Array {\n    if (!keypair) {\n        throw new Error('Invalid keypair. Must not be null or undefined.');\n    }\n    if (!password) {\n        throw new Error('Invalid password. Must not be null or undefined.');\n    }\n    if (!keypair.startsWith('vEK1.')) {\n        throw new Error('Invalid keypair. Must start with \"vEK1.\"');\n    }\n    if (!cyphertext.startsWith('vA1.')) {\n        throw new Error('Invalid cyphertext. Must start with \"vA1.\"');\n    }\n    const [myPublicKey, myEncryptedPrivateKey] =\n        decodeAsymmetricKeypairV1(keypair);\n    if (!myPublicKey || !myEncryptedPrivateKey) {\n        throw new Error('Invalid keypair. Unable to be decoded.');\n    }\n    const myPrivateKey = decrypt(password, myEncryptedPrivateKey);\n    if (!myPrivateKey) {\n        throw new Error('Invalid keypair. Unable to decrypt the private key.');\n    }\n\n    const withoutVersion = cyphertext.slice('vA1.'.length);\n    let nextPeriod = withoutVersion.indexOf('.');\n    if (nextPeriod < 0) {\n        return null;\n    }\n    const theirPublicKeyBase64 = withoutVersion.slice(0, nextPeriod);\n    const withoutPublicKey = withoutVersion.slice(nextPeriod + 1);\n    nextPeriod = withoutPublicKey.indexOf('.');\n    if (nextPeriod < 0) {\n        return null;\n    }\n    const nonceBase64 = withoutPublicKey.slice(0, nextPeriod);\n    const dataBase64 = withoutPublicKey.slice(nextPeriod + 1);\n    if (dataBase64.length <= 0) {\n        return null;\n    }\n\n    const theirPublicKey = toByteArray(theirPublicKeyBase64);\n    const nonce = toByteArray(nonceBase64);\n    const data = toByteArray(dataBase64);\n\n    return box.open(data, nonce, theirPublicKey, myPrivateKey);\n}\n\n/**\n * Determines whether the given data appears to be encrypted using asymmetric encryption.\n * @param cyphertext The cyphertext to test.\n */\nexport function isAsymmetricEncrypted(cyphertext: string): boolean {\n    try {\n        return typeof cyphertext === 'string' && cyphertext.startsWith('vA1.');\n    } catch {\n        return false;\n    }\n}\n\n/**\n * Determines whether the given data appears to be encrypted using symmetric encryption.\n * @param cyphertext The cyphertext to test.\n */\nexport function isEncrypted(cyphertext: string): boolean {\n    try {\n        return typeof cyphertext === 'string' && cyphertext.startsWith('v1.');\n    } catch {\n        return false;\n    }\n}\n","/**\n * Defines a class that represents a 2D point in space.\n */\nexport class Vector2 {\n    /**\n     * The X value of this vector.\n     */\n    x: number;\n\n    /**\n     * The Y value of this vector.\n     */\n    y: number;\n\n    /**\n     * Constructs a new 2D vector with the given X and Y values.\n     * @param x The X value of the vector.\n     * @param y The Y value of the vector.\n     *\n     * @example Create a new Vector2 object with the position (2, 3).\n     * let myVector = new Vector2(2, 3);\n     *\n     * os.toast(`X: ${myVector.x}, Y: ${myVector.y}`);\n     *\n     * @example Move this bot to (10, 15) in the home dimension.\n     * tags.homePosition = new Vector2(10, 15);\n     */\n    constructor(x: number = 0, y: number = 0) {\n        this.x = x;\n        this.y = y;\n        Object.freeze(this);\n    }\n\n    /**\n     * Creates a 2D vector with the given X and Y values that is normalized immediately upon creation.\n     * @param x The X value of the vector.\n     * @param y The Y value of the vector.\n     *\n     * @example Create a normalized vector\n     * const vector = Vector2.createNormalized(1, 2);\n     */\n    static createNormalized(x: number, y: number) {\n        const length = Math.sqrt(x * x + y * y);\n        return new Vector2(x / length, y / length);\n    }\n\n    /**\n     * Calculates the angle between the two given vectors and returns the result in radians.\n     * @param first The first vector that should be used for comparision.\n     * @param second The second vector that should be used for comparision.\n     *\n     * @example Find the angle between two vectors.\n     * const first = new Vector2(\n     *     Math.cos(Math.PI / 3),\n     *     Math.sin(Math.PI / 3)\n     * ); // 60 degrees\n     * const second = new Vector2(\n     *     Math.cos(Math.PI / 2),\n     *     Math.sin(Math.PI / 2)\n     * ); // 90 degrees\n     *\n     * const angle = Vector2.angleBetween(first, second);\n     * os.toast(angle);\n     */\n    static angleBetween(first: Vector2, second: Vector2): number {\n        const dot = first.dot(second);\n        const l1 = first.length();\n        const l2 = second.length();\n        return Math.acos(dot / (l1 * l2));\n    }\n\n    /**\n     * Calculates the distance between the two given vectors and returns the result.\n     * @param first The first vector that should be used for comparision.\n     * @param second The second vector that should be used for comparision.\n     *\n     * @example Find the distance between two vectors.\n     * const first = new Vector2(5, 10);\n     * const second = new Vector2(9, 2);\n     * const distance = Vector2.distanceBetween(first, second);\n     *\n     * os.toast(`Distance: ${distance}`);\n     */\n    static distanceBetween(first: Vector2, second: Vector2): number {\n        const direction = second.subtract(first);\n        return direction.length();\n    }\n\n    /**\n     * Constructs a new vector that is the linear interpolation between the given start and end positions.\n     * The degree that the result is interpolated is determined by the given amount parameter.\n     * @param start The start position.\n     * @param finish The end position.\n     * @param amount The amount that the resulting position should be interpolated between the start and end positions.  Values near 0 indicate rotations close to the first and values near 1 indicate rotations close to the second.\n     *\n     * @example Find the position that is halfway between two vectors.\n     * const start = new Vector2(5, 10);\n     * const finish = new Vector2(9, 2);\n     * const halfway = Vector2.interpolatePosition(start, finish, 0.5);\n     *\n     * os.toast(halfway);\n     *\n     * @example Find the position that is 1/4 between two vectors.\n     * const start = new Vector2(5, 10);\n     * const finish = new Vector2(9, 2);\n     * const halfway = Vector2.interpolatePosition(start, finish, 0.25);\n     *\n     * os.toast(halfway);\n     */\n    static interpolatePosition(\n        start: Vector2,\n        finish: Vector2,\n        amount: number\n    ) {\n        const dir = finish.subtract(start);\n        const lerp = dir.multiplyScalar(amount);\n        return start.add(lerp);\n    }\n\n    /**\n     * Constructs a new vector that is the directional linear interpolation between the given start and end positions.\n     * The degree that the result is interpolated is determined by the given amount parameter.\n     *\n     * This function works similarly to interpolatePosition(), except the result is always a normalized vector.\n     *\n     * @param start The start position.\n     * @param finish The end position.\n     * @param amount The amount that the resulting position should be interpolated between the start and end positions.  Values near 0 indicate rotations close to the first and values near 1 indicate rotations close to the second.\n     *\n     * @example Find the direction that points halfway between the two vectors.\n     * const start = new Vector2(5, 10);\n     * const finish = new Vector2(9, 2);\n     * const halfway = Vector2.interpolatePosition(start, finish, 0.5);\n     *\n     * os.toast(halfway);\n     */\n    static interpolateDirection(\n        start: Vector2,\n        finish: Vector2,\n        amount: number\n    ) {\n        return Vector2.interpolatePosition(start, finish, amount).normalize();\n    }\n\n    /**\n     * Adds this vector with the other vector and returns the result.\n     * @param other The other vector to add with this vector.\n     *\n     * @example Add two vectors together.\n     * const first = new Vector2(1, 2);\n     * const second = new Vector2(3, 4);\n     * const added = first.add(second);\n     *\n     * os.toast(added); // Prints (4, 6)\n     */\n    add(other: Vector2): Vector2 {\n        return new Vector2(this.x + other.x, this.y + other.y);\n    }\n\n    /**\n     * Subtracts the other vector from this vector and returns the result.\n     * @param other The other vector that should be subtracted from this vector.\n     *\n     * @example Subtract two vectors.\n     * const first = new Vector2(1, 2);\n     * const second = new Vector2(3, 4);\n     * const subtracted = first.subtract(second);\n     * os.toast(subtracted);\n     *\n     * @example Find the direction from one vector to another.\n     * const first = new Vector2(1, 2);\n     * const second = new Vector2(3, 4);\n     *\n     * const directionFromFirstToSecond = second.subtract(first);\n     * const directionFromSecondToFirst = first.subtract(second);\n     *\n     * os.toast(`first -> second = ${directionFromFirstToSecond}; second -> first = ${directionFromSecondToFirst}`);\n     */\n    subtract(other: Vector2): Vector2 {\n        return new Vector2(this.x - other.x, this.y - other.y);\n    }\n\n    /**\n     * Multiplies each component of this vector by the given value and returns the result.\n     * @param scale The scale that should be applied to this vector.\n     *\n     * @example Scale a vector by 10.\n     * const myVector = new Vector2(1, 1);\n     * const scaled = myVector.multiplyScalar(10);\n     * os.toast(scaled); // Prints (10, 10)\n     */\n    multiplyScalar(scale: number): Vector2 {\n        return new Vector2(this.x * scale, this.y * scale);\n    }\n\n    /**\n     * Multiplies this vector by the given other vector and returns the result.\n     * @param other The other vector to multiply with this vector.\n     *\n     * @example Multiply two vectors together.\n     * const first = new Vector2(1, 2);\n     * const second = new Vector2(3, 4);\n     * const multiplied = first.multiply(second);\n     *\n     * os.toast(multiplied); // Prints (3, 8)\n     */\n    multiply(other: Vector2): Vector2 {\n        return new Vector2(this.x * other.x, this.y * other.y);\n    }\n\n    /**\n     * Calculates the dot product of this vector compared to the given other vector.\n     * Returns a number that is positive if the vectors point in the same direction,\n     * negative if they point in opposite directions, and zero if they are perpendicular.\n     * For normalized vectors, this value is clamped to 1 and -1.\n     * @param other The other vector to calculate the dot product with.\n     *\n     * @example Determine how two vectors are pointing towards/away from the same direction.\n     * const first = new Vector2(1, 2);\n     * const second = new Vector2(3, 4);\n     *\n     * const dot = first.dot(second);\n     * if (dot < 0) {\n     *     os.toast(\"Vectors are pointing away from each other!\");\n     * } else if (dot === 0) {\n     *     os.toast(\"Vectors 90 degrees away from each other!\");\n     * } else {\n     *     os.toast(\"Vectors are pointing towards from each other!\");\n     * }\n     */\n    dot(other: Vector2): number {\n        return this.x * other.x + this.y * other.y;\n    }\n\n    /**\n     * Calculates the length of this vector and returns the result.\n     *\n     * @example Get the length of the vector.\n     * const myVector = new Vector2(1, 2);\n     * const length = myVector.length();\n     *\n     * os.toast(`Vector is ${length} units long`);\n     */\n    length(): number {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n\n    /**\n     * Calculates the square length of this vector and returns the result.\n     * This is equivalent to length^2, but it is faster to calculate than length because it doesn't require\n     * calculating a square root.\n     *\n     * @example Get the square length of the vector.\n     * const myVector = new Vector2(1, 2);\n     * const length = myVector.squareLength();\n     *\n     * os.toast(`Vector is ${length}^2 units long`);\n     */\n    squareLength(): number {\n        return this.x * this.x + this.y * this.y;\n    }\n\n    /**\n     * Calculates the normalized version of this vector and returns it.\n     * A normalized vector is a vector whose length equals 1.\n     *\n     * Normalizing a vector preserves its directionality while making the length (i.e. scale) of it 1.\n     *\n     * @example Normalize a vector.\n     * const myVector = new Vector2(1, 2);\n     * const normalized = myVector.normalize();\n     *\n     * os.toast(`Vector: ${myVector}, Normalized: ${normalized}`);\n     */\n    normalize(): Vector2 {\n        const length = this.length();\n        return new Vector2(this.x / length, this.y / length);\n    }\n\n    /**\n     * Negates each component of this vector and returns a new vector that contains the result.\n     *\n     * @example Negate a vector.\n     * const myVector = new Vector2(1, 2);\n     * const negated = myVector.negate();\n     *\n     * os.toast(`Vector: ${myVector}, Negated: ${negated}`);\n     */\n    negate(): Vector2 {\n        return new Vector2(-this.x, -this.y);\n    }\n\n    /**\n     * Converts this vector to a human-readable string representation.\n     *\n     * @example Get a string of a vector.\n     * const myVector = new Vector2(1, 2);\n     * const vectorString = myVector.toString();\n     *\n     * os.toast('My Vector: ' + vectorString);\n     */\n    toString(): string {\n        return `Vector2(${this.x}, ${this.y})`;\n    }\n\n    /**\n     * Determines if this vector equals the other vector.\n     * @param other The other vector.\n     *\n     * @example Determine if two vectors represent the same value.\n     * const first = new Vector2(1, 2);\n     * const second = new Vector2(3, 4);\n     * const third = new Vector2(1, 2);\n     *\n     * os.toast(`first == second: ${first.equals(second)}; first == third: ${first.equals(third)}`)\n     */\n    equals(other: Vector2): boolean {\n        return this.x === other.x && this.y === other.y;\n    }\n}\n","import { clamp } from '../utils';\nimport { Vector2 } from './Vector2';\n\n/**\n * Defines a class that represents a 3D point in space.\n */\nexport class Vector3 {\n    /**\n     * The X value of this vector.\n     */\n    x: number;\n\n    /**\n     * The Y value of this vector.\n     */\n    y: number;\n\n    /**\n     * The Z value of this vector.\n     */\n    z: number;\n\n    /**\n     * Gets a new Vector2 that contains this vector's X and Y components.\n     */\n    get xy() {\n        return new Vector2(this.x, this.y);\n    }\n\n    /**\n     * Gets a new Vector2 that contains this vector's X and Z components.\n     */\n    get xz() {\n        return new Vector2(this.x, this.z);\n    }\n\n    /**\n     * Gets a new Vector2 that contains this vector's Y and Z components.\n     */\n    get yz() {\n        return new Vector2(this.y, this.z);\n    }\n\n    /**\n     * Constructs a new 3D vector with the given X and Y values.\n     * @param x The X value of the vector.\n     * @param y The Y value of the vector.\n     * @param z The Z value of the vector.\n     *\n     * @example Create a new Vector3 object with the position (2, 3, 4).\n     * let myVector = new Vector3(2, 3, 4);\n     *\n     * os.toast(`X: ${myVector.x}, Y: ${myVector.y}, Z: ${myVector.z}`);\n     *\n     * @example Move this bot to (1, 2, 3) in the home dimension.\n     * tags.homePosition = new Vector3(1, 2, 3);\n     */\n    constructor(x: number = 0, y: number = 0, z: number = 0) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        Object.freeze(this);\n    }\n\n    /**\n     * Creates a 3D vector with the given X and Y values that is normalized immediately upon creation.\n     * @param x The X value of the vector.\n     * @param y The Y value of the vector.\n     * @param z The Z value of the vector.\n     *\n     * @example Create a normalized vector\n     * const vector = Vector3.createNormalized(1, 2, 3);\n     */\n    static createNormalized(x: number, y: number, z: number) {\n        const length = Math.sqrt(x * x + y * y + z * z);\n        return new Vector3(x / length, y / length, z / length);\n    }\n\n    /**\n     * Calculates the angle between the two given vectors and returns the result in radians.\n     * @param first The first vector that should be used for comparision.\n     * @param second The second vector that should be used for comparision.\n     *\n     * @example Find the angle between two vectors.\n     * const first = new Vector3(\n     *     Math.cos(Math.PI / 3),\n     *     Math.sin(Math.PI / 3),\n     *     0,\n     * ); // 60 degrees\n     * const second = new Vector3(\n     *     Math.cos(Math.PI / 2),\n     *     Math.sin(Math.PI / 2),\n     *     0\n     * ); // 90 degrees\n     *\n     * const angle = Vector3.angleBetween(first, second);\n     * os.toast(angle);\n     */\n    static angleBetween(first: Vector3, second: Vector3): number {\n        const dot = first.dot(second);\n        const l1 = first.length();\n        const l2 = second.length();\n        const cos = dot / (l1 * l2);\n        if (cos <= 1 && cos >= -1) {\n            return Math.acos(cos);\n        } else {\n            // Sometimes the dot product ends up outside the 1 <-> -1 range and we need to clamp it.\n            return Math.acos(clamp(cos, -1, 1));\n        }\n    }\n\n    /**\n     * Calculates the distance between the two given vectors and returns the result.\n     * @param first The first vector that should be used for comparision.\n     * @param second The second vector that should be used for comparision.\n     *\n     * @example Find the distance between two vectors.\n     * const first = new Vector3(5, 10, 3);\n     * const second = new Vector3(9, 2, 6);\n     * const distance = Vector3.distanceBetween(first, second);\n     *\n     * os.toast(`Distance: ${distance}`);\n     */\n    static distanceBetween(first: Vector3, second: Vector3): number {\n        const direction = second.subtract(first);\n        return direction.length();\n    }\n\n    /**\n     * Constructs a new vector that is the linear interpolation between the given start and end positions.\n     * The degree that the result is interpolated is determined by the given amount parameter.\n     * @param start The start position.\n     * @param finish The end position.\n     * @param amount The amount that the resulting position should be interpolated between the start and end positions.  Values near 0 indicate rotations close to the first and values near 1 indicate rotations close to the second.\n     *\n     * @example Find the position that is halfway between two vectors.\n     * const start = new Vector3(5, 10, 15);\n     * const finish = new Vector3(9, 2, 6);\n     * const halfway = Vector3.interpolatePosition(start, finish, 0.5);\n     *\n     * os.toast(halfway);\n     *\n     * @example Find the position that is 1/4 between two vectors.\n     * const start = new Vector3(5, 10, 15);\n     * const finish = new Vector3(9, 2, 6);\n     * const halfway = Vector3.interpolatePosition(start, finish, 0.25);\n     *\n     * os.toast(halfway);\n     */\n    static interpolatePosition(\n        start: Vector3,\n        finish: Vector3,\n        amount: number\n    ) {\n        const dir = finish.subtract(start);\n        const lerp = dir.multiplyScalar(amount);\n        return start.add(lerp);\n    }\n\n    /**\n     * Constructs a new vector that is the directional linear interpolation between the given start and end positions.\n     * The degree that the result is interpolated is determined by the given amount parameter.\n     *\n     * This function works similarly to interpolatePosition(), except the result is always a normalized vector.\n     *\n     * @param start The start position.\n     * @param finish The end position.\n     * @param amount The amount that the resulting position should be interpolated between the start and end positions.  Values near 0 indicate rotations close to the first and values near 1 indicate rotations close to the second.\n     *\n     * @example Find the direction that points halfway between the two vectors.\n     * const start = new Vector3(5, 10, 16);\n     * const finish = new Vector3(9, 2, 6);\n     * const halfway = Vector3.interpolatePosition(start, finish, 0.5);\n     *\n     * os.toast(halfway);\n     */\n    static interpolateDirection(\n        start: Vector3,\n        finish: Vector3,\n        amount: number\n    ) {\n        return Vector3.interpolatePosition(start, finish, amount).normalize();\n    }\n\n    /**\n     * Adds this vector with the other vector and returns the result.\n     * @param other The other vector to add with this vector.\n     *\n     * @example Add two vectors together.\n     * const first = new Vector3(1, 2, 3);\n     * const second = new Vector3(3, 4, 5);\n     * const added = first.add(second);\n     *\n     * os.toast(added); // Prints (4, 6, 8)\n     */\n    add(other: Vector3): Vector3 {\n        return new Vector3(\n            this.x + other.x,\n            this.y + other.y,\n            this.z + other.z\n        );\n    }\n\n    /**\n     * Subtracts the other vector from this vector and returns the result.\n     * @param other The other vector that should be subtracted from this vector.\n     *\n     * @example Subtract two vectors.\n     * const first = new Vector3(1, 2, 3);\n     * const second = new Vector3(3, 4, 5);\n     * const subtracted = first.subtract(second);\n     * os.toast(subtracted);\n     *\n     * @example Find the direction from one vector to another.\n     * const first = new Vector3(1, 2, 3);\n     * const second = new Vector3(3, 4, 5);\n     *\n     * const directionFromFirstToSecond = second.subtract(first);\n     * const directionFromSecondToFirst = first.subtract(second);\n     *\n     * os.toast(`first -> second = ${directionFromFirstToSecond}; second -> first = ${directionFromSecondToFirst}`);\n     */\n    subtract(other: Vector3): Vector3 {\n        return new Vector3(\n            this.x - other.x,\n            this.y - other.y,\n            this.z - other.z\n        );\n    }\n\n    /**\n     * Multiplies each component of this vector by the given value and returns the result.\n     * @param scale The scale that should be applied to this vector.\n     *\n     * @example Scale a vector by 10.\n     * const myVector = new Vector3(1, 1, 1);\n     * const scaled = myVector.multiplyScalar(10);\n     * os.toast(scaled); // Prints (10, 10, 10)\n     */\n    multiplyScalar(scale: number): Vector3 {\n        return new Vector3(this.x * scale, this.y * scale, this.z * scale);\n    }\n\n    /**\n     * Multiplies this vector by the given other vector and returns the result.\n     * @param other The other vector to multiply with this vector.\n     *\n     * @example Multiply two vectors together.\n     * const first = new Vector3(1, 2, 3);\n     * const second = new Vector3(3, 4, 5);\n     * const multiplied = first.multiply(second);\n     *\n     * os.toast(multiplied); // Prints (3, 8, 15)\n     */\n    multiply(other: Vector3): Vector3 {\n        return new Vector3(\n            this.x * other.x,\n            this.y * other.y,\n            this.z * other.z\n        );\n    }\n\n    /**\n     * Calculates the dot product of this vector compared to the given other vector.\n     * Returns a number that is positive if the vectors point in the same direction,\n     * negative if they point in opposite directions, and zero if they are perpendicular.\n     * For normalized vectors, this value is clamped to 1 and -1.\n     * @param other The other vector to calculate the dot product with.\n     *\n     * @example Determine how two vectors are pointing towards/away from the same direction.\n     * const first = new Vector3(1, 2, 3);\n     * const second = new Vector3(3, 4, 5);\n     *\n     * const dot = first.dot(second);\n     * if (dot < 0) {\n     *     os.toast(\"Vectors are pointing away from each other!\");\n     * } else if (dot === 0) {\n     *     os.toast(\"Vectors 90 degrees away from each other!\");\n     * } else {\n     *     os.toast(\"Vectors are pointing towards from each other!\");\n     * }\n     */\n    dot(other: Vector3): number {\n        return this.x * other.x + this.y * other.y + this.z * other.z;\n    }\n\n    /**\n     * Calculates the cross product of this vector with the given other vector.\n     * Returns a new vector that is perpendicular to both vectors.\n     * Note that the order of the vectors greatly matters. For example, (1, 0, 0).cross(0, 1, 0) === (0, 0, 1) but (0, 1, 0).cross(1, 0, 0) === (0, 0, -1).\n     * @param other The other vector to calculate the cross product with.\n     *\n     * @example Calculate a vector that is perpendicular to two vectors.\n     * const first = new Vector3(1, 0, 0);\n     * const second = new Vector3(0, 1, 0);\n     *\n     * const result = first.cross(second);\n     * os.toast(`Result: ${result}`); // Prints (0, 0, 1)\n     */\n    cross(other: Vector3): Vector3 {\n        return new Vector3(\n            this.y * other.z - other.y * this.z,\n            this.z * other.x - other.z * this.x,\n            this.x * other.y - other.x * this.y\n        );\n    }\n\n    /**\n     * Calculates the length of this vector and returns the result.\n     *\n     * @example Get the length of the vector.\n     * const myVector = new Vector3(1, 2, 3);\n     * const length = myVector.length();\n     *\n     * os.toast(`Vector is ${length} units long`);\n     */\n    length(): number {\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n    }\n\n    /**\n     * Calculates the square length of this vector and returns the result.\n     * This is equivalent to length^2, but it is faster to calculate than length because it doesn't require\n     * calculating a square root.\n     *\n     * @example Get the square length of the vector.\n     * const myVector = new Vector3(1, 2, 3);\n     * const length = myVector.squareLength();\n     *\n     * os.toast(`Vector is ${length}^2 units long`);\n     */\n    squareLength(): number {\n        return this.x * this.x + this.y * this.y + this.z * this.z;\n    }\n\n    /**\n     * Calculates the normalized version of this vector and returns it.\n     * A normalized vector is a vector whose length equals 1.\n     *\n     * Normalizing a vector preserves its directionality while making the length (i.e. scale) of it 1.\n     *\n     * @example Normalize a vector.\n     * const myVector = new Vector3(1, 2, 3);\n     * const normalized = myVector.normalize();\n     *\n     * os.toast(`Vector: ${myVector}, Normalized: ${normalized}`);\n     */\n    normalize(): Vector3 {\n        const length = this.length();\n        if (length === 1) {\n            return this;\n        }\n        return new Vector3(this.x / length, this.y / length, this.z / length);\n    }\n\n    /**\n     * Negates each component of this vector and returns a new vector that contains the result.\n     *\n     * @example Negate a vector.\n     * const myVector = new Vector3(1, 2, 3);\n     * const negated = myVector.negate();\n     *\n     * os.toast(`Vector: ${myVector}, Negated: ${negated}`);\n     */\n    negate(): Vector3 {\n        return new Vector3(-this.x, -this.y, -this.z);\n    }\n\n    /**\n     * Converts this vector to a human-readable string representation.\n     *\n     * @example Get a string of a vector.\n     * const myVector = new Vector3(1, 2, 3);\n     * const vectorString = myVector.toString();\n     *\n     * os.toast('My Vector: ' + vectorString);\n     */\n    toString(): string {\n        return `Vector3(${this.x}, ${this.y}, ${this.z})`;\n    }\n\n    /**\n     * Determines if this vector equals the other vector.\n     * @param other The other value to compare to.\n     *\n     * @example Determine if two vectors represent the same value.\n     * const first = new Vector3(1, 2, 3);\n     * const second = new Vector3(3, 4, 5);\n     * const third = new Vector3(1, 2, 3);\n     *\n     * os.toast(`first == second: ${first.equals(second)}; first == third: ${first.equals(third)}`)\n     */\n    equals(other: Vector3): boolean {\n        return this.x === other.x && this.y === other.y && this.z === other.z;\n    }\n}\n\n/**\n * A 3D vector that contains (0, 0, 0).\n */\nexport const ZERO = new Vector3();\n\n/**\n * A 3D vector that contains (1, 1, 1).\n */\nexport const ONE = new Vector3(1, 1, 1);\n\n/**\n * A 3D vector that contains (0, 1, 0).\n */\nexport const FORWARD = new Vector3(0, 1, 0);\n\n/**\n * A 3D vector that contains (0, -1, 0).\n */\nexport const BACK = new Vector3(0, -1, 0);\n\n/**\n * A 3D vector that contains (1, 0, 0).\n */\nexport const RIGHT = new Vector3(1, 0, 0);\n\n/**\n * A 3D vector that contains (-1, 0, 0).\n */\nexport const LEFT = new Vector3(-1, 0, 0);\n\n/**\n * A 3D vector that contains (0, 0, 1).\n */\nexport const UP = new Vector3(0, 0, 1);\n\n/**\n * A 3D vector that contains (0, 0, -1).\n */\nexport const DOWN = new Vector3(0, 0, -1);\n","/**\n * Defines a class that represents a Quaternion. That is, a representation of a 3D rotation.\n *\n * Quaternions are a mathematical representation of 3D transformations and are commonly used to calculate and apply rotations to 3D points.\n * They work by defining a quaterion such that q = w + x*i + y*j + z*k, where w, x, y, and z are real numbers and i, j, and k are imaginary numbers.\n * The basics of this is that x, y, and z define a vector that represents the rotation axis, and w defines an angle around which the rotation occurs.\n * However, because i, j, and k are included we can keep x, y, and z from incorrectly interacting with each other and so avoid common pitfalls like Gimbal lock.\n *\n * One little known feature of quaternions is that they can also represent reflections and also scale.\n * This is because there are two different ways to apply a quaternion to a 3D point:\n *\n * - quaterion * point * inverse(quaterion)\n *\n * This formula rotates and scales the point quaternion. The rotation occurs around the axis specified by the quaternion X, Y, and Z values.\n * Additionally, the point will be scaled by the length of the quaternion. (i.e. sqrt( x^2 + y^2 + z^2 + w^2 ))\n * This is why quaternions that are used to represent only rotations must be normalized.\n *\n * - quaternion * point * quaternion\n *\n * This formula reflects scales the point by the quaternion. The reflection occurs across the axis specified by the quaternion X, Y, and Z values.\n * Additionally, the point will be scaled by the length of the quaternion. (i.e. sqrt( x^2 + y^2 + z^2 + w^2 ))\n */\nexport class Quaternion {\n    /**\n     * The X value of the quaternion.\n     */\n    x: number;\n\n    /**\n     * The Y value of the quaternion.\n     */\n    y: number;\n\n    /**\n     * The Z value of the quaternion.\n     */\n    z: number;\n\n    /**\n     * The W value of the quaternion.\n     */\n    w: number;\n\n    /**\n     * Creates a new Quaternion with the given values.\n     * @param x The X value.\n     * @param y The Y value.\n     * @param z The Z value.\n     * @param w The W value.\n     */\n    constructor(x: number = 0, y: number = 0, z: number = 0, w: number = 1) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n        Object.freeze(this);\n    }\n\n    /**\n     * Multiplies this quaternion by the other quaternion and returns the result.\n     * In quaternion math, multiplication can be used to combine quaternions together,\n     * however unlike regular multiplication quaternion multiplication is order dependent.\n     *\n     * Which frame of reference you want to use depends on which order you use.\n     * For example, q2.multiply(q1) starts with the identity, applies q1 to it, and then applies q2 to that.\n     * Whereas, q1.multiply(q2) starts with the identity, applies q2 to it, and then applies q1 to that.\n     *\n     * @param other The other quaternion.\n     */\n    multiply(other: Quaternion): Quaternion {\n        // Taken from https://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/arithmetic/index.htm\n        const x =\n            this.x * other.w +\n            this.w * other.x +\n            this.y * other.z -\n            this.z * other.y;\n        const y =\n            this.w * other.y -\n            this.x * other.z +\n            this.y * other.w +\n            this.z * other.x;\n        const z =\n            this.w * other.z +\n            this.x * other.y -\n            this.y * other.x +\n            this.z * other.w;\n        const w =\n            this.w * other.w -\n            this.x * other.x -\n            this.y * other.y -\n            this.z * other.z;\n        return new Quaternion(x, y, z, w);\n    }\n\n    /**\n     * Calculates the conjugate of this quaternion and returns the result.\n     * The conjugate (or inverse) of a quaternion is similar to negating a number.\n     * When you multiply a quaternion by its conjugate, the result is the identity quaternion.\n     */\n    invert(): Quaternion {\n        return new Quaternion(-this.x, -this.y, -this.z, this.w);\n    }\n\n    /**\n     * Gets the length of this vector. That is, the pathagorean theorem applied to X, Y, Z, and W.\n     */\n    length(): number {\n        return Math.sqrt(\n            this.x * this.x +\n                this.y * this.y +\n                this.z * this.z +\n                this.w * this.w\n        );\n    }\n\n    /**\n     * Calculates the square length of this quaternion and returns the result.\n     * This is equivalent to length^2, but it is faster to calculate than length because it doesn't require\n     * calculating a square root.\n     */\n    squareLength(): number {\n        return (\n            this.x * this.x +\n            this.y * this.y +\n            this.z * this.z +\n            this.w * this.w\n        );\n    }\n\n    /**\n     * Calculates the normalized version of this quaternion and returns it.\n     * A normalized quaternion is a quaternion whose length equals 1.\n     *\n     * Normalizing a quaternion preserves its rotation/reflection while making the length (i.e. scale) of it 1.\n     */\n    normalize(): Quaternion {\n        const length = this.length();\n        return new Quaternion(\n            this.x / length,\n            this.y / length,\n            this.z / length,\n            this.w / length\n        );\n    }\n\n    toString(): string {\n        return `Quaternion(${this.x}, ${this.y}, ${this.z}, ${this.w})`;\n    }\n\n    /**\n     * Determines if this quaternion equals the other quaternion.\n     * @param other The other quaternion to apply.\n     */\n    equals(other: Quaternion): boolean {\n        if (!other) {\n            return false;\n        }\n\n        return (\n            this.x === other.x &&\n            this.y === other.y &&\n            this.z === other.z &&\n            this.w === other.w\n        );\n    }\n}\n\n/**\n * The identity quaternion.\n */\nexport const IDENTITY = new Quaternion(0, 0, 0, 1);\n","import { Quaternion } from './Quaternion';\nimport { Vector2 } from './Vector2';\nimport { Vector3 } from './Vector3';\n\n/**\n * Defines a class that can represent geometric rotations.\n */\nexport class Rotation {\n    private _q: Quaternion;\n\n    /**\n     * The quaternion that this rotation uses.\n     */\n    get quaternion() {\n        return this._q;\n    }\n\n    /**\n     * Creates a new rotation using the given parameters.\n     * @param rotation The information that should be used to construct the rotation.\n     *\n     * @example Create a rotation from an axis and angle.\n     * const rotation = new Rotation({\n     *     axis: new Vector3(0, 0, 1),\n     *     angle: Math.PI / 2\n     * }); // 90 degree rotation around Z axis\n     *\n     * @example Create a rotation from two vectors.\n     * const rotation = new Rotation({\n     *     from: new Vector3(1, 0, 0),\n     *     to: new Vector3(0, 1, 0)\n     * }); // Rotation that rotates (1, 0, 0) to (0, 1, 0)\n     *\n     * @example Create a rotation that looks along the X axis.\n     * const rotation = new Rotation({\n     *     direction: new Vector3(1, 0, 0),\n     *     upwards: new Vector3(0, 0, 1),\n     *     errorHandling: 'nudge'\n     * });\n     *\n     * @example Tilt this bot forwards in the home dimension.\n     * tags.homeRotation = new Rotation({\n     *     axis: new Vector3(1, 0, 0),\n     *     angle: Math.PI / 6 // 30 degrees\n     * });\n     */\n    constructor(\n        rotation?:\n            | FromToRotation\n            | AxisAndAngle\n            | QuaternionRotation\n            | Quaternion\n            | SequenceRotation\n            | EulerAnglesRotation\n            | LookRotation\n    ) {\n        if (!rotation) {\n            this._q = new Quaternion(0, 0, 0, 1);\n        } else if ('axis' in rotation) {\n            this._q = Rotation.quaternionFromAxisAndAngle(rotation);\n        } else if ('from' in rotation) {\n            this._q = Rotation.quaternionFromTo(rotation);\n        } else if ('quaternion' in rotation) {\n            const q = rotation.quaternion;\n            this._q = new Quaternion(q.x, q.y, q.z, q.w).normalize();\n        } else if ('sequence' in rotation) {\n            let q = new Quaternion(0, 0, 0, 1);\n            for (let r of rotation.sequence) {\n                q = r.quaternion.multiply(q);\n            }\n            this._q = q;\n        } else if ('euler' in rotation) {\n            let q = new Quaternion(0, 0, 0, 1);\n            let order = rotation.euler.order ?? 'XYZ';\n            let extrinsic = rotation.euler.extrinsic ?? false;\n\n            function combine(q: Quaternion, rotation: Quaternion) {\n                if (extrinsic) {\n                    return rotation.multiply(q);\n                } else {\n                    return q.multiply(rotation);\n                }\n            }\n\n            for (let char of order) {\n                if (char === 'X' || char === 'x') {\n                    q = combine(\n                        q,\n                        Rotation.quaternionFromAxisAndAngle({\n                            axis: new Vector3(1, 0, 0),\n                            angle: rotation.euler.x,\n                        })\n                    );\n                } else if (char === 'Y' || char === 'y') {\n                    q = combine(\n                        q,\n                        Rotation.quaternionFromAxisAndAngle({\n                            axis: new Vector3(0, 1, 0),\n                            angle: rotation.euler.y,\n                        })\n                    );\n                } else if (char === 'Z' || char === 'z') {\n                    q = combine(\n                        q,\n                        Rotation.quaternionFromAxisAndAngle({\n                            axis: new Vector3(0, 0, 1),\n                            angle: rotation.euler.z,\n                        })\n                    );\n                }\n            }\n            this._q = q;\n        } else if ('direction' in rotation) {\n            this._q = Rotation.quaternionLook(rotation);\n        } else if (rotation instanceof Quaternion) {\n            this._q = rotation.normalize();\n        } else {\n            this._q = new Quaternion(0, 0, 0, 1);\n        }\n    }\n\n    /**\n     * Constructs a new Quaternion from the given axis and angle.\n     * @param axisAndAngle The object that contains the axis and angle values.\n     */\n    static quaternionFromAxisAndAngle(axisAndAngle: AxisAndAngle): Quaternion {\n        const normalizedAxis = axisAndAngle.axis.normalize();\n        const sinAngle = Math.sin(axisAndAngle.angle / 2);\n        const cosAngle = Math.cos(axisAndAngle.angle / 2);\n        return new Quaternion(\n            normalizedAxis.x * sinAngle,\n            normalizedAxis.y * sinAngle,\n            normalizedAxis.z * sinAngle,\n            cosAngle\n        );\n    }\n\n    /**\n     * Constructs a new Quaternion from the given from/to rotation.\n     * This is equivalent to calculating the cross product and angle between the two vectors and constructing an axis/angle quaternion.\n     * @param fromToRotation The object that contains the from and to values.\n     */\n    static quaternionFromTo(fromToRotation: FromToRotation): Quaternion {\n        const normalizedFrom = fromToRotation.from.normalize();\n        const normalizedTo = fromToRotation.to.normalize();\n\n        const cross = normalizedFrom.cross(normalizedTo);\n        const angle = Vector3.angleBetween(normalizedFrom, normalizedTo);\n\n        return Rotation.quaternionFromAxisAndAngle({\n            axis: cross,\n            angle,\n        });\n    }\n\n    /**\n     * Constructs a new Quaternion from the given look rotation.\n     * @param look The object that contains the look rotation values.\n     */\n    static quaternionLook(look: LookRotation): Quaternion {\n        if (look.errorHandling !== 'error' && look.errorHandling !== 'nudge') {\n            throw new Error(\n                'The errorHandling property must be provided. It must be a string that contains either \"error\" or \"nudge\".'\n            );\n        }\n\n        if (look.direction.squareLength() < 0.0001) {\n            return new Quaternion();\n        }\n\n        let direction = look.direction.normalize();\n        let up = look.upwards.normalize();\n        const lookUpDot = direction.dot(up);\n        if (look.errorHandling === 'error') {\n            if (lookUpDot > 0.9998) {\n                throw new Error(\n                    `The up and direction vectors must not be the same when constructing a look rotation.\\nThis is because vectors that are parallel don't have a valid cross product. (i.e. There are infinite vectors that are perpendicular to both)`\n                );\n            } else if (lookUpDot < -0.9998) {\n                throw new Error(\n                    `The up and direction vectors must not be opposites when constructing a look rotation.\\nThis is because vectors that are parallel don't have a valid cross product. (i.e. There are infinite vectors that are perpendicular to both)`\n                );\n            }\n        } else {\n            if (Math.abs(up.z) === 1) {\n                direction = new Vector3(\n                    direction.x,\n                    direction.y + 0.0001,\n                    direction.z\n                );\n            } else {\n                direction = new Vector3(\n                    direction.x + 0.00001,\n                    direction.y,\n                    direction.z\n                );\n            }\n        }\n\n        // Matrix version from:\n        // https://www.euclideanspace.com/maths/algebra/vectors/lookat/index.htm\n        // with changed order to use Y-up coordinate system\n        const y = direction.normalize();\n        const x = y.cross(up).normalize();\n\n        const z = x.cross(y);\n\n        const m00 = x.x;\n        const m01 = y.x;\n        const m02 = z.x;\n        const m10 = x.y;\n        const m11 = y.y;\n        const m12 = z.y;\n        const m20 = x.z;\n        const m21 = y.z;\n        const m22 = z.z;\n\n        // https://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n        const qw = Math.sqrt(Math.max(0, 1 + m00 + m11 + m22)) / 2;\n        let qx = copySign(\n            m21 - m12,\n            Math.sqrt(Math.max(0, 1 + m00 - m11 - m22)) / 2\n        );\n        let qy = copySign(\n            m02 - m20,\n            Math.sqrt(Math.max(0, 1 - m00 + m11 - m22)) / 2\n        );\n        let qz = copySign(\n            m10 - m01,\n            Math.sqrt(Math.max(0, 1 - m00 - m11 + m22)) / 2\n        );\n\n        return new Quaternion(qx, qy, qz, qw);\n    }\n\n    /**\n     * Determines the angle between the two given quaternions and returns the result in radians.\n     * @param first The first quaternion. Must be a quaterion that represents a rotation\n     * @param second The second quaternion.\n     */\n    static angleBetween(first: Rotation, second: Rotation): number {\n        const delta = first.quaternion.invert().multiply(second.quaternion);\n        return 2 * Math.acos(delta.w);\n    }\n\n    /**\n     * Constructs a new rotation that is the spherical linear interpolation between the given first and second rotations.\n     * The degree that the result is interpolated is determined by the given amount parameter.\n     * @param first The first rotation.\n     * @param second The second rotation.\n     * @param amount The amount that the resulting rotation should be interpolated between the first and second rotations. Values near 0 indicate rotations close to the first and values near 1 indicate rotations close to the second.\n     */\n    static interpolate(\n        first: Rotation,\n        second: Rotation,\n        amount: number\n    ): Rotation {\n        const q1 = first.quaternion;\n        const q2 = second.quaternion;\n\n        const cosHalfTheta =\n            q1.w * q2.w + q1.x * q2.x + q1.y * q2.y + q1.z * q2.z;\n\n        // if angle beween is 0 then we can simply return the first rotation\n        if (cosHalfTheta >= 1 || cosHalfTheta <= -1) {\n            return new Rotation(new Quaternion(q1.x, q1.y, q1.z, q1.w));\n        }\n        const sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);\n\n        // If angle between is 180, then we can choose either axis normal to first or second.\n        if (Math.abs(sinHalfTheta) <= 0.001) {\n            return new Rotation(\n                new Quaternion(\n                    q1.x * 0.5 + q2.x * 0.5,\n                    q1.y * 0.5 + q2.y * 0.5,\n                    q1.z * 0.5 + q2.z * 0.5,\n                    q1.w * 0.5 + q2.w * 0.5\n                )\n            );\n        }\n\n        const halfTheta = Math.acos(cosHalfTheta);\n        const ratioA = Math.sin((1 - amount) * halfTheta) / sinHalfTheta;\n        const ratioB = Math.sin(amount * halfTheta) / sinHalfTheta;\n\n        return new Rotation(\n            new Quaternion(\n                q1.x * ratioA + q2.x * ratioB,\n                q1.y * ratioA + q2.y * ratioB,\n                q1.z * ratioA + q2.z * ratioB,\n                q1.w * ratioA + q2.w * ratioB\n            )\n        );\n    }\n\n    /**\n     * Rotates the given Vector3 by this quaternion and returns a new vector containing the result.\n     * @param vector The 3D vector that should be rotated.\n     *\n     * @example Apply a rotation to a Vector3 object.\n     * const rotation = new Rotation({\n     *     axis: new Vector3(1, 0, 0),\n     *     angle: Math.PI / 4\n     * }); // 45 degree rotation around X axis\n     *\n     * const point = new Vector3(1, 2, 0);\n     * const rotated = rotation.rotateVector3(point);\n     * os.toast(rotated);\n     */\n    rotateVector3(vector: Vector3): Vector3 {\n        // Multiplied out version of (q * vector * q^-1)\n        const q = this.quaternion;\n        return new Vector3(\n            q.w * q.w * vector.x +\n                2 * q.y * q.w * vector.z -\n                2 * q.z * q.w * vector.y +\n                q.x * q.x * vector.x +\n                2 * q.y * q.x * vector.y +\n                2 * q.z * q.x * vector.z -\n                q.z * q.z * vector.x -\n                q.y * q.y * vector.x,\n            2 * q.x * q.y * vector.x +\n                q.y * q.y * vector.y +\n                2 * q.z * q.y * vector.z +\n                2 * q.w * q.z * vector.x -\n                q.z * q.z * vector.y +\n                q.w * q.w * vector.y -\n                2 * q.x * q.w * vector.z -\n                q.x * q.x * vector.y,\n            2 * q.x * q.z * vector.x +\n                2 * q.y * q.z * vector.y +\n                q.z * q.z * vector.z -\n                2 * q.w * q.y * vector.x -\n                q.y * q.y * vector.z +\n                2 * q.w * q.x * vector.y -\n                q.x * q.x * vector.z +\n                q.w * q.w * vector.z\n        );\n    }\n\n    /**\n     * Rotates the given Vector2 by this quaternion and returns a new vector containing the result.\n     * Note that rotations around any other axis than (0, 0, 1) or (0, 0, -1) can produce results that contain a Z component.\n     * @param vector The 2D vector that should be rotated.\n     *\n     * @example Apply a rotation to a Vector2 object.\n     * const rotation = new Rotation({\n     *     axis: new Vector3(1, 0, 0),\n     *     angle: Math.PI / 4\n     * }); // 45 degree rotation around X axis\n     *\n     * const point = new Vector2(1, 2);\n     * const rotated = rotation.rotateVector2(point);\n     * os.toast(rotated);\n     */\n    rotateVector2(vector: Vector2): Vector3 {\n        return this.rotateVector3(new Vector3(vector.x, vector.y));\n    }\n\n    /**\n     * Combines this rotation with the other rotation and returns a new rotation that represents the combination of the two.\n     * @param other The other rotation.\n     *\n     * @example Combine two rotations together.\n     * const first = new Rotation({\n     *     axis: new Vector3(1, 0, 0),\n     *     angle: Math.PI / 4\n     * }); // 45 degree rotation around X axis\n     * const second = new Rotation({\n     *     axis: new Vector3(1, 0, 0),\n     *     angle: Math.PI / 4\n     * }); // 45 degree rotation around X axis\n     *\n     * const third = first.combineWith(second); // 90 degree rotation around X\n     *\n     * os.toast(third);\n     */\n    combineWith(other: Rotation): Rotation {\n        return new Rotation(other.quaternion.multiply(this.quaternion));\n    }\n\n    /**\n     * Calculates the inverse rotation of this rotation and returns a new rotation with the result.\n     *\n     * @example Calculate the inverse of a rotation.\n     * const first = new Rotation({\n     *     axis: new Vector3(1, 0, 0),\n     *     angle: Math.PI / 4\n     * }); // 45 degree rotation around X axis\n     * const inverse = first.inverse();\n     *\n     * const result = first.combineWith(inverse);\n     *\n     * os.toast(result);\n     */\n    invert(): Rotation {\n        return new Rotation(this._q.invert());\n    }\n\n    /**\n     * Gets the axis and angle that this rotation rotates around.\n     */\n    axisAndAngle(): AxisAndAngle {\n        const halfAngle = Math.acos(this.quaternion.w);\n        const sinHalfAngle = Math.sin(halfAngle);\n        const x = this.quaternion.x / sinHalfAngle;\n        const y = this.quaternion.y / sinHalfAngle;\n        const z = this.quaternion.z / sinHalfAngle;\n        const angle = halfAngle * 2;\n\n        return {\n            axis: new Vector3(x, y, z),\n            angle: angle,\n        };\n    }\n\n    /**\n     * Determines if this rotation equals the other rotation.\n     * @param other The rotation to check.\n     */\n    equals(other: Rotation): boolean {\n        return this._q.equals(other?._q);\n    }\n\n    /**\n     * Converts this rotation to a human-readable string representation.\n     *\n     * @example Get a string of a rotation.\n     * const myRotation = new Rotation({\n     *     axis: new Vector3(1, 0, 0),\n     *     angle: Math.PI / 4\n     * }); // 45 degree rotation around X axis\n     * const rotationString = myRotation.toString();\n     *\n     * os.toast('My Rotation: ' + rotationString);\n     */\n    toString(): string {\n        const { axis, angle } = this.axisAndAngle();\n        const angleWithoutPi = angle / Math.PI;\n        if (angle === 0) {\n            return `Rotation(identity)`;\n        }\n        return `Rotation(axis: ${axis}, angle: Math.PI * ${angleWithoutPi})`;\n    }\n}\n\n/**\n * Defines an interface that represents a from/to rotation.\n * That is, a rotation that is able to rotate a vector from the given vector direction to the given vector direction.\n */\nexport interface FromToRotation {\n    /**\n     * The direction that the rotation should rotate from.\n     */\n    from: Vector3;\n\n    /**\n     * The direction that the rotation should rotate to.\n     */\n    to: Vector3;\n}\n\n/**\n * Defines an interface that represents an Axis and Angle pair.\n */\nexport interface AxisAndAngle {\n    /**\n     * The axis about which the angle should rotate around.\n     */\n    axis: Vector3;\n\n    /**\n     * The number of radians that should be rotated around the axis.\n     */\n    angle: number;\n}\n\n/**\n * Defines an interface that represents an Euler Angles rotation.\n */\nexport interface EulerAnglesRotation {\n    euler: {\n        /**\n         * The amount to rotate around the X axis.\n         */\n        x: number;\n\n        /**\n         * The amount to rotate around the Y axis.\n         */\n        y: number;\n\n        /**\n         * The amount to rotate around the Z axis.\n         */\n        z: number;\n\n        /**\n         * The order that the rotations should be applied in.\n         * Defaults to XYZ.\n         */\n        order?: string;\n\n        /**\n         * Whether the euler angles are extrinsic.\n         * Defaults to false.\n         */\n        extrinsic?: boolean;\n    };\n}\n\n/**\n * Defines an interface that represents a sequence of rotations.\n */\nexport interface SequenceRotation {\n    /**\n     * The sequence of successive rotations.\n     */\n    sequence: Rotation[];\n}\n\nexport interface QuaternionRotation {\n    quaternion: { x: number; y: number; z: number; w: number };\n}\n\n/**\n * Defines an interface that represents a rotation transforms (0, 1, 0) and (0, 0, 1) to look along the given direction and upwards axes.\n */\nexport interface LookRotation {\n    /**\n     * The direction that (0, 1, 0) should be pointing along after the rotation is applied.\n     */\n    direction: Vector3;\n\n    /**\n     * The direction that the upward axis should be pointing along after the rotation is applied.\n     * If the direction and upwards vectors are not perpendicular, then the direction will be prioritized and the angle between\n     * upwards and the resulting upwards vector will be minimized.\n     *\n     * If direction and upwards are perpendicular, then applying the rotation to (0, 0, 1) will give the upwards vector.\n     */\n    upwards: Vector3;\n\n    /**\n     * How errors with the direction and upwards vectors should be handled.\n     * If the direction and upwards vectors are parallel or perpendicular, then it is not possible to create a rotation\n     * that looks along the direction and uses the upwards vector. The upwards vector is essentially useless in this scenario\n     * and as a result there are an infinite number of possible valid rotations that look along direction vector.\n     *\n     * This parameter provides two ways to handle this situation:\n     *\n     * - \"error\" indicates that an error should be thrown when this situation arises.\n     * - \"nudge\" indicates that the direction vector should be nudged by a miniscule amount in an arbitrary direction.\n     *           This causes the upwards and direction vectors to no longer be parallel, but it can also cause rotation bugs when the direction and upwards are the same.\n     */\n    errorHandling: 'error' | 'nudge';\n}\n\n/**\n * Defines a constant that contains a rotation that, when combined with a rotation, converts a rotation in AUX coordinates to THREE.js coordinates.\n */\nexport const AUX_ROTATION_TO_THREEJS = new Rotation({\n    axis: new Vector3(1, 0, 0),\n    angle: -Math.PI / 2,\n});\n\n/**\n * Copies the sign from signGiver onto signTaker and returns the result.\n * @param signGiver The number whose sign should be given to the other number.\n * @param signTaker The number whose sign should be set.\n */\nexport function copySign(signGiver: number, signTaker: number): number {\n    if (Math.sign(signGiver) === Math.sign(signTaker)) {\n        return signTaker;\n    } else {\n        return signTaker * -1;\n    }\n}\n","import {\n    Bot,\n    Workspace,\n    DEFAULT_WORKSPACE_SCALE,\n    DEFAULT_WORKSPACE_HEIGHT,\n    DEFAULT_WORKSPACE_GRID_SCALE,\n    DEFAULT_BUILDER_USER_COLOR,\n    DEFAULT_PLAYER_USER_COLOR,\n    AuxDomain,\n    BotShape,\n    DEFAULT_BOT_SHAPE,\n    BotTags,\n    DEFAULT_WORKSPACE_SIZE,\n    BotLabelAnchor,\n    DEFAULT_LABEL_ANCHOR,\n    BotDragMode,\n    DimensionVisualizeMode,\n    PrecalculatedBot,\n    PrecalculatedTags,\n    BotsState,\n    DEFAULT_USER_INACTIVE_TIME,\n    DEFAULT_USER_DELETION_TIME,\n    BotPositioningMode,\n    BotSpace,\n    BOT_SPACE_TAG,\n    PortalType,\n    BotSubShape,\n    BotOrientationMode,\n    DEFAULT_ORIENTATION_MODE,\n    BotAnchorPoint,\n    DEFAULT_ANCHOR_POINT,\n    BotLOD,\n    BotLabelAlignment,\n    DEFAULT_LABEL_ALIGNMENT,\n    BotScaleMode,\n    DEFAULT_SCALE_MODE,\n    MeetPortalAnchorPoint,\n    DEFAULT_MEET_PORTAL_ANCHOR_POINT,\n    BotSignatures,\n    DEFAULT_TAG_PORTAL_ANCHOR_POINT,\n    TAG_MASK_SPACE_PRIORITIES,\n    RuntimeBot,\n    DNA_TAG_PREFIX,\n    BotLabelFontSize,\n    DEFAULT_LABEL_FONT_SIZE,\n    BotLabelWordWrap,\n    DEFAULT_LABEL_WORD_WRAP_MODE,\n    MenuBotForm,\n    DEFAULT_MENU_BOT_FORM,\n    PortalCameraControlsMode,\n    DEFAULT_PORTAL_CAMERA_CONTROLS_MODE,\n    MenuBotHoverStyle,\n    MenuBotResolvedHoverStyle,\n    DEFAULT_MENU_BOT_HOVER_STYLE,\n    PortalCameraType,\n    BotCursorType,\n    DEFAULT_BOT_CURSOR,\n    BotLabelPadding,\n    BOT_LINK_TAG_PREFIX,\n    DATE_TAG_PREFIX,\n    STRING_TAG_PREFIX,\n    NUMBER_TAG_PREFIX,\n    DEFAULT_BOT_PORTAL_ANCHOR_POINT,\n    VECTOR_TAG_PREFIX,\n    ROTATION_TAG_PREFIX,\n} from './Bot';\n\nimport { BotCalculationContext, cacheFunction } from './BotCalculationContext';\n\nimport { v4 as uuid } from 'uuid';\nimport {\n    flatMap,\n    union,\n    keys,\n    find,\n    values,\n    isEqual,\n    sortBy,\n    cloneDeep,\n    differenceBy,\n    intersectionBy,\n    unionBy,\n} from 'lodash';\n\n/// <reference path=\"../typings/global.d.ts\" />\nimport { PartialBot } from '../bots';\nimport { merge, shortUuid } from '../utils';\nimport { BotObjectsContext } from './BotObjectsContext';\nimport { DateTime, SystemZone } from 'luxon';\nimport { Quaternion, Rotation, Vector2, Vector3 } from '../math';\n\nexport var isFormulaObjectSymbol: symbol = Symbol('isFormulaObject');\n\nexport var ShortId_Length: number = 5;\n\n/**\n * The default energy for actions.\n */\nexport const DEFAULT_ENERGY: number = 100_000;\n\nexport type SimulationIdParseResult =\n    | SimulationIdParseFailure\n    | SimulationIdParseSuccess;\n\nexport interface SimulationIdParseFailure {\n    success: false;\n}\n\nexport interface SimulationIdParseSuccess {\n    success: true;\n    channel?: string;\n    host?: string;\n}\n\nexport const POSSIBLE_DIMENSION_VISUALIZERS = ['*'] as const;\n\n/**\n * Defines an interface that represents the difference between\n * to BotsState objects.\n */\nexport interface BotsStateDiff {\n    addedBots: Bot[];\n    removedBots: string[];\n    updatedBots: Bot[];\n}\n\n/**\n * Determines whether the given tag value is a valid value or if\n * it represents nothing.\n * @param value The value.\n */\nexport function hasValue(value: unknown) {\n    return !(value === null || typeof value === 'undefined' || value === '');\n}\n\n/**\n * Converts the given value to a string.\n * @param value The value that should be rendered into a string.\n * @returns\n */\nexport function convertToString(value: any): string {\n    if (!hasValue(value)) {\n        return '';\n    }\n    if (typeof value === 'string') {\n        return value;\n    } else if (typeof value !== 'object' && value !== undefined) {\n        return value.toString();\n    } else if (value instanceof Date) {\n        return value.toISOString();\n    } else {\n        return JSON.stringify(value);\n    }\n}\n\n/**\n * Cleans the bot by removing any null or undefined properties.\n * @param bot The bot to clean.\n */\nexport function cleanBot(bot: Bot): Bot {\n    let cleaned = merge({}, bot);\n    // Make sure we're not modifying another bot's tags\n    let newTags = merge({}, cleaned.tags);\n    cleaned.tags = newTags;\n    for (let property in cleaned.tags) {\n        let value = cleaned.tags[property];\n        if (!hasValue(value)) {\n            delete cleaned.tags[property];\n        }\n    }\n    return cleaned;\n}\n\n/**\n * Determines if the given workspace is currently minimized.\n * @param workspace The workspace.\n */\nexport function isMinimized(calc: BotCalculationContext, workspace: Workspace) {\n    return getDimensionMinimized(calc, workspace);\n}\n\n/**\n * Determines if the given bot contains data for a dimension.\n */\nexport function isDimension(\n    calc: BotCalculationContext,\n    dimensionBot: Bot\n): boolean {\n    return getBotConfigDimensions(calc, dimensionBot).length > 0;\n}\n\n/**\n * Determines if the given dimension bot is being visualized in the viewport.\n */\nexport function isVisibleDimension(\n    calc: BotCalculationContext,\n    dimensionBot: Bot\n): boolean {\n    const result = calculateBotValue(\n        calc,\n        dimensionBot,\n        'auxDimensionVisualize'\n    );\n\n    if (typeof result === 'string' && hasValue(result)) {\n        return true;\n    } else if (Array.isArray(result)) {\n        return true;\n    }\n    return false;\n}\n\n/**\n * Filters the given list of bots by whether they belong to the given selection.\n * @param bots The bots to filter.\n * @param selectionId The selection to check.\n */\nexport function filterBotsBySelection<TBot extends Bot>(\n    bots: TBot[],\n    selectionId: string\n) {\n    return bots.filter((f) => {\n        if (f.id === selectionId) {\n            return true;\n        }\n        if (selectionId === 'id' || selectionId === 'space') {\n            return true;\n        }\n        return (\n            hasValue(f.tags[selectionId]) ||\n            hasValue(calculateBotValue(null, f, selectionId))\n        );\n    });\n}\n\n/**\n * Gets the state that should be uploaded from the given data.\n * @param data The data.\n */\nexport function getUploadState(data: any): BotsState {\n    if ('version' in data) {\n        return data.state;\n    }\n    return data;\n}\n\n/**\n * Gets whether the bot is pointable.\n * @param calc The calculation context.\n * @param bot The bot.\n */\nexport function isBotPointable(calc: BotCalculationContext, bot: Bot): boolean {\n    return calculateBooleanTagValue(calc, bot, 'auxPointable', true);\n}\n\n/**\n * Gets whether the bot is focusable.\n * @param calc The calculation context.\n * @param bot The bot.\n */\nexport function isBotFocusable(calc: BotCalculationContext, bot: Bot): boolean {\n    return calculateBooleanTagValue(calc, bot, 'auxFocusable', true);\n}\n\n/**\n * Gets a list of tags that the given bots contain.\n *\n * @param bots The array of bots that the list of tags should be retrieved\n * for.\n * @param currentTags The current array of tags that is being displayed.\n *                    The new list will try to preserve the order of the tags\n * in this list.\n * @param extraTags The list of tags that should not be removed from the\n * output list.\n * @param allowedTags The list of tags that should be allowed in the output list.\n */\nexport function botTags(\n    bots: Bot[],\n    currentTags: string[],\n    extraTags: string[],\n    allowedTags: string[] = null\n): { tag: string; space: string }[] {\n    const botTags = flatMap(bots, (f) => keys(f.tags)).map(\n        (t) => ({ tag: t, space: null as string } as const)\n    );\n    const botMasks = flatMap(bots, (b) => {\n        if (!b.masks) {\n            return [];\n        }\n        let tags = [] as { tag: string; space: string }[];\n        for (let space in b.masks) {\n            let spaceTags = keys(b.masks[space]).map(\n                (k) =>\n                    ({\n                        tag: k,\n                        space: space,\n                    } as const)\n            );\n            tags.push(...spaceTags);\n        }\n        return tags;\n    });\n    const allBotTags = unionBy(botTags, botMasks, tagComparer);\n\n    const extraTagPairs = extraTags.map(\n        (t) => ({ tag: t, space: null as string } as const)\n    );\n    const currentTagPairs = currentTags.map(\n        (t) => ({ tag: t, space: null as string } as const)\n    );\n\n    const tagsToKeep = unionBy(allBotTags, extraTagPairs, tagComparer);\n    const allTags = unionBy(currentTagPairs, tagsToKeep, tagComparer);\n\n    const onlyTagsToKeep = intersectionBy(allTags, tagsToKeep, tagComparer);\n\n    if (allowedTags) {\n        const allowedTagsSet = new Set(allowedTags);\n        return onlyTagsToKeep.filter((t) => allowedTagsSet.has(t.tag));\n    }\n\n    return onlyTagsToKeep;\n\n    function tagComparer(tagPair: { tag: string; space: string }) {\n        return `${tagPair.tag}.${!tagPair.space ? 'null' : tagPair.space}`;\n    }\n}\n\nexport function getAllBotTags(bots: Bot[], includeHidden: boolean) {\n    const botTags = flatMap(bots, (f) => keys(f.tags));\n\n    const nonHiddenTags = botTags.filter(\n        (t) => includeHidden || !isHiddenTag(t)\n    );\n\n    return nonHiddenTags;\n}\n\n/**\n * Find bots that match the short ids.\n * @param bots The bots to search through.\n * @param shortIds The short ids to search for.\n * @returns bot array or null if no matches found.\n */\nexport function botsFromShortIds(bots: Bot[], shortIds: string[]): Bot[] {\n    var matches: Bot[] = [];\n    shortIds.forEach((shortId) => {\n        var bot = this.botFromShortId(bots, shortId);\n        if (bot) matches.push(bot);\n    });\n\n    if (matches.length > 0) return matches;\n    else return null;\n}\n\n/**\n * Find bot that matches the short id.\n * @param bots The bots to search through.\n * @param shortId The short id to search for.\n * @returns bot or undefined if no match found.\n */\nexport function botFromShortId(bots: Bot[], shortId: string): Bot {\n    return find(bots, (f: Bot) => {\n        return getShortId(f) === shortId;\n    });\n}\n\n/**\n * Return the short id for the bot.\n * @param bot The bot to get short id for.\n */\nexport function getShortId(bot: Bot | string): string {\n    let id = typeof bot === 'string' ? bot : bot.id;\n\n    if (typeof id !== 'string') {\n        if (id !== null && typeof id !== 'undefined') {\n            return (<any>id).toString();\n        } else {\n            return null;\n        }\n    }\n\n    let str = id.substr(0, ShortId_Length);\n\n    if (id.startsWith('mod-')) {\n        str = 'mod';\n    }\n\n    if (id.startsWith('config')) {\n        str = 'config';\n    }\n\n    return str;\n}\n\n/**\n * Determines if the given tag is a hidden tag.\n * @param tag The tag to test.\n */\nexport function isHiddenTag(tag: string): boolean {\n    return /^_/.test(tag) || /(\\w+)\\._/.test(tag);\n}\n\n/**\n * Determines if the given bot is a runtime bot.\n * @param bot The bot to check.\n */\nexport function isRuntimeBot(bot: any): bot is RuntimeBot {\n    if (!!bot && typeof bot === 'object') {\n        return (\n            !!bot.id &&\n            typeof bot.tags === 'object' &&\n            typeof bot.raw === 'object' &&\n            typeof bot.masks === 'object' &&\n            typeof bot.tags.toJSON === 'function' &&\n            typeof bot.listeners === 'object' &&\n            typeof bot.changes === 'object' &&\n            typeof bot.maskChanges === 'object'\n        );\n    }\n    return false;\n}\n\nexport function isPrecalculated(\n    bot: Bot | PrecalculatedBot\n): bot is PrecalculatedBot {\n    return bot && (<PrecalculatedBot>bot).precalculated === true;\n}\n\nexport function isExistingBot(bot: Bot | PrecalculatedBot): bot is Bot {\n    return bot && (<Bot>bot).id != undefined;\n}\n\n/**\n * Gets the space that the given bot lives in.\n * @param bot The bot.\n */\nexport function getBotSpace(bot: Bot): BotSpace {\n    const type = bot.space;\n    if (!hasValue(type)) {\n        return 'shared';\n    }\n    return type;\n}\n\nexport function calculateBotValue(\n    context: BotObjectsContext,\n    object: Bot | PrecalculatedBot,\n    tag: keyof BotTags\n) {\n    const value = calculateBotTagValue(object, tag);\n    if (\n        typeof value === 'undefined' &&\n        typeof tag === 'string' &&\n        tag.startsWith('aux') &&\n        tag.length >= 4\n    ) {\n        const firstChar = tag.substring(3, 4);\n        const rest = tag.substring(4);\n        const newTag = firstChar.toLowerCase() + rest;\n        return calculateBotTagValue(object, newTag);\n    }\n    return value;\n}\n\n/**\n * Calculates the list of bot IDs that are stored in the given tag in the given bot.\n * @param bot The bot.\n * @param tag The tag.\n */\nexport function calculateBotIds(\n    object: Bot | PrecalculatedBot,\n    tag: keyof BotTags\n): string[] {\n    const value = calculateBotValue(null, object, tag);\n    if (isBotLink(value)) {\n        return parseBotLink(value);\n    } else if (typeof value === 'string') {\n        return [value];\n    } else if (isBot(value)) {\n        return [value.id];\n    } else if (Array.isArray(value)) {\n        let ids = [] as string[];\n        for (let item of value) {\n            if (isBot(item)) {\n                ids.push(item.id);\n            } else if (typeof item === 'string') {\n                ids.push(item);\n            }\n        }\n        return ids;\n    }\n\n    return null;\n}\n\nfunction calculateBotTagValue(\n    object: Bot | PrecalculatedBot,\n    tag: keyof BotTags\n) {\n    if (tag === 'id') {\n        return object.id;\n    } else if (tag === BOT_SPACE_TAG) {\n        return getBotSpace(object);\n    } else if (isPrecalculated(object)) {\n        return object.values[tag];\n    } else if (isRuntimeBot(object)) {\n        return object.tags[tag];\n    } else {\n        return calculateValue(object, tag, object.tags[tag]);\n    }\n}\n\nexport function calculateFormattedBotValue(\n    context: BotCalculationContext,\n    bot: Bot,\n    tag: string\n): string {\n    const value = calculateBotValue(context, bot, tag);\n    return formatValue(value);\n}\n\n/**\n * Determines if the given value represents a formula.\n */\nexport function isFormula(value: unknown): value is string {\n    return typeof value === 'string' && value.indexOf(DNA_TAG_PREFIX) === 0;\n}\n\n/**\n * Determines if the given value represents a script.\n * @param value The value.\n */\nexport function isScript(value: unknown): value is string {\n    return typeof value === 'string' && value.indexOf('@') === 0;\n}\n\n/**\n * Determiens if the given value represents a bot link.\n * @param value The value.\n */\nexport function isBotLink(value: unknown): value is string {\n    return typeof value === 'string' && value.startsWith(BOT_LINK_TAG_PREFIX);\n}\n\n/**\n * Parses the given value into a list of Bot IDs if it is a link.\n * Returns null if the value is not a bot link.\n * @param value The value to parse.\n */\nexport function parseBotLink(value: unknown): string[] {\n    if (isBotLink(value)) {\n        const split = value.substring(BOT_LINK_TAG_PREFIX.length).split(',');\n        return split.filter((id) => hasValue(id));\n    }\n    return null;\n}\n\n/**\n * Creates a bot link that links to the given bot IDs.\n * @param botIds The IDs of the bots to link to.\n */\nexport function createBotLink(botIds: string[]): string {\n    return `${BOT_LINK_TAG_PREFIX}${botIds.join(',')}`;\n}\n\n/**\n * Determines if the given value represents a date time.\n * @param value The value.\n */\nexport function isBotDate(value: unknown): value is string {\n    return typeof value === 'string' && value.startsWith(DATE_TAG_PREFIX);\n}\n\n/**\n * Parses the given value into a date time object.\n * Returns null if the value is not a date.\n * @param value The value to parse.\n */\nexport function parseBotDate(value: unknown): DateTime {\n    if (isBotDate(value)) {\n        const dateString = value.substring(DATE_TAG_PREFIX.length);\n        const [date, timezone] = dateString.split(' ');\n        const hasTimezone = hasValue(timezone);\n        const result = DateTime.fromISO(date, {\n            setZone: !hasTimezone,\n            zone: hasTimezone ? timezone : 'utc',\n        });\n\n        if (result.isValid) {\n            return result;\n        }\n    }\n\n    return null;\n}\n\n/**\n * Formats the given value into a parseable string.\n * @param value The date to format.\n */\nexport function formatBotDate(value: DateTime): string {\n    const dateString = value.toISO({\n        suppressMilliseconds: true,\n    });\n    const partialFormat = `${DATE_TAG_PREFIX}${dateString}`;\n    if (value.zone === SystemZone.instance) {\n        return partialFormat + ` local`;\n    } else if (!value.zone.isUniversal) {\n        return partialFormat + ` ${value.zoneName}`;\n    } else {\n        return partialFormat;\n    }\n}\n\n/**\n * Parses the given value into a script.\n * Returns the script if the value is a script.\n * Returns null if the value is not a script.\n * @param value The value to parse.\n */\nexport function parseScript(value: unknown): string | null {\n    if (isScript(value)) {\n        return value.substring(1);\n    }\n    return null;\n}\n\n/**\n * Parses the given value into a script.\n * Returns the script if the value is a script.\n * Returns the value if it is not a script.\n * @param value The value to parse.\n */\nexport function parseScriptSafe(value: string): string {\n    return parseScript(value) ?? value;\n}\n\n/**\n * Parses the given value into a formula.\n * Returns the formula if the value is a formula.\n * Returns null if the value is not a formula.\n * @param value The value to parse.\n */\nexport function parseFormula(value: string): string | null {\n    if (isFormula(value)) {\n        return value.substring(DNA_TAG_PREFIX.length);\n    }\n    return null;\n}\n\n/**\n * Parses the given value into a formula.\n * Returns the JSON if the value is a formula.\n * Returns the value if it is not a formula.\n * @param value The value to parse.\n */\nexport function parseFormulaSafe(value: string): string {\n    return parseFormula(value) ?? value;\n}\n\n/**\n * Trims the leading script symbol off the given tag.\n */\nexport function trimPortalScript(\n    scriptPrefixes: string[],\n    tag: string\n): string {\n    const prefix = getScriptPrefix(scriptPrefixes, tag);\n    if (prefix) {\n        return tag.substring(prefix.length);\n    }\n    return tag;\n}\n\n/**\n * Trims the leading script symbol off the given tag.\n */\nexport function trimPrefixedScript(prefix: string, tag: string): string {\n    if (tag.startsWith(prefix)) {\n        return tag.substring(prefix.length);\n    }\n    return tag;\n}\n\n/**\n * Determines if the given value is for a script entrypoint.\n * @param prefix The prefix to check against.\n * @param value The value to check.\n */\nexport function isPortalScript(prefix: string, value: unknown): boolean {\n    return typeof value === 'string' && value.startsWith(prefix);\n}\n\nexport function hasPortalScript(prefixes: string[], value: unknown): boolean {\n    return getScriptPrefix(prefixes, value) !== null;\n}\n\n/**\n * Determines which of the given script prefixes the given value matches.\n * @param prefixes The script prefixes to test against the value.\n * @param value The value to test.\n * @returns\n */\nexport function getScriptPrefix(prefixes: string[], value: unknown): string {\n    if (typeof value === 'string') {\n        for (let prefix of prefixes) {\n            if (value.startsWith(prefix)) {\n                return prefix;\n            }\n        }\n    }\n    return null;\n}\n\nconst INFINITIES = new Set(['infinity', '-infinity']);\n\n/**\n * Determines if the given value represents a number.\n */\nexport function isNumber(value: string): boolean {\n    value = parseTaggedNumber(value);\n    return (\n        typeof value === 'string' &&\n        value.length > 0 &&\n        ((/^-?\\d*(?:\\.?\\d+)?(?:[eE]-?\\d+)?$/.test(value) && value !== '-') ||\n            (typeof value === 'string' && INFINITIES.has(value.toLowerCase())))\n    );\n}\n\n/**\n * Determines if the given value is a string that is tagged with the  emoji.\n * @param value The value to check.\n */\nexport function isTaggedString(value: unknown): value is string {\n    return typeof value === 'string' && value.startsWith(STRING_TAG_PREFIX);\n}\n\n/**\n * Parses the given tagged string into a regular string value.\n * @param value The value that should be parsed as a string.\n */\nexport function parseTaggedString(value: string): string {\n    if (isTaggedString(value)) {\n        return value.substring(STRING_TAG_PREFIX.length);\n    }\n    return value;\n}\n/**\n * Determines if the given value starts with the  emoji tag.\n * @param value The value to test.\n */\nexport function isTaggedNumber(value: string): boolean {\n    return typeof value === 'string' && value.startsWith(NUMBER_TAG_PREFIX);\n}\n\n/**\n * Parses the given tagged number into a regular number value.\n * @param value The value to parse.\n */\nexport function parseTaggedNumber(value: string): string {\n    if (isTaggedNumber(value)) {\n        return value.substring(NUMBER_TAG_PREFIX.length);\n    }\n    return value;\n}\n\n/**\n * Parses the given value into a number.\n * @param value The value to parse.\n */\nexport function parseNumber(value: string): number {\n    value = parseTaggedNumber(value);\n    if (isNumber(value)) {\n        const valueLowerCase = value.toLowerCase();\n        if (valueLowerCase === 'infinity') {\n            return Infinity;\n        } else if (valueLowerCase === '-infinity') {\n            return -Infinity;\n        }\n        return parseFloat(value);\n    }\n    return NaN;\n}\n\n/**\n * Determines if the given value is a valid real number and returns it if it is.\n * If it is not, then the given default value will be returned.\n * @param value The value to check for real-ness. All numerical values are considered real except NaN, and +/- Infinity.\n * @param defaultIfInvalid The default value to return if the value is not real.\n */\nexport function realNumberOrDefault(\n    value: unknown,\n    defaultIfInvalid: number\n): number {\n    if (\n        typeof value !== 'number' ||\n        isNaN(value) ||\n        value === Infinity ||\n        value === -Infinity\n    ) {\n        return defaultIfInvalid;\n    }\n\n    return value;\n}\n\n/**\n * Formats the given value into a parseable vector string.\n * @param vector The vector to format.\n */\nexport function formatBotVector(vector: Vector2 | Vector3): string {\n    if (vector instanceof Vector2) {\n        return `${vector.x},${vector.y}`;\n    } else {\n        return `${vector.x},${vector.y},${vector.z}`;\n    }\n}\n\n/**\n * Determines if the given value represents a bot vector value.\n * @param value The value to check.\n */\nexport function isBotVector(value: unknown): value is string {\n    return typeof value === 'string' && value.startsWith(VECTOR_TAG_PREFIX);\n}\n\n/**\n * Parses the given value into a Vector2 or Vector3 value.\n * @param value The value to parse as a bot vector.\n */\nexport function parseBotVector(value: unknown): Vector2 | Vector3 | null {\n    if (typeof value !== 'string') {\n        return null;\n    }\n\n    if (!value.startsWith('')) {\n        return null;\n    }\n\n    const valueWithoutArrow = value.substring(''.length);\n    const firstComma = valueWithoutArrow.indexOf(',');\n    if (firstComma < 0) {\n        return null;\n    }\n\n    const firstNumber = valueWithoutArrow.substring(0, firstComma);\n    const valueWithoutFirstNumber = valueWithoutArrow.substring(firstComma + 1);\n    const secondComma = valueWithoutFirstNumber.indexOf(',');\n\n    if (secondComma < 0) {\n        return new Vector2(\n            parseNumber(firstNumber),\n            parseNumber(valueWithoutFirstNumber)\n        );\n    }\n\n    const secondNumber = valueWithoutFirstNumber.substring(0, secondComma);\n    const thirdNumber = valueWithoutFirstNumber.substring(secondComma + 1);\n\n    return new Vector3(\n        parseNumber(firstNumber),\n        parseNumber(secondNumber),\n        parseNumber(thirdNumber)\n    );\n}\n\n/**\n * Formats the given value into a parseable rotation string.\n * @param vector The vector to format.\n */\nexport function formatBotRotation(rotation: Rotation): string {\n    const q = rotation.quaternion;\n    return `${q.x},${q.y},${q.z},${q.w}`;\n}\n\n/**\n * Determines if the given value represents a bot rotation.\n * @param value The value to check.\n */\nexport function isBotRotation(value: unknown): value is string {\n    return typeof value === 'string' && value.startsWith(ROTATION_TAG_PREFIX);\n}\n\n/**\n * Parses the given value into a Rotation value.\n * @param value The value to parse as a bot vector.\n */\nexport function parseBotRotation(value: unknown): Rotation | null {\n    if (typeof value !== 'string') {\n        return null;\n    }\n\n    if (!value.startsWith('')) {\n        return null;\n    }\n\n    const valueWithoutArrow = value.substring(''.length);\n    const firstComma = valueWithoutArrow.indexOf(',');\n    if (firstComma < 0) {\n        return null;\n    }\n\n    const firstNumber = valueWithoutArrow.substring(0, firstComma);\n    const valueWithoutFirstNumber = valueWithoutArrow.substring(firstComma + 1);\n    const secondComma = valueWithoutFirstNumber.indexOf(',');\n\n    if (secondComma < 0) {\n        return null;\n    }\n\n    const secondNumber = valueWithoutFirstNumber.substring(0, secondComma);\n    const valueWithoutSecondNumber = valueWithoutFirstNumber.substring(\n        secondComma + 1\n    );\n    const thirdComma = valueWithoutSecondNumber.indexOf(',');\n\n    if (thirdComma < 0) {\n        return null;\n    }\n\n    const thirdNumber = valueWithoutSecondNumber.substring(0, thirdComma);\n    const fourthNumber = valueWithoutSecondNumber.substring(thirdComma + 1);\n\n    if (fourthNumber.length <= 0) {\n        return null;\n    }\n\n    return new Rotation(\n        new Quaternion(\n            parseNumber(firstNumber),\n            parseNumber(secondNumber),\n            parseNumber(thirdNumber),\n            parseNumber(fourthNumber)\n        )\n    );\n}\n\n/**\n * Determines if the given object is a bot.\n * @param object The object to check.\n */\nexport function isBot(object: any): object is Bot {\n    if (object) {\n        return !!object.id && !!object.tags;\n    }\n    return false;\n}\n\n/**\n * Gets the array of objects in the given state that are currently active.\n * @param state The state to get the active objects of.\n */\nexport function getActiveObjects(state: BotsState) {\n    return <Bot[]>values(state);\n}\n\n/**\n * Determines if the given tag is \"well known\".\n * @param tag The tag.\n */\nexport function isTagWellKnown(tag: string): boolean {\n    return isHiddenTag(tag);\n}\n\n/**\n * Determines if the bots are equal disregarding well-known hidden tags\n * and their IDs. Bot \"appearance equality\" means instead of asking \"are these bots exactly the same?\"\n * we ask \"are these bots functionally the same?\". In this respect we care about things like color, label, etc.\n * We also care about things like draggable but not _position, _index _selection, etc.\n *\n * You can determine if a tag is \"well-known\" by using isTagWellKnown().\n * @param first The first bot.\n * @param second The second bot.\n */\nexport function doBotsAppearEqual(\n    first: Bot,\n    second: Bot,\n    options: BotAppearanceEqualityOptions = {}\n): boolean {\n    if (first === second) {\n        return true;\n    } else if (!first || !second) {\n        return false;\n    }\n\n    options = merge(\n        {\n            ignoreSelectionTags: true,\n            ignoreId: false,\n        },\n        options\n    );\n\n    if (!options.ignoreId && first.id === second.id) {\n        return true;\n    }\n\n    const tags = union(keys(first.tags), keys(second.tags));\n    const usableTags = tags.filter((t) => !isTagWellKnown(t));\n\n    let allEqual = true;\n    for (let t of usableTags) {\n        if (!isEqual(first.tags[t], second.tags[t])) {\n            allEqual = false;\n            break;\n        }\n    }\n\n    return allEqual;\n}\n\nexport interface BotAppearanceEqualityOptions {\n    ignoreId?: boolean;\n}\n\n/**\n * Defines an interface that represents the result of validating a tag.\n */\nexport interface TagValidation {\n    valid: boolean;\n    'tag.required'?: TagRequired;\n    'tag.invalidChar'?: TagInvalidChar;\n}\n\nexport interface TagRequired {}\n\nexport interface TagInvalidChar {\n    char: string;\n}\n\n/**\n * Validates the given tag and returns any errors for it.\n * @param tag The tag.\n */\nexport function validateTag(tag: string) {\n    let errors: TagValidation = {\n        valid: true,\n    };\n    if (!tag || !tag.trim()) {\n        errors.valid = false;\n        errors['tag.required'] = {};\n    } else {\n        if (tag.indexOf('#') >= 0) {\n            errors.valid = false;\n            errors['tag.invalidChar'] = { char: '#' };\n        }\n    }\n\n    return errors;\n}\n\n/**\n * Gets a partial bot that toggles whether the given bot is apart of the given selection.\n * @param bot The bot.\n * @param selectionId The ID of the selection.\n * @param userId The User that is adding the bot to the selection.\n */\nexport function toggleBotSelection(\n    bot: Bot,\n    selectionId: string,\n    userId: string\n) {\n    return {\n        tags: {\n            [selectionId]: !bot.tags[selectionId],\n        },\n    };\n}\n\n/**\n * Gets the color that the given user bot should appear as.\n * @param calc The bot calculation context.\n * @param userBot The user bot.\n * @param globalsBot The globals bot.\n * @param domain The domain.\n */\nexport function getUserBotColor(\n    calc: BotCalculationContext,\n    userBot: Bot,\n    domain: AuxDomain\n): string {\n    if (userBot.tags['auxColor']) {\n        return calculateBotValue(calc, userBot, 'auxColor');\n    }\n\n    if (domain === 'builder') {\n        return DEFAULT_BUILDER_USER_COLOR;\n    } else {\n        return DEFAULT_PLAYER_USER_COLOR;\n    }\n}\n\n/**\n * Gets the menu ID that is used for the given user.\n * @param userBot The bot for the user.\n */\nexport function getUserMenuId(calc: BotCalculationContext, userBot: Bot) {\n    return calculateBotValue(calc, userBot, 'menuPortal');\n}\n\n/**\n * Gets the list of bots that are in the user's menu.\n * @param calc The bot calculation context.\n * @param userBot The user bot to use.\n */\nexport function getBotsInMenu(\n    calc: BotCalculationContext,\n    userBot: Bot\n): Bot[] {\n    const context = getUserMenuId(calc, userBot);\n    return botsInDimension(calc, context);\n}\n\n/**\n * Gets the list of bots that are in the given dimension.\n * @param calc The bot calculation context.\n * @param dimension The dimension to search for bots in.\n */\nexport function botsInDimension(\n    calc: BotCalculationContext,\n    dimension: string\n): Bot[] {\n    const bots = calc.objects.filter((f) =>\n        isBotInDimension(calc, f, dimension)\n    );\n    return sortBy(bots, (f) => botDimensionSortOrder(calc, f, dimension));\n}\n\n/**\n * Gets a diff that adds a bot to the given dimension.\n * If the bot is already in the dimension, then nothing happens.\n * If other bots are already at the given position, then the bot will be placed at the topmost index.\n * @param calc The bot calculation context.\n * @param dimension The dimension that the bot should be added to.\n * @param x The x position that the bot should be placed at.\n * @param y The x position in the dimension that the bot should be placed at.\n * @param index The index that the bot should be placed at.\n */\nexport function addToDimensionDiff(\n    calc: BotCalculationContext,\n    dimension: string,\n    x: number = 0,\n    y: number = 0,\n    index?: number\n): BotTags {\n    const bots = objectsAtDimensionGridPosition(calc, dimension, { x, y });\n    return {\n        [dimension]: true,\n        ...setPositionDiff(\n            calc,\n            dimension,\n            x,\n            y,\n            typeof index === 'undefined' ? bots.length : index\n        ),\n    };\n}\n\n/**\n * Gets a diff that removes a bot from the given dimension.\n * @param calc The bot calculation context.\n * @param dimension The dimension that the bot should be removed from.\n */\nexport function removeFromDimensionDiff(\n    calc: BotCalculationContext,\n    dimension: string\n): BotTags {\n    return {\n        [dimension]: null,\n        [`${dimension}X`]: null,\n        [`${dimension}Y`]: null,\n        [`${dimension}SortOrder`]: null,\n    };\n}\n\n/**\n * Gets a diff that sets a bot's position in the given dimension.\n * @param calc The bot calculation context.\n * @param dimension The dimension.\n * @param x The X position.\n * @param y The Y position.\n * @param index The index.\n */\nexport function setPositionDiff(\n    calc: BotCalculationContext,\n    dimension: string,\n    x?: number,\n    y?: number,\n    index?: number\n): BotTags {\n    let tags: BotTags = {};\n    if (typeof x === 'number') {\n        tags[`${dimension}X`] = x;\n    }\n    if (typeof y === 'number') {\n        tags[`${dimension}Y`] = y;\n    }\n    if (typeof index === 'number') {\n        tags[`${dimension}SortOrder`] = index;\n    }\n    return tags;\n}\n\n/**\n * Gets the bot update needed to add the given bot to the given user's menu.\n * @param calc The calculation context.\n * @param userBot The bot of the user.\n * @param id The ID that should be used for the menu item. This is separate from bot ID.\n * @param index The index that the bot should be added to. Positive infinity means add at the end. 0 means add at the beginning.\n */\nexport function addBotToMenu(\n    calc: BotCalculationContext,\n    userBot: Bot,\n    id: string,\n    index: number = Infinity\n): PartialBot {\n    const dimension = getUserMenuId(calc, userBot);\n    const bots = getBotsInMenu(calc, userBot);\n    const idx = isFinite(index) ? index : bots.length;\n    return {\n        tags: {\n            [`${dimension}Id`]: id,\n            [`${dimension}SortOrder`]: idx,\n            [dimension]: true,\n        },\n    };\n}\n\n/**\n * Gets the bot update needed to remove a bot from the given user's menu.\n * @param calc The bot calculation context.\n * @param userBot The bot of the user.\n */\nexport function removeBotFromMenu(\n    calc: BotCalculationContext,\n    userBot: Bot\n): PartialBot {\n    const dimension = getUserMenuId(calc, userBot);\n    return {\n        tags: {\n            [dimension]: null,\n            [`${dimension}Id`]: null,\n            [`${dimension}SortOrder`]: null,\n        },\n    };\n}\n\n/**\n * Gets the list of tags that are on the given bot.\n * @param bot\n */\nexport function tagsOnBot(bot: PartialBot): string[] {\n    let tags = new Set(keys(bot.tags));\n    if (bot.masks) {\n        for (let space in bot.masks) {\n            let k = keys(bot.masks[space]);\n            for (let key of k) {\n                tags.add(key);\n            }\n        }\n    }\n    return [...tags.values()];\n}\n\n/**\n * Gets the specified tag value from the specified bot.\n * @param bot The bot that the tag should be retrieved from.\n * @param tag The tag to retrieve.\n */\nexport function getTag(bot: PartialBot, tag: string) {\n    return bot.tags[tag];\n}\n\n/**\n * Gets the specified tag from the specified bot.\n * @param bot The bot that the tag should be retrieved from.\n * @param tag The tag to retrieve.\n */\nexport function getBotTag(bot: Bot, tag: string) {\n    if (tag === 'id') {\n        return bot.id;\n    } else if (tag === BOT_SPACE_TAG) {\n        return getBotSpace(bot);\n    }\n    return getTag(bot, tag);\n}\n\n/**\n * Creates a new codimensionntext ID.\n */\nexport function createDimensionId() {\n    return `${shortUuid()}`;\n}\n\n/**\n * Creates a bot with a new ID and the given tags.\n * @param id The ID of the bot.\n * @param tags The tags to use in the bot.\n * @param space The space of the bot.\n */\nexport function createBot(\n    id = uuid(),\n    tags: Bot['tags'] = {},\n    space?: BotSpace\n): Bot {\n    if (hasValue(space)) {\n        return {\n            id,\n            tags,\n            space,\n        };\n    }\n    return { id, tags };\n}\n\nexport function createPrecalculatedBot(\n    id = uuid(),\n    values: PrecalculatedTags = {},\n    tags?: Bot['tags'],\n    space?: BotSpace\n): PrecalculatedBot {\n    if (hasValue(space)) {\n        return {\n            id,\n            space,\n            precalculated: true,\n            tags: tags || values,\n            values,\n        };\n    }\n    return {\n        id,\n        precalculated: true,\n        tags: tags || values,\n        values,\n    };\n}\n\n/**\n * Calculates the grid scale for the given workspace.\n * @param workspace\n */\nexport function calculateGridScale(\n    calc: BotCalculationContext,\n    workspace: Bot,\n    defaultSurfaceScale: number = DEFAULT_WORKSPACE_SCALE,\n    defaultGridScale: number = DEFAULT_WORKSPACE_GRID_SCALE\n): number {\n    if (workspace) {\n        const scale = calculateNumericalTagValue(\n            calc,\n            workspace,\n            `auxPortalSurfaceScale`,\n            defaultSurfaceScale\n        );\n        const gridScale = calculateNumericalTagValue(\n            calc,\n            workspace,\n            `auxPortalGridScale`,\n            defaultGridScale\n        );\n        return calculateGridScaleFromConstants(scale, gridScale);\n    } else {\n        return calculateGridScaleFromConstants(\n            defaultSurfaceScale,\n            defaultGridScale\n        );\n    }\n}\n\n/**\n * Calculates the grid scale from the given constants.\n * @param surfaceScale\n * @param gridScale\n */\nexport function calculateGridScaleFromConstants(\n    surfaceScale: number,\n    gridScale: number\n) {\n    return surfaceScale * gridScale;\n}\n\n/**\n * Calculates the difference between the two given states.\n * In particular, it calculates which operations need to be performed on prev in order to get current.\n * The returned object contains the bots that were added, removed, and/or updated between the two states.\n * This operation runs in O(n) time where n is the number of bots.\n * @param prev The previous state.\n * @param current The current state.\n */\nexport function calculateStateDiff(\n    prev: BotsState,\n    current: BotsState\n): BotsStateDiff {\n    prev = prev || {};\n    current = current || {};\n\n    let diff: BotsStateDiff = {\n        addedBots: [],\n        removedBots: [],\n        updatedBots: [],\n    };\n\n    const ids = union(keys(prev), keys(current));\n\n    ids.forEach((id) => {\n        const prevVal = prev[id];\n        const currVal = current[id];\n\n        if (prevVal && !currVal) {\n            diff.removedBots.push(prevVal.id);\n        } else if (!prevVal && currVal) {\n            diff.addedBots.push(currVal);\n        } else if (!isEqual(prevVal, currVal)) {\n            diff.updatedBots.push(currVal);\n        }\n    });\n\n    return diff;\n}\n\n/**\n * Trims the leading # symbol off the given tag.\n */\nexport function trimTag(tag: string): string {\n    if (tag.startsWith('#') || tag.startsWith('@')) {\n        return tag.substring(1);\n    }\n    return tag;\n}\n\n/**\n * Trims the leading # symbol and trailing () symbols from the given tag.\n * @param tag The tag.\n */\nexport function trimEvent(tag: string): string {\n    const withoutHash = trimTag(tag);\n    if (withoutHash.endsWith('()')) {\n        return withoutHash.substring(0, withoutHash.length - 2);\n    }\n    return withoutHash;\n}\n\n/**\n * Gets a list of strings from the given bot and tag.\n * @param calc The bot calculation context.\n * @param bot The bot.\n * @param tag The tag.\n */\nexport function getBotStringList(\n    calc: BotCalculationContext,\n    bot: Bot,\n    tag: string\n): string[] {\n    let value = calculateBotValue(calc, bot, tag);\n\n    if (value && !Array.isArray(value)) {\n        value = [value];\n    }\n\n    return value;\n}\n\n/**\n * Gets the AUX_BOT_VERSION number that the given bot was created with.\n * If not specified, then undefined is returned.\n * @param calc The bot calculation context.\n * @param bot THe bot.\n */\nexport function getBotVersion(calc: BotCalculationContext, bot: Bot) {\n    return calculateNumericalTagValue(calc, bot, 'auxVersion', undefined);\n}\n\n/**\n * Gets the index that the given bot is at in the given dimension.\n * @param calc The calculation context to use.\n * @param bot The bot.\n * @param dimension The dimension.\n */\nexport function getBotIndex(\n    calc: BotCalculationContext,\n    bot: Bot,\n    dimension: string\n): number {\n    return calculateNumericalTagValue(calc, bot, `${dimension}SortOrder`, 0);\n}\n\n/**\n * Gets the position that the given bot is at in the given dimension.\n * @param calc The calculation context to use.\n * @param bot The bot.\n * @param dimension The dimension.\n */\nexport function getBotPosition(\n    calc: BotCalculationContext,\n    bot: Bot,\n    dimension: string\n): { x: number; y: number; z: number } {\n    const vector = calculateBotVectorTagValue(\n        calc,\n        bot,\n        `${dimension}Position`,\n        null\n    );\n    if (vector instanceof Vector2) {\n        return {\n            x: vector.x,\n            y: vector.y,\n            z: 0,\n        };\n    } else if (vector instanceof Vector3) {\n        return {\n            x: vector.x,\n            y: vector.y,\n            z: vector.z,\n        };\n    }\n\n    return {\n        x: calculateNumericalTagValue(calc, bot, `${dimension}X`, 0),\n        y: calculateNumericalTagValue(calc, bot, `${dimension}Y`, 0),\n        z: calculateNumericalTagValue(calc, bot, `${dimension}Z`, 0),\n    };\n}\n\n/**\n * Gets the rotation that the given bot is at in the given dimension.\n * @param calc The calculation context to use.\n * @param bot The bot.\n * @param dimension The dimension.\n */\nexport function getBotRotation(\n    calc: BotCalculationContext,\n    bot: Bot,\n    dimension: string\n): Rotation {\n    const rotation = calculateBotRotationTagValue(\n        calc,\n        bot,\n        `${dimension}Rotation`,\n        null\n    );\n    if (rotation) {\n        return rotation;\n    }\n\n    return new Rotation({\n        euler: {\n            x: calculateNumericalTagValue(\n                calc,\n                bot,\n                `${dimension}RotationX`,\n                0\n            ),\n            y: calculateNumericalTagValue(\n                calc,\n                bot,\n                `${dimension}RotationY`,\n                0\n            ),\n            z: calculateNumericalTagValue(\n                calc,\n                bot,\n                `${dimension}RotationZ`,\n                0\n            ),\n        },\n    });\n}\n\n/**\n * Calculates the auxScaleX, auxScaleY, and auxScaleZ values from the given object.\n * @param context The calculation context.\n * @param obj The object.\n * @param multiplier The value that scale values should be multiplied by.\n * @param defaultScale The default value.\n * @param prefix The optional prefix for the tags. Defaults to `aux.`\n */\nexport function getBotScale(\n    context: BotCalculationContext,\n    obj: Bot,\n    defaultScale: number = 1,\n    prefix: string = 'aux'\n) {\n    return cacheFunction(\n        context,\n        'getBotScale',\n        () => {\n            const scaleX = calculateNumericalTagValue(\n                context,\n                obj,\n                `${prefix}ScaleX`,\n                defaultScale\n            );\n            const scaleY = calculateNumericalTagValue(\n                context,\n                obj,\n                `${prefix}ScaleY`,\n                defaultScale\n            );\n            const scaleZ = calculateNumericalTagValue(\n                context,\n                obj,\n                `${prefix}ScaleZ`,\n                defaultScale\n            );\n            const uniformScale = calculateNumericalTagValue(\n                context,\n                obj,\n                `${prefix}Scale`,\n                1\n            );\n\n            return {\n                x: scaleX * uniformScale,\n                y: scaleY * uniformScale,\n                z: scaleZ * uniformScale,\n            };\n        },\n        obj.id,\n        defaultScale,\n        prefix\n    );\n}\n\n/**\n * Gets the shape of the bot.\n * @param calc The calculation context to use.\n * @param bot The bot.\n */\nexport function getBotShape(calc: BotCalculationContext, bot: Bot): BotShape {\n    const shape: BotShape = calculateBotValue(calc, bot, 'auxForm');\n    if (\n        shape === 'cube' ||\n        shape === 'sphere' ||\n        shape === 'sprite' ||\n        shape === 'mesh' ||\n        shape === 'iframe' ||\n        shape === 'nothing' ||\n        shape === 'frustum' ||\n        shape === 'helix' ||\n        shape === 'egg' ||\n        shape === 'hex' ||\n        shape === 'cursor' ||\n        shape === 'portal' ||\n        shape === 'dimension' ||\n        shape === 'circle' ||\n        shape === 'keyboard'\n    ) {\n        return shape;\n    }\n    return DEFAULT_BOT_SHAPE;\n}\n\n/**\n * Gets the form of a menu bot.\n * @param calc The calculation context to use.\n * @param bot The bot.\n */\nexport function getMenuBotForm(\n    calc: BotCalculationContext,\n    bot: Bot\n): MenuBotForm {\n    const shape: MenuBotForm = calculateBotValue(calc, bot, 'auxForm');\n    if (shape === 'button' || shape === 'input') {\n        return shape;\n    }\n    return DEFAULT_MENU_BOT_FORM;\n}\n\n/**\n * Gets the form of a menu bot.\n * @param calc The calculation context to use.\n * @param bot The bot.\n */\nexport function getMenuBotHoverStyle(\n    calc: BotCalculationContext,\n    bot: Bot\n): MenuBotResolvedHoverStyle {\n    let shape: MenuBotHoverStyle = calculateBotValue(\n        calc,\n        bot,\n        'auxMenuItemHoverMode'\n    );\n    if (shape === 'hover' || shape === 'none') {\n        return shape;\n    } else {\n        const onClick = calculateBotValue(calc, bot, 'onClick');\n        return hasValue(onClick) ? 'hover' : 'none';\n    }\n}\n\n/**\n * Gets the sub-shape of the bot.\n * @param calc The calculation context to use.\n * @param bot The bot.\n */\nexport function getBotSubShape(\n    calc: BotCalculationContext,\n    bot: Bot\n): BotSubShape {\n    const shape: BotSubShape = calculateBotValue(calc, bot, 'auxFormSubtype');\n    if (shape === 'gltf' || shape === 'html' || shape === 'src') {\n        return shape;\n    }\n    return null;\n}\n\n/**\n * Gets the anchor position for the bot's label.\n * @param calc The calculation context to use.\n * @param bot The bot.\n */\nexport function getBotLabelAnchor(\n    calc: BotCalculationContext,\n    bot: Bot\n): BotLabelAnchor {\n    return getBotTagAnchor(calc, bot, 'auxLabelPosition');\n}\n\nexport function getBotTagAnchor(\n    calc: BotCalculationContext,\n    bot: Bot,\n    tag: string\n): BotLabelAnchor {\n    const anchor: BotLabelAnchor = calculateBotValue(calc, bot, tag);\n    if (\n        anchor === 'back' ||\n        anchor === 'floating' ||\n        anchor === 'front' ||\n        anchor === 'left' ||\n        anchor === 'right' ||\n        anchor === 'top'\n    ) {\n        return anchor;\n    }\n    return DEFAULT_LABEL_ANCHOR;\n}\n\n/**\n * Gets the text alignment for the bot's label.\n * @param calc The calculation context.\n * @param bot The bot.\n */\nexport function getBotLabelAlignment(\n    calc: BotCalculationContext,\n    bot: Bot\n): BotLabelAlignment {\n    const anchor: BotLabelAlignment = calculateBotValue(\n        calc,\n        bot,\n        'auxLabelAlignment'\n    );\n    if (anchor === 'center' || anchor === 'left' || anchor === 'right') {\n        return anchor;\n    }\n    return DEFAULT_LABEL_ALIGNMENT;\n}\n\n/**\n * Gets the amount of padding that should be used to auto-sized labels.\n * @param calc The calculation context.\n * @param bot The bot.\n */\nexport function getBotLabelPadding(\n    calc: BotCalculationContext,\n    bot: Bot\n): BotLabelPadding {\n    const padding = calculateNumericalTagValue(calc, bot, 'auxLabelPadding', 0);\n    const x = calculateNumericalTagValue(calc, bot, 'auxLabelPaddingX', 0);\n    const y = calculateNumericalTagValue(calc, bot, 'auxLabelPaddingY', 0);\n\n    const horizontal = padding + x;\n    const vertical = padding + y;\n\n    return {\n        horizontal: isIrrational(horizontal) ? 0 : horizontal,\n        vertical: isIrrational(vertical) ? 0 : vertical,\n    };\n}\n\n/**\n * Determines if the given value is NaN, or +/- infinity.\n * @param val\n */\nfunction isIrrational(val: number): boolean {\n    return isNaN(val) || val === Infinity || val === -Infinity;\n}\n\n/**\n * Gets the text alignment for the bot's label.\n * @param calc The calculation context.\n * @param bot The bot.\n */\nexport function getBotScaleMode(\n    calc: BotCalculationContext,\n    bot: Bot\n): BotScaleMode {\n    const anchor: BotScaleMode = calculateBotValue(calc, bot, 'auxScaleMode');\n    if (anchor === 'fit' || anchor === 'absolute') {\n        return anchor;\n    }\n    return DEFAULT_SCALE_MODE;\n}\n\n/**\n * Gets the orientation mode for the given bot.\n * @param calc The calculation context.\n * @param bot The bot.\n */\nexport function getBotOrientationMode(\n    calc: BotCalculationContext,\n    bot: Bot\n): BotOrientationMode {\n    const mode = <BotOrientationMode>(\n        calculateStringTagValue(\n            calc,\n            bot,\n            'auxOrientationMode',\n            DEFAULT_ORIENTATION_MODE\n        )\n    );\n    if (\n        mode === 'absolute' ||\n        mode === 'billboard' ||\n        mode === 'billboardTop' ||\n        mode === 'billboardFront'\n    ) {\n        return mode;\n    }\n    return DEFAULT_ORIENTATION_MODE;\n}\n\nconst possibleAnchorPoints = new Set([\n    'center',\n    'front',\n    'back',\n    'bottom',\n    'top',\n    'left',\n    'right',\n] as const);\n\n/**\n * Gets the anchor point for the given bot.\n * @param calc The calculation context.\n * @param bot The bot.\n */\nexport function getBotAnchorPoint(\n    calc: BotCalculationContext,\n    bot: Bot\n): BotAnchorPoint {\n    const mode = <BotAnchorPoint>calculateBotValue(calc, bot, 'auxAnchorPoint');\n    return calculateAnchorPoint(mode);\n}\n\n/**\n * Ensures that the given bot anchor point value is valid by converting the given value to a valid anchor point value.\n * @param value The value.\n */\nexport function calculateAnchorPoint(value: BotAnchorPoint) {\n    if (Array.isArray(value)) {\n        if (value.length >= 3 && value.every((v) => typeof v === 'number')) {\n            return value;\n        }\n    } else if (possibleAnchorPoints.has(value as any)) {\n        return value;\n    }\n    return DEFAULT_ANCHOR_POINT;\n}\n\n/**\n * Calculates the 3D offset of the anchor point.\n * @param point The anchor point.\n */\nexport function calculateAnchorPointOffset(point: BotAnchorPoint) {\n    if (typeof point === 'string') {\n        let offset = {\n            x: 0,\n            y: 0,\n            z: 0,\n        };\n        if (point === 'center') {\n            offset.z = 0;\n        } else if (point === 'top') {\n            offset.z = -0.5;\n        } else if (point === 'bottom') {\n            offset.z = 0.5;\n        } else if (point === 'front') {\n            offset.y = -0.5;\n        } else if (point === 'back') {\n            offset.y = 0.5;\n        } else if (point === 'left') {\n            offset.x = 0.5;\n        } else if (point === 'right') {\n            offset.x = -0.5;\n        } else {\n            offset.z = 0.5;\n        }\n\n        return offset;\n    } else {\n        const [x, y, z] = point;\n        return {\n            x: -x,\n            y: -y,\n            z: -z,\n        };\n    }\n}\n\n/**\n * Gets the anchor point offset for the bot in AUX coordinates.\n * @param calc The calculation context.\n * @param bot The bot.\n */\nexport function getAnchorPointOffset(\n    calc: BotCalculationContext,\n    bot: Bot\n): {\n    x: number;\n    y: number;\n    z: number;\n} {\n    const point = getBotAnchorPoint(calc, bot);\n    return calculateAnchorPointOffset(point);\n}\n\nconst possibleMeetPortalAnchorPoints = new Set([\n    'fullscreen',\n    'top',\n    'topRight',\n    'topLeft',\n    'bottom',\n    'bottomRight',\n    'bottomLeft',\n    'left',\n    'right',\n] as const);\n\nexport function getPortalAnchorPoint(\n    calc: BotCalculationContext,\n    bot: Bot,\n    tag: string,\n    defaultValue: MeetPortalAnchorPoint\n): MeetPortalAnchorPoint {\n    const mode = <MeetPortalAnchorPoint>calculateBotValue(calc, bot, tag);\n\n    if (Array.isArray(mode)) {\n        if (mode.every((v) => ['string', 'number'].indexOf(typeof v) >= 0)) {\n            let result = mode.slice(0, 4);\n            while (result.length < 4) {\n                result.push(0);\n            }\n            return result as MeetPortalAnchorPoint;\n        }\n    } else if (possibleMeetPortalAnchorPoints.has(mode)) {\n        return mode;\n    }\n    return defaultValue;\n}\n\n/**\n * Gets the meet portal anchor point for the given bot.\n * @param calc The calculation context.\n * @param bot The bot.\n */\nexport function getBotMeetPortalAnchorPoint(\n    calc: BotCalculationContext,\n    bot: Bot\n): MeetPortalAnchorPoint {\n    return getPortalAnchorPoint(\n        calc,\n        bot,\n        'auxMeetPortalAnchorPoint',\n        DEFAULT_MEET_PORTAL_ANCHOR_POINT\n    );\n}\n\n/**\n * Gets the tag portal anchor point for the given bot.\n * @param calc The calculation context.\n * @param bot The bot.\n */\nexport function getBotTagPortalAnchorPoint(\n    calc: BotCalculationContext,\n    bot: Bot\n): MeetPortalAnchorPoint {\n    return getPortalAnchorPoint(\n        calc,\n        bot,\n        'auxTagPortalAnchorPoint',\n        DEFAULT_TAG_PORTAL_ANCHOR_POINT\n    );\n}\n\n/**\n * Gets the bot portal anchor point for the given bot.\n * @param calc The calculation context.\n * @param bot The bot.\n */\nexport function getBotPortalAnchorPoint(\n    calc: BotCalculationContext,\n    bot: Bot\n): MeetPortalAnchorPoint {\n    return getPortalAnchorPoint(\n        calc,\n        bot,\n        'auxBotPortalAnchorPoint',\n        DEFAULT_BOT_PORTAL_ANCHOR_POINT\n    );\n}\n\n/**\n * Gets the camera type for the given portal bot.\n * @param calc The calculation context.\n * @param bot The bot.\n */\nexport function getCameraType(\n    calc: BotCalculationContext,\n    bot: Bot\n): PortalCameraType {\n    const mode = <PortalCameraType>(\n        calculateBotValue(calc, bot, 'auxPortalCameraType')\n    );\n\n    if (mode === 'orthographic' || mode === 'perspective') {\n        return mode;\n    }\n    return null;\n}\n\n/**\n * Gets the anchor point offset for the bot in AUX coordinates.\n * @param calc The calculation context.\n * @param bot The bot.\n */\nexport function getBotMeetPortalAnchorPointOffset(\n    calc: BotCalculationContext,\n    bot: Bot\n): {\n    top?: string;\n    right?: string;\n    bottom?: string;\n    left?: string;\n    height?: string;\n    width?: string;\n    'min-height'?: string;\n    'min-width'?: string;\n} {\n    const point = getBotMeetPortalAnchorPoint(calc, bot);\n    return calculateMeetPortalAnchorPointOffset(point);\n}\n\nconst botCursors = [\n    'auto',\n    'default',\n    'none',\n    'context-menu',\n    'help',\n    'pointer',\n    'progress',\n    'wait',\n    'cell',\n    'crosshair',\n    'text',\n    'vertical-text',\n    'alias',\n    'copy',\n    'move',\n    'no-drop',\n    'not-allowed',\n    'grab',\n    'grabbing',\n    'all-scroll',\n    'col-resize',\n    'row-resize',\n    'n-resize',\n    'e-resize',\n    's-resize',\n    'w-resize',\n    'ne-resize',\n    'nw-resize',\n    'se-resize',\n    'sw-resize',\n    'ew-resize',\n    'ns-resize',\n    'nesw-resize',\n    'nwse-resize',\n    'zoom-in',\n    'zoom-out',\n];\n\n/**\n * Gets the CSS that should be used for the given cursor value.\n * @param cursor The cursor.\n */\nexport function getCursorCSS(cursor: BotCursorType): string {\n    if (!hasValue(cursor)) {\n        return null;\n    }\n    if (typeof cursor === 'string') {\n        return cursor;\n    } else if (cursor.type === 'link') {\n        return `url(\"${cursor.url}\") ${cursor.x} ${cursor.y}, auto`;\n    }\n}\n\n/**\n * Finds and returns the bot cursor type that matches the given value.\n * @param value The value.\n */\nfunction calculateBotCursor(\n    calc: BotCalculationContext,\n    bot: Bot,\n    tag: string\n): BotCursorType {\n    const value = calculateStringTagValue(calc, bot, tag, null);\n\n    if (!hasValue(value)) {\n        return null;\n    }\n\n    if (botCursors.indexOf(value) >= 0) {\n        return value as BotCursorType;\n    }\n\n    try {\n        // try parsing the value as a URL\n        const url = new URL(value);\n        return {\n            type: 'link',\n            url: value,\n            x: calculateNumericalTagValue(calc, bot, tag + 'HotspotX', 0),\n            y: calculateNumericalTagValue(calc, bot, tag + 'HotspotY', 0),\n        };\n    } catch {}\n\n    return DEFAULT_BOT_CURSOR;\n}\n\n/**\n * Gets the cursor that has been configured on the given bot.\n * Returns null if the bot does not have a valid string value.\n * @param calc The calculation context.\n * @param bot The bot.\n */\nexport function getBotCursor(\n    calc: BotCalculationContext,\n    bot: Bot\n): BotCursorType {\n    return calculateBotCursor(calc, bot, 'auxCursor');\n}\n\n/**\n * Gets the cursor that has been configured as the portal cursor for the given bot.\n * Returns null if the bot does not have a valid string value.\n * @param calc The calculation context.\n * @param bot The bot.\n */\nexport function getPortalCursor(\n    calc: BotCalculationContext,\n    bot: Bot\n): BotCursorType {\n    return calculateBotCursor(calc, bot, 'auxPortalCursor');\n}\n\n/**\n * Gets the anchor point offset for the bot in AUX coordinates.\n * @param calc The calculation context.\n * @param bot The bot.\n */\nexport function getBotTagPortalAnchorPointOffset(\n    calc: BotCalculationContext,\n    bot: Bot\n): {\n    top?: string;\n    right?: string;\n    bottom?: string;\n    left?: string;\n    height?: string;\n    width?: string;\n    'min-height'?: string;\n    'min-width'?: string;\n} {\n    const point = getBotTagPortalAnchorPoint(calc, bot);\n    return calculateMeetPortalAnchorPointOffset(point);\n}\n\n/**\n * Calculates the CSS style for the given meet portal anchor point.\n */\nexport function calculateMeetPortalAnchorPointOffset(\n    anchorPoint: MeetPortalAnchorPoint\n): {\n    top?: string;\n    right?: string;\n    bottom?: string;\n    left?: string;\n    height?: string;\n    width?: string;\n    'min-height'?: string;\n    'min-width'?: string;\n} {\n    if (typeof anchorPoint === 'string') {\n        if (anchorPoint === 'top') {\n            return {\n                top: '0px',\n                height: '50%',\n                'min-height': '250px',\n                left: '0px',\n                right: '0px',\n            };\n        } else if (anchorPoint === 'topRight') {\n            return {\n                top: '25px',\n                height: '25%',\n                'min-height': '250px',\n                width: '25%',\n                'min-width': '250px',\n                right: '25px',\n            };\n        } else if (anchorPoint === 'topLeft') {\n            return {\n                top: '25px',\n                height: '25%',\n                'min-height': '250px',\n                width: '25%',\n                'min-width': '250px',\n                left: '25px',\n            };\n        } else if (anchorPoint === 'bottom') {\n            return {\n                bottom: '0px',\n                height: '50%',\n                'min-height': '250px',\n                left: '0px',\n                right: '0px',\n            };\n        } else if (anchorPoint === 'bottomRight') {\n            return {\n                bottom: '25px',\n                height: '25%',\n                'min-height': '250px',\n                width: '25%',\n                'min-width': '250px',\n                right: '25px',\n            };\n        } else if (anchorPoint === 'bottomLeft') {\n            return {\n                bottom: '25px',\n                height: '25%',\n                'min-height': '250px',\n                width: '25%',\n                'min-width': '250px',\n                left: '25px',\n            };\n        } else if (anchorPoint === 'left') {\n            return {\n                bottom: '0px',\n                height: '100%',\n                'min-height': '250px',\n                width: '50%',\n                'min-width': '250px',\n                left: '0px',\n            };\n        } else if (anchorPoint === 'right') {\n            return {\n                bottom: '0px',\n                height: '100%',\n                'min-height': '250px',\n                width: '50%',\n                'min-width': '250px',\n                right: '0px',\n            };\n        } else {\n            return {\n                top: '0px',\n                right: '0px',\n                bottom: '0px',\n                left: '0px',\n            };\n        }\n    } else {\n        const [top, right, bottom, left] = anchorPoint;\n        return {\n            top: stringOrPx(top),\n            right: stringOrPx(right),\n            bottom: stringOrPx(bottom),\n            left: stringOrPx(left),\n        };\n    }\n}\n\nfunction stringOrPx(value: string | number): string {\n    if (typeof value === 'string') {\n        return value;\n    }\n    return `${value}px`;\n}\n\nconst lodTags = new Set([\n    'onMaxLODEnter',\n    'onMaxLODExit',\n    'onMinLODEnter',\n    'onMinLODExit',\n    'auxMaxLODThreshold',\n    'auxMinLODThreshold',\n] as const);\n\n/**\n * Gets whether the bot has a tag to enable LODs.\n * @param calc The calculation context.\n * @param bot The bot.\n */\nexport function botHasLOD(calc: BotCalculationContext, bot: Bot): boolean {\n    for (let tag of lodTags.values()) {\n        const val = calculateBotValue(calc, bot, tag);\n        if (isScript(val)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Calcualtes the LOD that a bot should be in based on the virtual distance, minimum threshold, and maximum threshold.\n * @param virtualDistance The percentage of the screen that the bot takes up.\n * @param minThreshold The minimum LOD threshold.\n * @param maxThreshold The maximum LOD threshold.\n */\nexport function calculateBotLOD(\n    virtualDistance: number,\n    minThreshold: number,\n    maxThreshold: number\n): BotLOD {\n    return virtualDistance < minThreshold\n        ? 'min'\n        : virtualDistance > maxThreshold\n        ? 'max'\n        : 'normal';\n}\n\n/**\n * Calculates the portal camera controls mode that the given bot has set.\n * @param calc The calculation context.\n * @param bot The portal config bot.\n */\nexport function calculatePortalCameraControlsMode(\n    calc: BotCalculationContext,\n    bot: Bot\n): PortalCameraControlsMode {\n    const mode = <PortalCameraControlsMode>(\n        calculateBotValue(calc, bot, 'auxPortalCameraControls')\n    );\n    if (mode === 'player' || mode === false) {\n        return mode;\n    }\n    return DEFAULT_PORTAL_CAMERA_CONTROLS_MODE;\n}\n\n/**\n * Calculates the label font size that the given bot has set.\n * @param calc The calculation context.\n * @param bot The bot.\n */\nexport function calculateLabelFontSize(\n    calc: BotCalculationContext,\n    bot: Bot\n): BotLabelFontSize {\n    const mode = <BotLabelFontSize>(\n        calculateBotValue(calc, bot, 'auxLabelFontSize')\n    );\n    if (mode === 'auto') {\n        return mode;\n    } else if (typeof mode === 'number') {\n        if (mode < 0.001) {\n            return 0.001;\n        }\n        return mode;\n    }\n    return DEFAULT_LABEL_FONT_SIZE;\n}\n\n/**\n * Calculates the label word wrapping mode that the given bot has set.\n * @param calc The calculation context.\n * @param bot The bot.\n */\nexport function calculateLabelWordWrapMode(\n    calc: BotCalculationContext,\n    bot: Bot\n): BotLabelWordWrap {\n    const mode = <BotLabelWordWrap>(\n        calculateBotValue(calc, bot, 'auxLabelWordWrapMode')\n    );\n    if (\n        mode === 'breakCharacters' ||\n        mode === 'breakWords' ||\n        mode === 'none'\n    ) {\n        return mode;\n    }\n    return DEFAULT_LABEL_WORD_WRAP_MODE;\n}\n\n/**\n * Determines if the given bot is a config bot for the given dimension.\n * @param calc The calculation context.\n * @param bot The bot to check.\n * @param dimension The dimension to check if the bot is the config of.\n */\nexport function isConfigForContext(\n    calc: BotCalculationContext,\n    bot: Bot,\n    dimension: string\n) {\n    const contexts = getBotConfigDimensions(calc, bot);\n    return contexts.indexOf(dimension) >= 0;\n}\n\n/**\n * Gets whether the dimension(s) that the given bot represents are locked.\n * Uses at the auxPortalLocked tag to determine whether it is locked.\n * @param calc The calculation context.\n * @param bot The bot.\n */\nexport function isDimensionLocked(\n    calc: BotCalculationContext,\n    bot: Bot\n): boolean {\n    return calculateBooleanTagValue(calc, bot, 'auxPortalLocked', false);\n}\n\n/**\n * Gets the list of contexts that the given bot is a config bot for.\n * @param calc The calculation context.\n * @param bot The bot that represents the dimension.\n */\nexport function getBotConfigDimensions(\n    calc: BotCalculationContext,\n    bot: Bot\n): string[] {\n    const result = calculateBotValue(calc, bot, 'auxDimensionConfig');\n    return parseBotConfigDimensions(result);\n}\n\n/**\n * Parses a list of dimension names from the given value.\n * @param value The value to parse.\n */\nexport function parseBotConfigDimensions(value: any): string[] {\n    if (typeof value === 'string' && hasValue(value)) {\n        return [value];\n    } else if (typeof value === 'number' && hasValue(value)) {\n        return [value.toString()];\n    } else if (typeof value === 'boolean' && hasValue(value)) {\n        return [value.toString()];\n    } else if (Array.isArray(value)) {\n        return value;\n    }\n    return [];\n}\n\n/**\n * Gets a value from the given dimension bot.\n * @param calc The calculation context.\n * @param dimensionBot The bot that represents the dimension.\n * @param name The name of the value to get.\n */\nexport function getDimensionValue(\n    calc: BotCalculationContext,\n    dimensionBot: Bot,\n    name: string\n): any {\n    return calculateBotValue(calc, dimensionBot, `auxPortal${name}`);\n}\n\n/**\n * Gets the ID of the bot that the given bot should be transformed by.\n * @param calc The bot calculation context.\n * @param bot The bot to check.\n */\nexport function getBotTransformer(\n    calc: BotCalculationContext,\n    bot: Bot\n): string {\n    const ids = calculateBotIds(bot, 'transformer');\n    if (ids) {\n        return ids[0];\n    }\n    return null;\n}\n\n/**\n * Gets whether the given bot is movable.\n * @param calc The calculation context.\n * @param bot The bot to check.\n */\nexport function isBotMovable(calc: BotCalculationContext, bot: Bot): boolean {\n    // checks if bot is movable, but we should also allow it if it is pickupable so we can drag it into miniGridPortal if movable is false\n    return calculateBooleanTagValue(calc, bot, 'auxDraggable', true);\n}\n\n/**\n * Gets whether the given bot is listening for shouts or whispers.\n * @param calc The calculation context.\n * @param bot The bot to check.\n */\nexport function isBotListening(calc: BotCalculationContext, bot: Bot): boolean {\n    return calculateBooleanTagValue(calc, bot, 'auxListening', true);\n}\n\n/**\n * Gets whether the given bot's dimension is movable.\n * @param calc The calculation context.\n * @param bot The bot to check.\n */\nexport function isDimensionMovable(\n    calc: BotCalculationContext,\n    bot: Bot\n): boolean {\n    return calculateBooleanTagValue(\n        calc,\n        bot,\n        'auxDimensionSurfaceMovable',\n        true\n    );\n}\n\n/**\n * Gets the position that the dimension should be at using the given bot.\n * @param calc The calculation context to use.\n * @param bot The bot that represents the dimension.\n */\nexport function getDimensionPosition(\n    calc: BotCalculationContext,\n    bot: Bot\n): { x: number; y: number; z: number } {\n    return {\n        x: calculateNumericalTagValue(calc, bot, `auxDimensionX`, 0),\n        y: calculateNumericalTagValue(calc, bot, `auxDimensionY`, 0),\n        z: calculateNumericalTagValue(calc, bot, `auxDimensionZ`, 0),\n    };\n}\n\n/**\n * Gets the rotation that the dimension should be at using the given bot.\n * @param calc The calculation context to use.\n * @param bot The bot that represents the dimension.\n */\nexport function getDimensionRotation(\n    calc: BotCalculationContext,\n    bot: Bot\n): { x: number; y: number; z: number } {\n    return {\n        x: calculateNumericalTagValue(calc, bot, `auxDimensionOrientationX`, 0),\n        y: calculateNumericalTagValue(calc, bot, `auxDimensionOrientationY`, 0),\n        z: calculateNumericalTagValue(calc, bot, `auxDimensionOrientationZ`, 0),\n    };\n}\n\n/**\n * Gets whether the dimension is minimized.\n * @param calc The calculation context to use.\n * @param bot The bot that represents the dimension.\n */\nexport function getDimensionMinimized(\n    calc: BotCalculationContext,\n    bot: Bot\n): boolean {\n    return getDimensionValue(calc, bot, 'SurfaceMinimized');\n}\n\n/**\n * Gets the color of the dimension.\n * @param calc The calculation context to use.\n * @param bot The bot that represents the dimension.\n */\nexport function getDimensionColor(\n    calc: BotCalculationContext,\n    bot: Bot\n): string {\n    return getDimensionValue(calc, bot, 'Color');\n}\n\n/**\n * Gets the size of the dimension.\n * @param calc The calculation context to use.\n * @param bot The bot that represents the dimension.\n */\nexport function getDimensionSize(\n    calc: BotCalculationContext,\n    bot: Bot\n): number {\n    if (getDimensionVisualizeMode(calc, bot) === 'surface') {\n        return calculateNumericalTagValue(\n            calc,\n            bot,\n            `auxDimensionSurfaceSize`,\n            DEFAULT_WORKSPACE_SIZE\n        );\n    }\n    return 0;\n}\n\n/**\n * Gets the auxDimensionVisualize mode from the given bot.\n * @param calc The calculation context.\n * @param bot The bot.\n */\nexport function getDimensionVisualizeMode(\n    calc: BotCalculationContext,\n    bot: Bot\n): DimensionVisualizeMode {\n    const val = calculateBotValue(calc, bot, 'auxDimensionVisualize');\n    if (typeof val === 'boolean') {\n        return val;\n    }\n    if (val === 'surface') {\n        return val;\n    } else {\n        return false;\n    }\n}\n\n/**\n * Gets the grid of the dimension.\n * @param calc The calculation context to use.\n * @param bot The bot that represents the dimension.\n */\nexport function getBuilderDimensionGrid(\n    calc: BotCalculationContext,\n    bot: Bot\n): { [key: string]: number } {\n    const tags = tagsOnBot(bot);\n    const gridTags = tags.filter(\n        (t) =>\n            t.indexOf('auxDimensionConfig.surface.grid.') === 0 &&\n            t.indexOf(':') > 0\n    );\n\n    let val: { [key: string]: number } = {};\n    for (let tag of gridTags) {\n        val[tag.substr('auxDimensionConfig.surface.grid.'.length)] =\n            calculateNumericalTagValue(calc, bot, tag, undefined);\n    }\n\n    return val;\n}\n\n/**\n * Gets the height of the specified grid on the dimension.\n * @param calc The calculation context to use.\n * @param bot The bot that represents the dimension.\n * @param key The key for the grid position to lookup in the dimension grid.\n */\nexport function getDimensionGridHeight(\n    calc: BotCalculationContext,\n    bot: Bot,\n    key: string\n): number {\n    let contextGrid = getBuilderDimensionGrid(calc, bot);\n    if (contextGrid && contextGrid[key]) {\n        if (contextGrid[key]) {\n            return contextGrid[key];\n        }\n    }\n\n    return DEFAULT_WORKSPACE_HEIGHT;\n}\n\n/**\n * Gets the grid scale of the dimension.\n * @param calc The calculation context to use.\n * @param bot The bot that represents the dimension.\n */\nexport function getDimensionGridScale(\n    calc: BotCalculationContext,\n    bot: Bot\n): number {\n    return getDimensionValue(calc, bot, 'GridScale');\n}\n\n/**\n * Gets the scale of the dimension.\n * @param calc The calculation context to use.\n * @param bot The bot that represents the dimension.\n */\nexport function getDimensionScale(\n    calc: BotCalculationContext,\n    bot: Bot\n): number {\n    return (\n        getDimensionValue(calc, bot, 'SurfaceScale') || DEFAULT_WORKSPACE_SCALE\n    );\n}\n\n/**\n * Gets the default height of the dimension.\n * @param calc The calculation context to use.\n * @param bot The bot that represents the dimension.\n */\nexport function getDimensionDefaultHeight(\n    calc: BotCalculationContext,\n    bot: Bot\n): number {\n    return getDimensionValue(calc, bot, 'SurfaceDefaultHeight');\n}\n\n/**\n * Filters the given list of objects to those matching the given workspace ID and grid position.\n * The returned list is in the order of their indexes.\n * @param calc The bot calculation context to use.\n * @param dimension The ID of the dimension that the objects need to be on.\n * @param position The position that the objects need to be at.\n */\nexport function objectsAtDimensionGridPosition(\n    calc: BotCalculationContext,\n    dimension: string,\n    position: { x: number; y: number }\n): Bot[] {\n    return cacheFunction(\n        calc,\n        'objectsAtDimensionGridPosition',\n        () => {\n            let botsAtPosition = [] as Bot[];\n            for (let bot of calc.objects) {\n                if (!isBotInDimension(calc, bot, dimension)) {\n                    continue;\n                }\n\n                const botPos = getBotPosition(calc, bot, dimension);\n                if (position.x === botPos.x && position.y === botPos.y) {\n                    botsAtPosition.push(bot);\n                }\n            }\n            return <Bot[]>sortBy(\n                botsAtPosition,\n                (o) => getBotIndex(calc, o, dimension),\n                (o) => o.id\n            );\n        },\n        dimension,\n        position.x,\n        position.y\n    );\n}\n\n/**\n * Calculates whether the given bot should be stacked onto another bot or if\n * it should be combined with another bot.\n * @param calc The bot calculation context.\n * @param dimension The dimension.\n * @param gridPosition The grid position that the bot is being dragged to.\n * @param bot The bot that is being dragged.\n */\nexport function getDropBotFromGridPosition(\n    calc: BotCalculationContext,\n    dimension: string,\n    gridPosition: { x: number; y: number },\n    ...bots: (Bot | BotTags)[]\n) {\n    const objs = differenceBy(\n        objectsAtDimensionGridPosition(calc, dimension, gridPosition),\n        bots,\n        (f) => f.id\n    );\n\n    return {\n        other: objs[0],\n    };\n}\n\n/**\n * Filters the given list of objects to those that are assigned to the given workspace ID.\n * @param objects The objects to filter.\n * @param workspaceId The ID of the workspace that the objects need to be on,\n */\nexport function objectsAtWorkspace(objects: Bot[], workspaceId: string) {\n    return objects.filter((o) => {\n        return o.tags._workspace === workspaceId;\n    });\n}\n\n/**\n * Duplicates the given bot and returns a new bot with a new ID but the same tags.\n * The bot will be exactly the same as the previous except for 3 things.\n * First, it will have a different ID.\n * Second, it will never be marked as destroyed.\n * Third, it will not have any well known tags. (see isTagWellKnown())\n * @param calc The bot calculation context.\n * @param bot The bot to duplicate.\n * @param data The optional data that should override the existing bot data.\n */\nexport function duplicateBot(\n    calc: BotCalculationContext,\n    bot: Bot,\n    data?: PartialBot\n): Bot {\n    let copy = cloneDeep(bot);\n    const tags = tagsOnBot(copy);\n    const tagsToRemove = filterWellKnownAndDimensionTags(calc, tags);\n    tagsToRemove.forEach((t) => {\n        delete copy.tags[t];\n    });\n\n    let newBot = merge(copy, data || {});\n    newBot.id = uuid();\n\n    return <Bot>cleanBot(newBot);\n}\n\n/**\n * Filters the given list of tags by whether they are well known or used in a dimension.\n * @param calc The bot calculation context.\n * @param tags The list of tags to filter.\n */\nexport function filterWellKnownAndDimensionTags(\n    calc: BotCalculationContext,\n    tags: string[]\n) {\n    const contextsToRemove = getDimensions(calc);\n    const tagsToRemove = tags.filter((t) =>\n        isWellKnownOrDimension(t, contextsToRemove)\n    );\n    return tagsToRemove;\n}\n\n/**\n * Gets the list of contexts that the given calculation dimension contains.\n * @param calc The bot calculation context.\n */\nexport function getDimensions(calc: BotCalculationContext) {\n    return union(...calc.objects.map((o) => getBotConfigDimensions(calc, o)));\n}\n\n/**\n * Determines if the given tag is well known or in one of the given dimensions.\n * @param tag The tag to check.\n * @param dimensions The dimensions to check the tag against.\n */\nexport function isWellKnownOrDimension(tag: string, dimensions: string[]): any {\n    return isTagWellKnown(tag) || dimensions.some((c) => tag.indexOf(c) === 0);\n}\n\n/**\n * Determines if the given value is some bot tags.\n * @param value The value to test.\n */\nexport function isBotTags(value: any): value is BotTags {\n    return !isBot(value);\n}\n\nexport function simulationIdToString(id: SimulationIdParseSuccess): string {\n    if (id.host) {\n        let str = id.host;\n        if (id.channel) {\n            str += `?inst=${encodeURIComponent(id.channel)}`;\n        }\n        return str;\n    }\n\n    return id.channel;\n}\n\nexport function parseSimulationId(id: string): SimulationIdParseSuccess {\n    try {\n        let uri = new URL(id);\n        const channel =\n            uri.searchParams.get('inst') ?? uri.searchParams.get('server');\n        if (channel) {\n            return {\n                success: true,\n                host: `${uri.protocol}//${uri.host}`,\n                channel,\n            };\n        } else {\n            return {\n                success: true,\n                host: `${uri.protocol}//${uri.host}`,\n            };\n        }\n    } catch (ex) {\n        return {\n            success: true,\n            channel: id,\n        };\n    }\n}\n\n/**\n * Normalizes the given URL so that it will load the AUX bot instead of the web application.\n * @param url The URL.\n */\nexport function normalizeAUXBotURL(url: string): string {\n    const parsed = new URL(url);\n\n    if (\n        parsed.pathname.indexOf('.aux') !==\n        parsed.pathname.length - '.aux'.length\n    ) {\n        parsed.pathname = `${parsed.pathname}.aux`;\n        return parsed.href;\n    }\n\n    return url;\n}\n\n/**\n * Calculates the value of the given tag on the given bot. If the result is not a bot, then the given default value\n * is returned.\n * @param context The context.\n * @param bot The bot.\n * @param tag The tag.\n * @param defaultValue The default value to use if the tag doesn't exist or the result is not a bot.\n */\nexport function calculateBotValueAsBot(\n    context: BotCalculationContext,\n    bot: Bot,\n    tag: string,\n    defaultValue: Bot\n): Bot {\n    if (bot.tags[tag]) {\n        const result = calculateBotValue(context, bot, tag);\n        if (isBot(result)) {\n            return result;\n        }\n    }\n    return defaultValue;\n}\n\n/**\n * Calculates the value of the given tag on the given bot as a list of strings.\n * @param context The calculation context.\n * @param bot The bot.\n * @param tag The tag.\n * @param defaultValue The default value.\n */\nexport function calculateStringListTagValue(\n    context: BotCalculationContext,\n    bot: Bot,\n    tag: string,\n    defaultValue: string[]\n): string[] {\n    let value: any = calculateBotValue(context, bot, tag);\n\n    if (typeof value === 'undefined' || value === null || value === '') {\n        return defaultValue;\n    } else if (!Array.isArray(value)) {\n        value = [value];\n    }\n\n    if (value) {\n        for (let i = 0; i < value.length; i++) {\n            let v = value[i];\n            if (typeof v !== 'undefined' && v !== null) {\n                value[i] = v.toString();\n            }\n        }\n    }\n\n    return value;\n}\n\n/**\n * Calculates the value of the given tag on the given bot. If the result is not a number, then the given default value\n * is returned.\n * @param context The calculation context.\n * @param bot The bot.\n * @param tag The tag.\n * @param defaultValue The default value to use if the tag doesn't exist or the result is not a number.\n */\nexport function calculateNumericalTagValue(\n    context: BotCalculationContext,\n    bot: Bot,\n    tag: string,\n    defaultValue: number\n): number {\n    const result = calculateBotValue(context, bot, tag);\n    if (typeof result === 'number' && result !== null) {\n        return result;\n    }\n    return defaultValue;\n}\n\n/**\n * Calculates the value of the given tag on the given bot. If the result is not a boolean, then the given default value is returned.\n * @param context The context.\n * @param bot The bot.\n * @param tag The tag.\n * @param defaultValue The default value to use.\n */\nexport function calculateBooleanTagValue(\n    context: BotCalculationContext,\n    bot: Bot,\n    tag: string,\n    defaultValue: boolean\n): boolean {\n    const result = calculateBotValue(context, bot, tag);\n    if (typeof result === 'boolean' && result !== null) {\n        return result;\n    } else if (typeof result === 'object' && result instanceof Boolean) {\n        return result.valueOf();\n    }\n    return defaultValue;\n}\n\n/**\n * Calculates the value of the given tag on the given bot. If the result is not a stirng, then the given default value is returned.\n * @param context THe context.\n * @param bot The bot.\n * @param tag The tag.\n * @param defaultValue The default value to use.\n */\nexport function calculateStringTagValue(\n    context: BotCalculationContext,\n    bot: Bot,\n    tag: string,\n    defaultValue: string\n): string {\n    const result = calculateBotValue(context, bot, tag);\n    if (typeof result === 'string' && result !== null) {\n        return result;\n    }\n    return defaultValue;\n}\n\n/**\n * Calcualtes the given of the given tag on the given bot as a bot ID.\n * @param context The context.\n * @param bot The bot.\n * @param tag The tag.\n * @param defaultValue The default value to use.\n */\nexport function calculateBotIdTagValue(\n    bot: Bot,\n    tag: string,\n    defaultValue: string\n): string {\n    const ids = calculateBotIds(bot, tag);\n    if (ids) {\n        return ids[0];\n    }\n    return defaultValue;\n}\n\n/**\n * Calculates the value of the given tag on the given bot as a vector.\n * @param bot The bot.\n * @param tag The tag.\n * @param defaultValue The default value to use.\n */\nexport function calculateBotVectorTagValue(\n    context: BotCalculationContext,\n    bot: Bot,\n    tag: string,\n    defaultValue: Vector2 | Vector3\n): Vector2 | Vector3 {\n    const value = calculateBotValue(context, bot, tag);\n    const result = parseBotVector(value);\n    return result ? result : defaultValue;\n}\n\n/**\n * Calculates the value of the given tag on the given bot as a rotation.\n * @param bot The bot.\n * @param tag The tag.\n * @param defaultValue The default value to use.\n */\nexport function calculateBotRotationTagValue(\n    context: BotCalculationContext,\n    bot: Bot,\n    tag: string,\n    defaultValue: Rotation\n): Rotation {\n    const value = calculateBotValue(context, bot, tag);\n    const result = parseBotRotation(value);\n    return result ? result : defaultValue;\n}\n\n/**\n * Determines if the given bot is able to be destroyed.\n * Defaults to true.\n * @param calc The bot calculation context.\n * @param bot The bot to check.\n */\nexport function isDestroyable(calc: BotCalculationContext, bot: Bot) {\n    return calculateBooleanTagValue(calc, bot, 'auxDestroyable', true);\n}\n\n/**\n * Determines if the given bot is able to be edited by the bot sheet.\n * Defaults to true.\n * @param calc The bot calculation context.\n * @param bot The bot to check.\n */\nexport function isEditable(calc: BotCalculationContext, bot: Bot) {\n    return calculateBooleanTagValue(calc, bot, 'auxEditable', true);\n}\n\n/**\n * Determines if the given bot is trying to load a simulation.\n * @param calc The calculation context.\n * @param bot The bot to check.\n */\nexport function isSimulation(calc: BotCalculationContext, bot: Bot): boolean {\n    return !!getBotChannel(calc, bot);\n}\n\n/**\n * Gets the server tag from the given bot.\n * @param calc The bot calculation context to use.\n * @param bot The bot.\n */\nexport function getBotChannel(calc: BotCalculationContext, bot: Bot): string {\n    return calculateBotValue(calc, bot, 'server');\n}\n\n/**\n * Gets the first bot which is in the aux.channels dimension that has the server tag set to the given ID.\n * @param calc The bot calculation context.\n * @param id The ID to search for.\n */\nexport function getChannelBotById(calc: BotCalculationContext, id: string) {\n    const bots = calc.objects.filter((o) => {\n        return (\n            isBotInDimension(calc, o, 'aux.channels') &&\n            calculateBotValue(calc, o, 'server') === id\n        );\n    });\n\n    if (bots.length > 0) {\n        return bots[0];\n    } else {\n        return null;\n    }\n}\n\n/**\n * Returns wether or not the given bot resides in the given dimension id.\n * @param context The bot calculation context to run formulas with.\n * @param bot The bot.\n * @param dimensionId The id of the dimension that we are asking if the bot is in.\n */\nexport function isBotInDimension(\n    context: BotCalculationContext,\n    bot: Bot,\n    dimensionId: string\n): boolean {\n    if (!dimensionId) return false;\n\n    let dimensionValue = calculateBooleanTagValue(\n        context,\n        bot,\n        dimensionId.valueOf(),\n        false\n    ); //calculateBotValue(context, bot, dimensionId.valueOf());\n\n    return dimensionValue;\n}\n\n/**\n * Gets the tag that is used to set the dimension for the given portal type.\n * @param portal The portal type.\n */\nexport function getPortalTag(portal: PortalType) {\n    if (portal.endsWith('Portal')) {\n        return portal;\n    }\n    return `${portal}Portal`;\n}\n\n/**\n * Gets the ID of the bot that should be used to configure the given portal.\n * @param context The context.\n * @param bot The bot that is defining the portal.\n * @param portal The portal.\n */\nexport function getPortalConfigBotID(\n    context: BotCalculationContext,\n    bot: Bot,\n    portal: PortalType\n) {\n    const tag = `${getPortalTag(portal)}ConfigBot`;\n    return calculateStringTagValue(context, bot, tag, null);\n}\n\n/**\n * Gets the sort order that the given bot should appear in the given dimension.\n * @param context The bot calculation context.\n * @param bot The bot.\n * @param dimensionId The ID of the dimension that we're getting the sort order for.\n */\nexport function botDimensionSortOrder(\n    context: BotCalculationContext,\n    bot: Bot,\n    dimensionId: string\n): number | string {\n    if (!dimensionId) return NaN;\n\n    const dimensionValue = calculateBotValue(\n        context,\n        bot,\n        `${dimensionId}SortOrder`\n    );\n    if (typeof dimensionValue === 'string') {\n        return dimensionValue;\n    } else if (typeof dimensionValue === 'number') {\n        return dimensionValue;\n    } else {\n        return 0;\n    }\n}\n\nexport function isUserActive(calc: BotCalculationContext, bot: Bot) {\n    return calculateBooleanTagValue(calc, bot, `auxPlayerActive`, false);\n}\n\n/**\n * Formats the given value and returns a string representing it.\n * @param value The value to format.\n */\nexport function formatValue(value: any): string {\n    if (isBotRotation(value)) {\n        const result = parseBotRotation(value);\n        if (result) {\n            return result.toString();\n        } else {\n            return value;\n        }\n    } else if (typeof value === 'object') {\n        if (!value) {\n            return null;\n        } else if (Array.isArray(value)) {\n            return `[${value.map((v) => formatValue(v)).join(',')}]`;\n        } else if (value instanceof Error) {\n            return value.toString();\n        } else if (isBot(value)) {\n            return getShortId(value);\n        } else if (value instanceof Date) {\n            return value.toISOString();\n        } else {\n            return JSON.stringify(value);\n        }\n    } else if (typeof value !== 'undefined' && value !== null) {\n        return value.toString();\n    } else {\n        return value;\n    }\n}\n\n/**\n * Calculates the value of the given formula as if it was on the given bot (object) and tag.\n * @param object The bot that the formula was from.\n * @param tag The tag that the formula was from.\n * @param formula The formula.\n */\nexport function calculateValue(\n    object: Bot,\n    tag: keyof BotTags,\n    formula: string\n): any {\n    if (isNumber(formula)) {\n        return parseNumber(formula);\n    } else if (formula === 'true') {\n        return true;\n    } else if (formula === 'false') {\n        return false;\n    } else {\n        return formula;\n    }\n}\n\n/**\n * Defines a symbol for a property that contains the original object that\n * a value was transformed from.\n */\nexport const ORIGINAL_OBJECT = Symbol('ORIGINAL_OBJECT');\n\n/**\n * Gets the original object that the given object was constructed from.\n * Returns the object if there is no original object.\n * @param obj The object.\n */\nexport function getOriginalObject(obj: any): any {\n    if (typeof obj === 'object' && !!obj && ORIGINAL_OBJECT in obj) {\n        return obj[ORIGINAL_OBJECT];\n    }\n    return obj;\n}\n\nexport function getMaskSpaces(bot: Bot): string[] {\n    if (!bot.masks) {\n        return [];\n    }\n    return Object.keys(bot.masks);\n}\n\n/**\n * Gets the list of spaces that the given tag mask exists in.\n * @param bot The bot.\n * @param tag The tag.\n */\nexport function getTagMaskSpaces(bot: Bot, tag: string): string[] {\n    if (!bot.masks) {\n        return [];\n    }\n    let spaces = [] as string[];\n    for (let space in bot.masks) {\n        if (!bot.masks[space]) {\n            continue;\n        }\n        if (tag in bot.masks[space]) {\n            spaces.push(space);\n        }\n    }\n\n    return spaces;\n}\n\n/**\n * Gets the list of tags that are tag masks on the given bot.\n * @param bot The bot.\n */\nexport function tagMasksOnBot(bot: Bot): string[] {\n    if (!bot.masks) {\n        return [];\n    }\n    let tags = new Set<string>();\n    for (let space in bot.masks) {\n        for (let tag in bot.masks[space]) {\n            tags.add(tag);\n        }\n    }\n\n    return [...tags.values()];\n}\n\n/**\n * Gets the value of the given tag mask in the given space.\n * @param bot The bot.\n * @param space The space that the tag mask is in.\n * @param tag The tag.\n */\nexport function getTagMask(bot: Bot, space: string, tag: string): any {\n    if (!bot.masks) {\n        return undefined;\n    }\n    if (!bot.masks[space]) {\n        return undefined;\n    }\n    return bot.masks[space][tag];\n}\n\n/**\n * Determines whether the given bot has a tag or mask for the given tag.\n * @param bot The bot.\n * @param tag The tag.\n */\nexport function hasTagOrMask(bot: Bot, tag: string): boolean {\n    let hasTag = hasValue(bot.tags[tag]);\n    if (hasTag) {\n        return true;\n    }\n    if (bot.masks) {\n        for (let space in bot.masks) {\n            if (hasValue(bot.masks[space][tag])) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n/**\n * Determines if the given bot has a mask for the given tag.\n * @param bot The bot.\n * @param tag The tag.\n */\nexport function hasMaskForTag(bot: Bot, tag: string): boolean {\n    for (let space in bot.masks) {\n        if (hasValue(bot.masks[space][tag])) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Gets the tag value for the given space.\n * If the space is null, then the tag value is retrieved from the tags.\n * If the space is specified, then the tag value is retrieved from the corresponding tag masks.\n * @param bot The bot.\n * @param tag The tag.\n * @param space The space.\n */\nexport function getTagValueForSpace(bot: Bot, tag: string, space: string): any {\n    if (hasValue(space)) {\n        return bot.masks?.[space]?.[tag];\n    } else {\n        return bot.tags[tag];\n    }\n}\n\n/**\n * Gets the first space that the given tag exists in.\n * If the tag has a value in a tag mask, then the space that the mask exists in is returned.\n * If the tag does not have a value in a tag mask, then null is returned.\n * @param bot The bot.\n * @param tag The tag.\n */\nexport function getSpaceForTag(bot: Bot, tag: string): string {\n    for (let space of TAG_MASK_SPACE_PRIORITIES) {\n        if (hasValue(bot.masks?.[space]?.[tag])) {\n            return space;\n        }\n    }\n    return null;\n}\n\n/**\n * Calculates the bot update that is needed to set the given tag in the given space to the given value.\n * If the given space is null, then the tag will be set in the bot'ss tags.\n * If the given space has a value, then the tag will be set as a tag mask in the given space.\n * @param tag The tag to change.\n * @param value The value to set.\n * @param space The space.\n */\nexport function getUpdateForTagAndSpace(\n    tag: string,\n    value: any,\n    space: string\n): Partial<Bot> {\n    if (hasValue(space)) {\n        return {\n            masks: {\n                [space]: {\n                    [tag]: value,\n                },\n            },\n        };\n    } else {\n        return {\n            tags: {\n                [tag]: value,\n            },\n        };\n    }\n}\n\n/**\n * Parses the given tag to determine if it represents a script or formula.\n * @param tag The tag to parse.\n */\nexport function parseNewTag(tag: string) {\n    const script = parseScript(tag);\n    const formula = parseFormula(tag);\n    const name = script ?? formula ?? tag;\n    return {\n        name,\n        isScript: !!script,\n        isFormula: !!formula,\n    };\n}\n","import { assign } from 'lodash';\nimport { AtomId, Atom, atom } from '@casual-simulation/causal-trees';\nimport { sign, verify, keypair, getHash } from '@casual-simulation/crypto';\nimport stringify from '@casual-simulation/fast-json-stable-stringify';\n\n/**\n * The list of operation types.\n */\nexport enum AuxOpType {\n    Root = 0,\n    Bot = 1,\n    Tag = 2,\n    Value = 3,\n    Delete = 4,\n    Insert = 5,\n    Certificate = 6,\n    Revocation = 7,\n    Signature = 8,\n    TagMask = 9,\n}\n\n/**\n * Defines a union of all the possible op types.\n */\nexport type AuxOp =\n    | BotOp\n    | TagOp\n    | ValueOp\n    | InsertOp\n    | DeleteOp\n    | CertificateOp\n    | SignatureOp\n    | RevocationOp\n    | TagMaskOp;\n\n/**\n * Defines an interface for all the AUX atom values.\n */\nexport interface AuxOpBase {\n    /**\n     * The type of the operation.\n     */\n    type: AuxOpType;\n}\n\n/**\n * Defines an atom value that instructs the system to create a bot.\n */\nexport interface BotOp extends AuxOpBase {\n    type: AuxOpType.Bot;\n\n    /**\n     * Gets the ID of the bot.\n     */\n    id: string;\n}\n\n/**\n * Defines an atom value that instructs the system to create a tag on a bot.\n */\nexport interface TagOp extends AuxOpBase {\n    type: AuxOpType.Tag;\n\n    /**\n     * The name of the tag.\n     */\n    name: string;\n}\n\n/**\n * Defines an atom value that serves as the root for changes to the value of a tag.\n */\nexport interface ValueOp extends AuxOpBase {\n    type: AuxOpType.Value;\n\n    /**\n     * The initial value.\n     */\n    value: any;\n}\n\n/**\n * Defines an atom value that instructs the system to insert a set of text into a tag.\n * When inserting into a ValueOp this acts as inserting text into the value part of a tag.\n * When inserting into a TagOp this acts as inserting text into the name part of a tag.\n */\nexport interface InsertOp extends AuxOpBase {\n    type: AuxOpType.Insert;\n\n    /**\n     * The index that the text should be inserted into.\n     * Note that this index refers to the previous insertion operation and\n     * not the full text string.\n     */\n    index: number;\n\n    /**\n     * The text to insert.\n     */\n    text: string;\n}\n\n/**\n * Defines an atom value that instructs the system to delete an item.\n * If applied onto a bot, the bot will be deleted.\n * If applied to an insert operation, the specified substring will be deleted from that insertion's text.\n */\nexport interface DeleteOp extends AuxOpBase {\n    type: AuxOpType.Delete;\n\n    /**\n     * The start index of the substring to delete.\n     * If not specified the entire parent element will be tombstoned.\n     */\n    start?: number;\n\n    /**\n     * The end index of the substring to delete.\n     */\n    end?: number;\n}\n\n/**\n * Defines an atom value that instructs the system to create a certificate. (See https://en.wikipedia.org/wiki/Public_key_certificate)\n * Certificates create a chain of trust (https://en.wikipedia.org/wiki/Chain_of_trust) that can be used to validate that specific tag values have been created by a particular certificate.\n */\nexport interface CertificateOp extends AuxOpBase {\n    type: AuxOpType.Certificate;\n\n    /**\n     * The keypair that is stored in the certificate.\n     * Stores both the public and private keys in the format specified in\n     * the crypto package.\n     * The public key is unencrypted and available for anyone to use\n     * while the private key is encrypted with a password.\n     */\n    keypair: string;\n\n    /**\n     * The signature that is applied to this certificate.\n     * Must be from the atom's cause.\n     */\n    signature: string;\n}\n\n/**\n * Defines an atom value that represents a signature applied to a value.\n */\nexport interface SignatureOp extends AuxOpBase {\n    type: AuxOpType.Signature;\n\n    /**\n     * The ID of the atom that created this signature was created for.\n     */\n    valueId: AtomId;\n\n    /**\n     * The hash of the atom that this signature was created for.\n     */\n    valueHash: string;\n\n    /**\n     * The signature data that was created by the certificate.\n     */\n    signature: string;\n}\n\n/**\n * Defines an atom value that represents the revocation of a certificate.\n */\nexport interface RevocationOp extends AuxOpBase {\n    type: AuxOpType.Revocation;\n\n    /**\n     * The ID of the certificate that created this revocation.\n     */\n    certId: AtomId;\n\n    /**\n     * The hash of the certificate that created this revocation.\n     */\n    certHash: string;\n\n    /**\n     * The signature data that was created by the certificate.\n     */\n    signature: string;\n}\n\n/**\n * Defines an atom value that instructs the system to create a tag mask.\n */\nexport interface TagMaskOp extends AuxOpBase {\n    type: AuxOpType.TagMask;\n\n    /**\n     * The ID of the bot that this tag mask applies to.\n     */\n    botId: string;\n\n    /**\n     * The name of the tag.\n     */\n    name: string;\n}\n\n/**\n * Creates a bot atom op.\n */\nexport function bot(id: string): BotOp {\n    return op<BotOp>(AuxOpType.Bot, {\n        id,\n    });\n}\n\n/**\n * Creates a tag atom op.\n */\nexport function tag(name: string): TagOp {\n    return op<TagOp>(AuxOpType.Tag, {\n        name,\n    });\n}\n\n/**\n * Creates a value op.\n * @param value The initial value for the tag.\n */\nexport function value(value: any): ValueOp {\n    return op<ValueOp>(AuxOpType.Value, {\n        value,\n    });\n}\n\n/**\n * Creates an insert op.\n * @param index The index to insert the text at.\n * @param text The text to insert.\n */\nexport function insertOp(index: number, text: string): InsertOp {\n    return op<InsertOp>(AuxOpType.Insert, {\n        index,\n        text,\n    });\n}\n\n/**\n * Creates a delete op.\n * @param index The index to insert the text at.\n */\nexport function deleteOp(start?: number, end?: number): DeleteOp {\n    return op<DeleteOp>(AuxOpType.Delete, {\n        start,\n        end,\n    });\n}\n\n/**\n * Creates a certificate op.\n * @param keypair The keypair for the certificate.\n * @param signature The signature for the certificate.\n */\nexport function cert(keypair: string, signature?: string): CertificateOp {\n    return op<CertificateOp>(AuxOpType.Certificate, {\n        keypair,\n        signature: signature || null,\n    });\n}\n\n/**\n * Creates a signature op.\n * @param valueId The ID of the value that signature was created for.\n * @param valueHash The hash of the value that the signature was created for.\n * @param signature The signature.\n */\nexport function sig(\n    valueId: AtomId,\n    valueHash: string,\n    signature: string\n): SignatureOp {\n    return op<SignatureOp>(AuxOpType.Signature, {\n        valueId,\n        valueHash,\n        signature,\n    });\n}\n\n/**\n * Creates a revocation op.\n * @param certId The ID of the cert that created the signature.\n * @param certHash The hash of the certificate.\n * @param signature The signature.\n */\nexport function revocation(\n    certId: AtomId,\n    certHash: string,\n    signature: string\n): RevocationOp {\n    return op<RevocationOp>(AuxOpType.Revocation, {\n        certId,\n        certHash,\n        signature,\n    });\n}\n\n/**\n * Creates a tag mask op.\n * @param botId The ID of the bot that the tag mask is for.\n * @param name The name of the tag.\n */\nexport function tagMask(botId: string, name: string): TagMaskOp {\n    return op<TagMaskOp>(AuxOpType.TagMask, {\n        botId,\n        name,\n    });\n}\n\nexport function op<T extends AuxOp>(type: T['type'], extra: Partial<T>): T {\n    return <T>assign(\n        {\n            type: type,\n        },\n        extra\n    );\n}\n\n/**\n * Creates a certificate that is self signed.\n * @param password The password used to encrypt the keypair.\n */\nexport function selfSignedCert(password: string): CertificateOp {\n    const keys = keypair(password);\n    return signedCert(null, password, keys);\n}\n\n/**\n * Calculates a signature for the given keypair that can be used for a certificate.\n * Returns a signature that can validate that a certificate was signed by another cert.\n * @param signingCert The certificate that is signing the keypair. If null then the certKeypair will be signed with itself.\n * @param signingPassword The password that is needed to decrypt the keypair in the signing certificate.\n * @param certKeypair The keypair that should be signed.\n */\nexport function signedCert(\n    signingCert: Atom<CertificateOp> | null,\n    signingPassword: string,\n    certKeypair: string\n): CertificateOp {\n    const bytes = certSigningBytes(signingCert, certKeypair);\n    const sig = sign(\n        signingCert ? signingCert.value.keypair : certKeypair,\n        signingPassword,\n        bytes\n    );\n    if (!sig) {\n        throw new Error('Unable to sign the certificate.');\n    }\n    return cert(certKeypair, sig);\n}\n\n/**\n * Validates that the given signed cert was signed with the given signing cert.\n * @param signingCert The cert that created the signature.\n * @param signedCert The cert that was signed.\n */\nexport function validateCertSignature(\n    signingCert: Atom<CertificateOp> | null,\n    signedCert: Atom<CertificateOp>\n): boolean {\n    const bytes = certSigningBytes(signingCert, signedCert.value.keypair);\n    try {\n        return verify(\n            signingCert ? signingCert.value.keypair : signedCert.value.keypair,\n            signedCert.value.signature,\n            bytes\n        );\n    } catch (err) {\n        return false;\n    }\n}\n\n/**\n * Creates a signature for the given value atom.\n * @param signingCert The certificate that is signing the value.\n * @param signingPassword The password used to decrypt the private key.\n * @param value The value to sign.\n */\nexport function signedValue(\n    signingCert: Atom<CertificateOp>,\n    signingPassword: string,\n    value: Atom<ValueOp>\n): SignatureOp {\n    const bytes = valueSigningBytes(signingCert, value);\n    const signature = sign(signingCert.value.keypair, signingPassword, bytes);\n    if (!signature) {\n        throw new Error('Unable to sign the value.');\n    }\n    return sig(value.id, value.hash, signature);\n}\n\n/**\n * Validates that the given signature was signed with the given certificate.\n * @param signingCert\n * @param signature\n */\nexport function validateSignedValue(\n    signingCert: Atom<CertificateOp>,\n    signature: Atom<SignatureOp>,\n    value: Atom<ValueOp>\n): boolean {\n    try {\n        const bytes = valueSigningBytes(signingCert, value);\n        return verify(\n            signingCert.value.keypair,\n            signature.value.signature,\n            bytes\n        );\n    } catch (err) {\n        return false;\n    }\n}\n\n/**\n * Creates a revocation for the given certificate or signature atom.\n * @param signingCert The certificate that is signing the value.\n * @param signingPassword The password used to decrypt the private key.\n * @param atom The value to revoke.\n */\nexport function signedRevocation(\n    signingCert: Atom<CertificateOp>,\n    signingPassword: string,\n    atom: Atom<CertificateOp> | Atom<SignatureOp>\n): RevocationOp {\n    const bytes = revocationSigningBytes(signingCert, atom);\n    const signature = sign(signingCert.value.keypair, signingPassword, bytes);\n    if (!signature) {\n        throw new Error('Unable to sign the value.');\n    }\n    return revocation(signingCert.id, signingCert.hash, signature);\n}\n\n/**\n * Validates that the given revocation was signed with the given certificate.\n * @param signingCert\n * @param revocation\n */\nexport function validateRevocation(\n    signingCert: Atom<CertificateOp>,\n    revocation: Atom<RevocationOp>,\n    atom: Atom<CertificateOp> | Atom<SignatureOp>\n): boolean {\n    try {\n        const bytes = revocationSigningBytes(signingCert, atom);\n        return verify(\n            signingCert.value.keypair,\n            revocation.value.signature,\n            bytes\n        );\n    } catch (err) {\n        return false;\n    }\n}\n\nfunction certSigningBytes(\n    signingCert: Atom<CertificateOp> | null,\n    certKeypair: string\n): Uint8Array {\n    if (!signingCert) {\n        return signingBytes([certKeypair]);\n    } else {\n        return signingBytes([signingCert.hash, certKeypair]);\n    }\n}\n\nfunction valueSigningBytes(\n    signingCert: Atom<CertificateOp>,\n    value: Atom<ValueOp>\n): Uint8Array {\n    return signingBytes([signingCert.hash, value.hash]);\n}\n\nfunction revocationSigningBytes(\n    signingCert: Atom<CertificateOp>,\n    value: Atom<CertificateOp> | Atom<SignatureOp>\n): Uint8Array {\n    return signingBytes([signingCert.hash, value.hash]);\n}\n\nfunction signingBytes(data: any): Uint8Array {\n    const json = stringify(data);\n    const encoder = new TextEncoder();\n    return encoder.encode(json);\n}\n\n/**\n * Gets the hash for the given tag and value.\n * @param botId The ID of the bot.\n * @param tag The tag.\n * @param value The value.\n */\nexport function tagValueHash(botId: string, tag: string, value: any): string {\n    return getHash([botId, tag, value]);\n}\n","import {\n    applyTagEdit,\n    edit,\n    isTagEdit,\n    mergeEdits,\n    remoteEdit,\n    TagEditOp,\n} from '../aux-format-2';\nimport {\n    BotSpace,\n    BotTags,\n    Bot,\n    ScriptTags,\n    PrecalculatedBot,\n    BOT_SPACE_TAG,\n    getBotSpace,\n    createPrecalculatedBot,\n    BotSignatures,\n    BotTagMasks,\n    getTag,\n    getTagMaskSpaces,\n    hasValue,\n    DEFAULT_TAG_MASK_SPACE,\n    TAG_MASK_SPACE_PRIORITIES_REVERSE,\n    TAG_MASK_SPACE_PRIORITIES,\n    RuntimeBot,\n    CLEAR_CHANGES_SYMBOL,\n    SET_TAG_MASK_SYMBOL,\n    CLEAR_TAG_MASKS_SYMBOL,\n    CompiledBotListener,\n    EDIT_TAG_SYMBOL,\n    EDIT_TAG_MASK_SYMBOL,\n    getOriginalObject,\n    GET_TAG_MASKS_SYMBOL,\n    RuntimeBotLinks,\n} from '../bots';\nimport {\n    createBotLink,\n    isBot,\n    isBotLink,\n    ORIGINAL_OBJECT,\n} from '../bots/BotCalculations';\nimport { CompiledBot } from './CompiledBot';\nimport { RuntimeStateVersion } from './RuntimeStateVersion';\nimport { convertToCopiableValue } from './Utils';\n\n/**\n * Defines an interface that contains runtime bots state.\n * That is, a map of bot IDs to the runtime bot instances.\n */\nexport interface RuntimeBotsState {\n    [id: string]: RuntimeBot;\n}\n\n/**\n * Flattens the given tag masks into a normal tags object.\n * Spaces are prioritized accoring to the TAG_MASK_SPACE_PRIORITIES_REVERSE list.\n * @param masks The masks to flatten.\n */\nexport function flattenTagMasks(masks: BotTagMasks): BotTags {\n    let result = {} as BotTags;\n    if (masks) {\n        for (let space of TAG_MASK_SPACE_PRIORITIES_REVERSE) {\n            if (!!masks[space]) {\n                Object.assign(result, masks[space]);\n            }\n        }\n    }\n    return result;\n}\n\n/**\n * Constructs a new script bot for the given bot.\n * Script bots provide special behaviors by implemlementing getters and setters for tag values as well\n * as handling extra compatibility concerns like serialization.\n *\n * @param bot The bot.\n * @param manager The service that is able to track updates on a bot.\n * @param context The global context.\n */\nexport function createRuntimeBot(\n    bot: CompiledBot,\n    manager: RuntimeBotInterface\n): RuntimeBot {\n    if (!bot) {\n        return null;\n    }\n\n    const constantTags = {\n        id: bot.id,\n        space: getBotSpace(bot),\n    };\n    let changedRawTags: BotTags = {};\n    let rawTags: ScriptTags = <ScriptTags>{\n        ...bot.tags,\n    };\n    let rawMasks: BotTags = flattenTagMasks(bot.masks || {});\n    let rawLinks: RuntimeBotLinks = {};\n    let changedMasks: BotTagMasks = {};\n\n    const arrayModifyMethods = new Set([\n        'push',\n        'shift',\n        'unshift',\n        'pop',\n        'splice',\n        'fill',\n        'sort',\n    ]);\n    // const arrayModifyProperties = new Set(['length']);\n\n    const wrapValue = (tag: string, value: any) => {\n        if (Array.isArray(value)) {\n            const isTagValue = () => value === manager.getRawValue(bot, tag);\n            const isMaskValue = () => value === manager.getTagMask(bot, tag);\n            const proxy = new Proxy(value, {\n                get(target, key: string, proxy) {\n                    if (arrayModifyMethods.has(key)) {\n                        const func: Function = Reflect.get(target, key, proxy);\n                        return function () {\n                            const ret = func.apply(this, arguments);\n                            if (isMaskValue()) {\n                                updateTagMask(tag, value);\n                            }\n                            if (isTagValue()) {\n                                updateTag(tag, value);\n                            }\n                            return ret;\n                        };\n                    }\n\n                    return Reflect.get(target, key, proxy);\n                },\n                set(target, key: string, proxy) {\n                    const ret = Reflect.set(target, key, proxy);\n                    // if (arrayModifyProperties.has(key)) {\n                    if (isMaskValue()) {\n                        updateTagMask(tag, value);\n                    }\n                    if (isTagValue()) {\n                        updateTag(tag, value);\n                    }\n                    // }\n                    return ret;\n                },\n            });\n\n            Object.defineProperty(proxy, ORIGINAL_OBJECT, {\n                configurable: true,\n                enumerable: false,\n                writable: false,\n                value: value,\n            });\n\n            return proxy;\n        }\n        return value;\n    };\n\n    const tagsProxy = new Proxy(rawTags, {\n        get(target, key: string, proxy) {\n            if (key === 'toJSON') {\n                return Reflect.get(target, key, proxy);\n            } else if (key in constantTags) {\n                return constantTags[<keyof typeof constantTags>key];\n            }\n\n            return wrapValue(key, manager.getValue(bot, key));\n        },\n        set(target, key: string, value, receiver) {\n            if (key in constantTags) {\n                return true;\n            }\n            updateTag(key, getOriginalObject(value));\n            return true;\n        },\n        deleteProperty(target, key: string) {\n            if (key in constantTags) {\n                return true;\n            }\n            const value = null as any;\n            updateTag(key, value);\n            return true;\n        },\n        ownKeys(target) {\n            const keys = Object.keys(bot.values);\n            return keys;\n        },\n        getOwnPropertyDescriptor(target, property) {\n            if (property === 'toJSON') {\n                return Reflect.getOwnPropertyDescriptor(target, property);\n            }\n\n            return Reflect.getOwnPropertyDescriptor(bot.values, property);\n        },\n    });\n    const rawProxy = new Proxy(rawTags, {\n        get(target, key: string, proxy) {\n            if (key in constantTags) {\n                return constantTags[<keyof typeof constantTags>key];\n            }\n            return manager.getRawValue(bot, key);\n        },\n        set(target, key: string, value, receiver) {\n            if (key in constantTags) {\n                return true;\n            }\n            updateTag(key, getOriginalObject(value));\n            return true;\n        },\n        deleteProperty(target, key: string) {\n            if (key in constantTags) {\n                return true;\n            }\n            const value = null as any;\n            updateTag(key, value);\n            return true;\n        },\n        ownKeys(target) {\n            const keys = Object.keys(bot.tags);\n            return keys;\n        },\n        getOwnPropertyDescriptor(target, property) {\n            if (property === 'toJSON') {\n                return Reflect.getOwnPropertyDescriptor(target, property);\n            }\n\n            return Reflect.getOwnPropertyDescriptor(bot.tags, property);\n        },\n    });\n\n    const listenersProxy = new Proxy(bot.listeners, {\n        get(target, key: string, proxy) {\n            if (key in constantTags) {\n                return null;\n            }\n            return manager.getListener(bot, key);\n        },\n    });\n\n    const signaturesProxy = new Proxy(bot.signatures || {}, {\n        get(target, key: string, proxy) {\n            if (key in constantTags) {\n                return constantTags[<keyof typeof constantTags>key];\n            }\n            return manager.getSignature(bot, key);\n        },\n        set(target, key: string, proxy) {\n            return true;\n        },\n        deleteProperty(target: any, key: any) {\n            return true;\n        },\n    });\n    const maskProxy = new Proxy(rawMasks, {\n        get(target, key: string, proxy) {\n            return wrapValue(key, manager.getTagMask(bot, key));\n        },\n        set(target, key: string, value, proxy) {\n            if (key in constantTags) {\n                return true;\n            }\n            updateTagMask(key, getOriginalObject(value));\n            return true;\n        },\n        deleteProperty(target: any, key: string) {\n            if (key in constantTags) {\n                return true;\n            }\n            const spaces = getTagMaskSpaces(bot, key);\n            const config = manager.updateTagMask(bot, key, spaces, null);\n            if (config.mode === RealtimeEditMode.Immediate) {\n                delete rawMasks[key];\n            }\n            changeTagMask(key, config.changedValue, spaces);\n            return true;\n        },\n        ownKeys(target) {\n            const keys = Object.keys(flattenTagMasks(bot.masks));\n            return keys;\n        },\n        getOwnPropertyDescriptor(target, property) {\n            if (property === 'toJSON') {\n                return Reflect.getOwnPropertyDescriptor(target, property);\n            }\n\n            const flat = flattenTagMasks(bot.masks);\n            return Reflect.getOwnPropertyDescriptor(flat, property);\n        },\n    });\n\n    const linkProxy = new Proxy(rawLinks, {\n        set(target, key: string, value, proxy) {\n            if (key in constantTags) {\n                return true;\n            }\n            if (isBot(value)) {\n                updateTag(key, createBotLink([value.id]));\n            } else if (Array.isArray(value)) {\n                const tagValue = value.map((v) => (isBot(v) ? v.id : null));\n                updateTag(key, createBotLink(tagValue));\n            } else if (isBotLink(value)) {\n                updateTag(key, value);\n            } else if (typeof value === 'string') {\n                updateTag(key, createBotLink([value]));\n            } else if (\n                !hasValue(value) &&\n                isBotLink(manager.getValue(bot, key))\n            ) {\n                updateTag(key, value);\n            }\n\n            return true;\n        },\n        get(target, key: string, proxy) {\n            if (key === 'toJSON') {\n                return Reflect.get(target, key, proxy);\n            } else if (key in constantTags) {\n                return undefined;\n            }\n            return manager.getTagLink(bot, key);\n        },\n        ownKeys(target) {\n            const keys = Object.keys(bot.values);\n            return keys.filter((key) => {\n                return isBotLink(manager.getValue(bot, key));\n            });\n        },\n        deleteProperty(target, key: string) {\n            if (key in constantTags) {\n                return true;\n            }\n            if (isBotLink(manager.getValue(bot, key))) {\n                const value = null as any;\n                updateTag(key, value);\n            }\n            return true;\n        },\n        getOwnPropertyDescriptor(target, property: string) {\n            if (property === 'toJSON') {\n                return Reflect.getOwnPropertyDescriptor(target, property);\n            }\n\n            if (isBotLink(manager.getValue(bot, property))) {\n                return Reflect.getOwnPropertyDescriptor(bot.values, property);\n            }\n            return undefined;\n        },\n    });\n\n    // Define a toJSON() function but\n    // make it not enumerable so it is not included\n    // in Object.keys() and for..in expressions.\n    Object.defineProperty(tagsProxy, 'toJSON', {\n        value: () => bot.tags,\n        writable: false,\n        enumerable: false,\n\n        // This is so the function can be wrapped with another proxy\n        // if needed. (Like for VM2Sandbox)\n        configurable: true,\n    });\n\n    Object.defineProperty(linkProxy, 'toJSON', {\n        value: () => {\n            const linkKeys = Object.keys(linkProxy);\n            let result = {} as any;\n            for (let key of linkKeys) {\n                result[key] = manager.getValue(bot, key);\n            }\n            return result;\n        },\n        writable: false,\n        enumerable: false,\n        configurable: true,\n    });\n\n    let script: RuntimeBot = {\n        id: bot.id,\n        link: createBotLink([bot.id]),\n        tags: tagsProxy,\n        raw: rawProxy,\n        masks: maskProxy,\n        links: linkProxy,\n        vars: {},\n        changes: changedRawTags,\n        maskChanges: changedMasks,\n        listeners: listenersProxy,\n        signatures: signaturesProxy,\n        [CLEAR_CHANGES_SYMBOL]: null,\n        [SET_TAG_MASK_SYMBOL]: null,\n        [GET_TAG_MASKS_SYMBOL]: null,\n        [CLEAR_TAG_MASKS_SYMBOL]: null,\n        [EDIT_TAG_SYMBOL]: null,\n        [EDIT_TAG_MASK_SYMBOL]: null,\n    };\n\n    Object.defineProperty(script, CLEAR_CHANGES_SYMBOL, {\n        value: () => {\n            changedRawTags = {};\n            changedMasks = {};\n            script.changes = changedRawTags;\n            script.maskChanges = changedMasks;\n        },\n        configurable: false,\n        enumerable: false,\n        writable: false,\n    });\n\n    Object.defineProperty(script, SET_TAG_MASK_SYMBOL, {\n        value: (key: string, value: any, space: string) => {\n            if (key in constantTags) {\n                return true;\n            }\n            const spaces = !hasValue(space)\n                ? hasValue(value)\n                    ? [DEFAULT_TAG_MASK_SPACE]\n                    : getTagMaskSpaces(bot, key)\n                : [space];\n            const valueToSet = getOriginalObject(value);\n            const config = manager.updateTagMask(bot, key, spaces, valueToSet);\n            if (config.mode === RealtimeEditMode.Immediate) {\n                rawMasks[key] = valueToSet;\n            }\n            changeTagMask(key, config.changedValue, spaces);\n            return value;\n        },\n        configurable: false,\n        enumerable: false,\n        writable: false,\n    });\n\n    Object.defineProperty(script, GET_TAG_MASKS_SYMBOL, {\n        value: () => {\n            let masks = {} as BotTagMasks;\n            if (bot.masks) {\n                for (let space in bot.masks) {\n                    let spaceMasks = {} as BotTags;\n                    let hasSpaceMasks = false;\n                    const botMasks = bot.masks[space];\n                    for (let tag in botMasks) {\n                        const val = botMasks[tag];\n                        if (hasValue(val)) {\n                            hasSpaceMasks = true;\n                            spaceMasks[tag] = val;\n                        }\n                    }\n\n                    if (hasSpaceMasks) {\n                        masks[space] = spaceMasks;\n                    }\n                }\n            }\n            return masks;\n        },\n        configurable: false,\n        enumerable: false,\n        writable: false,\n    });\n\n    Object.defineProperty(script, CLEAR_TAG_MASKS_SYMBOL, {\n        value: (space: string) => {\n            if (bot.masks) {\n                let spaces = hasValue(space)\n                    ? [space]\n                    : TAG_MASK_SPACE_PRIORITIES;\n                for (let space of spaces) {\n                    const tags = bot.masks[space];\n                    for (let tag in tags) {\n                        script[SET_TAG_MASK_SYMBOL](tag, null, space);\n                    }\n                }\n            }\n        },\n        configurable: false,\n        enumerable: false,\n        writable: false,\n    });\n\n    Object.defineProperty(script, EDIT_TAG_SYMBOL, {\n        value: (tag: string, ops: TagEditOp[]) => {\n            if (tag in constantTags) {\n                return;\n            }\n            const e = remoteEdit(manager.currentVersion.vector, ...ops);\n            script.tags[tag] = e;\n        },\n        configurable: false,\n        enumerable: false,\n        writable: false,\n    });\n\n    Object.defineProperty(script, EDIT_TAG_MASK_SYMBOL, {\n        value: (tag: string, ops: TagEditOp[], space?: string) => {\n            if (tag in constantTags) {\n                return;\n            }\n            const e = remoteEdit(manager.currentVersion.vector, ...ops);\n            if (!hasValue(space)) {\n                const availableSpaces = getTagMaskSpaces(bot, tag);\n                if (availableSpaces.length <= 0) {\n                    space = DEFAULT_TAG_MASK_SPACE;\n                } else {\n                    for (let possibleSpace of TAG_MASK_SPACE_PRIORITIES) {\n                        if (availableSpaces.indexOf(possibleSpace) >= 0) {\n                            space = possibleSpace;\n                            break;\n                        }\n                    }\n                }\n            }\n            script[SET_TAG_MASK_SYMBOL](tag, e, space);\n        },\n        configurable: false,\n        enumerable: false,\n        writable: false,\n    });\n\n    Object.defineProperty(script, 'toJSON', {\n        value: () => {\n            if ('space' in bot) {\n                return {\n                    id: bot.id,\n                    space: bot.space,\n                    tags: tagsProxy,\n                };\n            } else {\n                return {\n                    id: bot.id,\n                    tags: tagsProxy,\n                };\n            }\n        },\n        writable: false,\n        enumerable: false,\n\n        // This is so the function can be wrapped with another proxy\n        // if needed. (Like for VM2Sandbox)\n        configurable: true,\n    });\n\n    if (BOT_SPACE_TAG in bot) {\n        script.space = bot.space;\n    }\n\n    const scriptProxy = new Proxy(script, {\n        get(target, prop: string, reciever) {\n            if (prop in target) {\n                return Reflect.get(target, prop, reciever);\n            } else if (typeof prop === 'string') {\n                const listener = manager.getListener(bot, prop);\n                if (listener) {\n                    return listener;\n                }\n            }\n            return undefined;\n        },\n    });\n\n    return scriptProxy;\n\n    function updateTag(tag: string, value: any) {\n        const { mode, changedValue } = manager.updateTag(bot, tag, value);\n        if (mode === RealtimeEditMode.Immediate) {\n            rawTags[tag] = value;\n            changeTag(tag, changedValue);\n        } else if (mode === RealtimeEditMode.Delayed) {\n            changeTag(tag, changedValue);\n        }\n    }\n\n    function updateTagMask(tag: string, value: any) {\n        const spaces = hasValue(value)\n            ? [DEFAULT_TAG_MASK_SPACE]\n            : getTagMaskSpaces(bot, tag);\n        const { mode, changedValue } = manager.updateTagMask(\n            bot,\n            tag,\n            spaces,\n            value\n        );\n        if (mode === RealtimeEditMode.Immediate) {\n            rawMasks[tag] = value;\n        }\n        changeTagMask(tag, changedValue, spaces);\n    }\n\n    function changeTag(tag: string, value: any) {\n        if (isTagEdit(value)) {\n            const currentValue = changedRawTags[tag];\n            if (isTagEdit(currentValue)) {\n                value = mergeEdits(currentValue, value);\n            } else if (hasValue(currentValue)) {\n                value = applyTagEdit(currentValue, value);\n            }\n        }\n        changedRawTags[tag] = value;\n    }\n\n    function changeTagMask(tag: string, value: any, spaces: string[]) {\n        for (let space of spaces) {\n            if (!changedMasks[space]) {\n                changedMasks[space] = {};\n            }\n            if (isTagEdit(value)) {\n                const currentValue = changedMasks[space][tag];\n                if (isTagEdit(currentValue)) {\n                    value = mergeEdits(currentValue, value);\n                } else if (hasValue(currentValue)) {\n                    value = applyTagEdit(currentValue, value);\n                }\n            }\n            changedMasks[space][tag] = value;\n        }\n    }\n}\n\n/**\n * Defines an interface for an object that provides the API that script bots use for housekeeping.\n */\nexport interface RuntimeBotInterface extends RuntimeBatcher {\n    /**\n     * Updates the tag of the given bot.\n     * Returns the realtime edit mode that should be used for this particular assignment.\n     * @param bot The bot.\n     * @param tag The tag that should be updated.\n     * @param newValue The new tag value.\n     */\n    updateTag(bot: CompiledBot, tag: string, newValue: any): RealtimeEditConfig;\n\n    /**\n     * Updates the tag mask of the given bot.\n     * @param bot The bot.\n     * @param tag The tag that should be updated.\n     * @param space The spaces that the tag mask should be applied in.\n     * @param value The new tag value. If null, then the mask will be deleted.\n     */\n    updateTagMask(\n        bot: CompiledBot,\n        tag: string,\n        spaces: string[],\n        value: any\n    ): RealtimeEditConfig;\n\n    /**\n     * Gets the value for the given tag on the given bot.\n     * @param bot The bot.\n     * @param tag The tag.\n     */\n    getValue(bot: CompiledBot, tag: string): any;\n\n    /**\n     * Gets the raw value for the given tag on the given bot.\n     * @param bot The bot.\n     * @param tag The tag.\n     */\n    getRawValue(bot: CompiledBot, tag: string): any;\n\n    /**\n     * Gets the raw tag mask value for the given tag.\n     * @param bot The bot.\n     * @param tag The tag.\n     * @param space The space.\n     */\n    getTagMask(bot: CompiledBot, tag: string): any;\n\n    /**\n     * Gets the tag link for the given tag.\n     * @param bot The bot.\n     * @param tag The tag.\n     */\n    getTagLink(bot: CompiledBot, tag: string): RuntimeBot | RuntimeBot[];\n\n    /**\n     * Gets the listener for the given bot and tag, resolving any formulas that may be present.\n     * Returns null if no listener is available.\n     * @param bot The bot.\n     * @param tag The tag.\n     */\n    getListener(bot: CompiledBot, tag: string): CompiledBotListener;\n\n    /**\n     * Gets whether the given signature on the bot is valid.\n     * @param bot The bot.\n     * @param signature The tag.\n     */\n    getSignature(bot: CompiledBot, signature: string): string;\n\n    /**\n     * Gets the current version that the interface is at.\n     */\n    currentVersion: RuntimeStateVersion;\n}\n\n/**\n * Defines an interface for an object that is able to manage the creation and destruction of script bots in the runtime.\n */\nexport interface RuntimeBotFactory {\n    /**\n     * Creates a new script bot from the given bot and adds it to the runtime.\n     *\n     * Returns null if a runtime bot could not be created for the given bot.\n     * This can happen when a bot is being created in a space that doesn't support immediate realtime edits.\n     *\n     * @param bot The bot.\n     */\n    createRuntimeBot(bot: Bot): RuntimeBot;\n\n    /**\n     * Destroyes the given script bot and removes it from the runtime.\n     * Returns the realtime edit mode that should apply for this operation.\n     *\n     * @param bot The bot.\n     */\n    destroyScriptBot(bot: RuntimeBot): RealtimeEditMode;\n}\n\n/**\n * Defines an interface for an object that is able to batch script results.\n */\nexport interface RuntimeBatcher {\n    /**\n     * Notifies the batcher that a change has happened and that it should schedule\n     * a handler to grab the changes and apply them.\n     */\n    notifyChange(): void;\n}\n\n/**\n * The list of possible realtime edit modes.\n */\nexport enum RealtimeEditMode {\n    /**\n     * Specifies that bots in this edit mode cannot be edited.\n     */\n    None = 0,\n\n    /**\n     * Specifies that all changes to the bot will be accepted.\n     * This allows the changes to be immediately used.\n     */\n    Immediate = 1,\n\n    /**\n     * Specifies that some changes to the bot may be rejected.\n     * This requires that changes be delayed until the related\n     * partition accepts/denies them.\n     */\n    Delayed = 2,\n}\n\n/**\n * The options that should be used when editing a tag.\n */\nexport interface RealtimeEditConfig {\n    /**\n     * The edit mode that should be used.\n     */\n    mode: RealtimeEditMode;\n\n    /**\n     * The value that should be used for the bot changes.\n     * If not included, then the value that was originally provided should be used.\n     */\n    changedValue: any;\n}\n","import { RealtimeEditMode } from './RuntimeBot';\n\n/**\n * The default realtime edit mode.\n */\nexport const DEFAULT_REALTIME_EDIT_MODE: RealtimeEditMode =\n    RealtimeEditMode.Immediate;\n\n/**\n * A map between space types and the realtime edit modes they should use.\n */\nexport type SpaceRealtimeEditModeMap = Map<string, RealtimeEditMode>;\n\n/**\n * The default map between bot spaces and realtime edit modes.\n */\nexport const DEFAULT_SPACE_REALTIME_EDIT_MODE_MAP: SpaceRealtimeEditModeMap = new Map(\n    [\n        ['shared', RealtimeEditMode.Immediate],\n        ['local', RealtimeEditMode.Immediate],\n        ['tempLocal', RealtimeEditMode.Immediate],\n        ['history', RealtimeEditMode.Delayed],\n        ['admin', RealtimeEditMode.Delayed],\n        ['certified', RealtimeEditMode.None],\n        ['bootstrap', RealtimeEditMode.None],\n    ]\n);\n\n/**\n * Gets the realtime edit mode for the given space and map.\n * @param map The map.\n * @param space The space.\n */\nexport function getRealtimeEditMode(\n    map: SpaceRealtimeEditModeMap,\n    space: string\n): RealtimeEditMode {\n    return map.get(space) || DEFAULT_REALTIME_EDIT_MODE;\n}\n\n/**\n * Defines an interface for an object that is able to provide realtime edit modes for a particular partition key.\n */\nexport interface AuxRealtimeEditModeProvider {\n    /**\n     * Gets the edit mode for the given space.\n     * @param space The space.\n     */\n    getEditMode(space: string): RealtimeEditMode;\n}\n\nexport class DefaultRealtimeEditModeProvider\n    implements AuxRealtimeEditModeProvider {\n    private _map: SpaceRealtimeEditModeMap;\n\n    constructor(\n        map: SpaceRealtimeEditModeMap = DEFAULT_SPACE_REALTIME_EDIT_MODE_MAP\n    ) {\n        this._map = map;\n    }\n\n    getEditMode(space: string): RealtimeEditMode {\n        return getRealtimeEditMode(this._map, space);\n    }\n}\n","if (!globalThis.Blob) {\n    if (typeof process === 'undefined') {\n        console.warn(\n            '[BlobPolyfill] Loading Blob stub! This should not happen in browser environments!'\n        );\n    }\n    (<any>globalThis).Blob = class {\n        type: string;\n        parts: any[];\n\n        constructor(parts: any[], options: any) {\n            this.parts = parts.slice();\n            this.type = options?.type;\n        }\n\n        async arrayBuffer(): Promise<ArrayBuffer> {\n            let bytes = [] as number[];\n            const encoder = new TextEncoder();\n            for (const part of this.parts) {\n                if (typeof part === 'string') {\n                    const encoded = encoder.encode(part);\n                    bytes.push(...encoded);\n                } else if (part instanceof ArrayBuffer) {\n                    bytes.push(...new Uint8Array(part));\n                } else if (ArrayBuffer.isView(part)) {\n                    bytes.push(...new Uint8Array(part.buffer));\n                } else if (part instanceof Blob) {\n                    const buffer = await part.arrayBuffer();\n                    bytes.push(...new Uint8Array(buffer));\n                }\n            }\n\n            const view = new Uint8Array(bytes);\n            return view.buffer;\n        }\n    };\n}\n","import * as Acorn from 'acorn';\nimport AcornJSX from 'acorn-jsx';\nimport { generate, GENERATOR } from 'astring';\nimport LRUCache from 'lru-cache';\nimport { traverse } from 'estraverse';\nimport {\n    createAbsolutePositionFromRelativePosition,\n    createRelativePositionFromTypeIndex,\n    getItem,\n    Doc,\n    Text,\n} from 'yjs';\nimport {\n    createAbsolutePositionFromStateVector,\n    createRelativePositionFromStateVector,\n    getClock,\n} from '../yjs/YjsHelpers';\nimport { VersionVector } from '@casual-simulation/causal-trees';\n\n/**\n * The symbol that is used in script dependencies to represent any argument.\n */\nexport const anyArgument = Symbol('anyArgument');\n\ndeclare module 'acorn' {\n    /**\n     * Extends the acorn parser interface.\n     */\n    interface Parser {\n        type: Acorn.TokenType;\n        start: number;\n        startLoc: number;\n        value: string;\n        pos: number;\n        next(): void;\n        parseLiteral(value: string): Acorn.Node;\n        parseIdent(): Acorn.Node;\n        parseExprSubscripts(): Acorn.Node;\n        parseSubscript(\n            base: Acorn.Node,\n            startPos: number,\n            startLoc: number\n        ): Acorn.Node;\n        unexpected(): void;\n        startNodeAt(start: number, startLoc: number): Acorn.Node;\n        readToken(code: number): any;\n        finishToken(token: Acorn.TokenType): any;\n        finishNode(node: Acorn.Node, type: string): Acorn.Node;\n        parseExprAtom(refShortHandDefaultPos: any): Acorn.Node;\n        parseParenAndDistinguishExpression(canBeArrow: boolean): Acorn.Node;\n    }\n}\n\nexport type ExJsNode = TokenValueNode | ObjectValueNode;\n\nexport interface TokenValueNode extends Acorn.Node {\n    type: 'TokenValue';\n    identifier: Acorn.Node;\n}\n\nexport interface ObjectValueNode extends Acorn.Node {\n    type: 'ObjectValue';\n    identifier: Acorn.Node;\n}\n\nconst exJsGenerator = Object.assign({}, GENERATOR, {\n    ImportExpression: function (node: any, state: any) {\n        state.write('import(');\n        this[node.source.type](node.source, state);\n        state.write(')');\n    },\n});\n\nexport interface TranspilerMacro {\n    test: RegExp;\n    replacement: (val: string) => string;\n}\n\n/**\n * The list of macros that the sandbox uses on the input code before transpiling it.\n */\nconst MACROS: TranspilerMacro[] = [\n    {\n        test: /^(?:\\)/g,\n        replacement: (val) => '',\n    },\n    {\n        test: /(?:[])/g,\n        replacement: (val) => '\"',\n    },\n    {\n        test: /(?:[])/g,\n        replacement: (val) => \"'\",\n    },\n];\n\n/**\n * Replaces macros in the given text.\n * @param text The text that the macros should be replaced in.\n */\nexport function replaceMacros(text: string) {\n    if (!text) {\n        return text;\n    }\n\n    for (let m of MACROS) {\n        text = text.replace(m.test, m.replacement);\n    }\n\n    return text;\n}\n\nexport interface TranspilerOptions {\n    jsxFactory?: string;\n    jsxFragment?: string;\n    forceSync?: boolean;\n}\n\n/**\n * Defines a class that is able to compile code from AUX's custom JavaScript dialect\n * into pure ES6 JavaScript. Does not preserve spacing or comments.\n *\n * See https://docs.google.com/document/d/1WQXQPjdXxyx_lau15WPpwTTYvt66_wPCu3x-08rpLoY/edit?usp=sharing\n */\nexport class Transpiler {\n    private _parser: typeof Acorn.Parser;\n    private _jsxFactory: string;\n    private _jsxFragment: string;\n    private _forceSync: boolean;\n    private _cache: LRUCache<string, TranspilerResult>;\n\n    get forceSync() {\n        return this._forceSync;\n    }\n\n    set forceSync(value: boolean) {\n        this._forceSync = value;\n    }\n\n    constructor(options?: TranspilerOptions) {\n        this._cache = new LRUCache<string, TranspilerResult>({\n            max: 1000,\n        });\n        this._parser = Acorn.Parser.extend(AcornJSX());\n        this._jsxFactory = options?.jsxFactory ?? 'h';\n        this._jsxFragment = options?.jsxFragment ?? 'Fragment';\n        this._forceSync = options?.forceSync ?? false;\n    }\n\n    parse(code: string): any {\n        const macroed = replaceMacros(code);\n        const node = this._parse(macroed);\n        return node;\n    }\n\n    /**\n     * Transpiles the given code into ES6 JavaScript Code.\n     */\n    transpile(code: string): string {\n        const result = this._transpile(code);\n        return result.code;\n    }\n\n    /**\n     * Transpiles the given code and returns the result with the generated metadata.\n     * @param code The code that should be transpiled.\n     */\n    transpileWithMetadata(code: string): TranspilerResult {\n        return this._transpile(code);\n    }\n\n    /**\n     * Transpiles the given code into ES6 JavaScript Code.\n     */\n    private _transpile(code: string): TranspilerResult {\n        const cached = this._cache.get(code);\n        if (cached) {\n            return cached;\n        }\n        const macroed = replaceMacros(code);\n        const node = this._parse(macroed);\n\n        // we create a YJS document to track\n        // text changes. This lets us use a separate client ID for each change\n        // which makes the calculations for indexes much simpler.\n        // This is because we can use a separate client ID for every required\n        // change and ignore other changes when looking for the right edit position.\n        const doc = new Doc();\n        doc.clientID = 0;\n\n        const text = doc.getText();\n        text.insert(0, code);\n\n        this._replace(node, doc, text);\n        const finalCode = text.toString();\n        const result: TranspilerResult = {\n            code: finalCode,\n            original: macroed,\n            metadata: {\n                doc,\n                text,\n            },\n        };\n        this._cache.set(code, result);\n\n        return result;\n    }\n\n    /**\n     * Parses the given code into a syntax tree.\n     * @param code\n     */\n    private _parse(code: string): any {\n        const node = this._parser.parse(code, {\n            ecmaVersion: <any>11,\n            locations: true,\n        });\n        return node;\n    }\n\n    getTagNodeValues(n: any) {\n        let currentNode = n.identifier;\n        let identifier: any;\n        let args: any[] = [];\n        let nodes: any[] = [];\n        while (currentNode.type === 'MemberExpression') {\n            currentNode = currentNode.object;\n        }\n        if (currentNode.type === 'CallExpression') {\n            identifier = currentNode.callee;\n            args = currentNode.arguments;\n            currentNode = n.identifier;\n            while (currentNode.type === 'MemberExpression') {\n                nodes.unshift(currentNode);\n                currentNode = currentNode.object;\n            }\n        } else {\n            identifier = n.identifier;\n        }\n        let tag: string;\n        if (identifier.type === 'MemberExpression') {\n            tag = this.toJs(identifier);\n        } else {\n            tag = identifier.name || identifier.value;\n        }\n        return { tag, args, nodes };\n    }\n\n    toJs(node: Acorn.Node): string {\n        return generate(<any>node, {\n            generator: exJsGenerator,\n        });\n    }\n\n    private _replace(node: Acorn.Node, doc: Doc, text: Text): void {\n        if (!node) {\n            return;\n        }\n\n        traverse(<any>node, {\n            enter: <any>((n: any, parent: any) => {\n                if (n.type === 'WhileStatement') {\n                    this._replaceWhileStatement(n, doc, text);\n                } else if (n.type === 'DoWhileStatement') {\n                    this._replaceDoWhileStatement(n, doc, text);\n                } else if (n.type === 'ForStatement') {\n                    this._replaceForStatement(n, doc, text);\n                } else if (n.type === 'ForInStatement') {\n                    this._replaceForInStatement(n, doc, text);\n                } else if (n.type === 'ForOfStatement') {\n                    this._replaceForOfStatement(n, doc, text);\n                } else if (n.type === 'JSXElement') {\n                    this._replaceJSXElement(n, doc, text);\n                } else if (n.type === 'JSXText') {\n                    this._replaceJSXText(n, doc, text);\n                } else if (n.type === 'JSXExpressionContainer') {\n                    this._replaceJSXExpressionContainer(n, doc, text);\n                } else if (n.type === 'JSXFragment') {\n                    this._replaceJSXFragment(n, doc, text);\n                } else if (\n                    this._forceSync &&\n                    n.type === 'FunctionDeclaration' &&\n                    n.async\n                ) {\n                    this._replaceAsyncFunction(n, doc, text);\n                } else if (\n                    this._forceSync &&\n                    n.type === 'ArrowFunctionExpression' &&\n                    n.async\n                ) {\n                    this._replaceAsyncFunction(n, doc, text);\n                } else if (\n                    this._forceSync &&\n                    n.type === 'FunctionExpression' &&\n                    n.async\n                ) {\n                    if (parent.type === 'Property' && parent.method) {\n                        this._replaceAsyncFunction(parent, doc, text);\n                    } else {\n                        this._replaceAsyncFunction(n, doc, text);\n                    }\n                } else if (this._forceSync && n.type === 'AwaitExpression') {\n                    this._replaceAwaitExpression(n, doc, text);\n                }\n            }),\n\n            keys: {\n                JSXElement: [],\n                JSXFragment: [],\n                JSXOpeningElement: [],\n                JSXClosingElement: [],\n                JSXText: [],\n                JSXExpressionContainer: ['expression'],\n            },\n        });\n    }\n\n    private _replaceWhileStatement(node: any, doc: Doc, text: Text): any {\n        this._insertEnergyCheckIntoStatement(doc, text, node.body);\n    }\n\n    private _replaceDoWhileStatement(node: any, doc: Doc, text: Text): any {\n        this._insertEnergyCheckIntoStatement(doc, text, node.body);\n    }\n\n    private _replaceForStatement(node: any, doc: Doc, text: Text): any {\n        this._insertEnergyCheckIntoStatement(doc, text, node.body);\n    }\n\n    private _replaceForInStatement(node: any, doc: Doc, text: Text): any {\n        this._insertEnergyCheckIntoStatement(doc, text, node.body);\n    }\n\n    private _replaceForOfStatement(node: any, doc: Doc, text: Text): any {\n        this._insertEnergyCheckIntoStatement(doc, text, node.body);\n    }\n\n    private _replaceJSXElement(node: any, doc: Doc, text: Text): any {\n        this._insertJSXFactoryCall(\n            node,\n            node.openingElement,\n            node.closingElement,\n            doc,\n            text\n        );\n\n        this._removeTag(\n            node,\n            node.openingElement,\n            node.closingElement,\n            doc,\n            text\n        );\n    }\n\n    private _replaceJSXFragment(node: any, doc: Doc, text: Text): any {\n        this._insertJSXFactoryCall(\n            node,\n            node.openingFragment,\n            node.closingFragment,\n            doc,\n            text\n        );\n\n        this._removeTag(\n            node,\n            node.openingFragment,\n            node.closingFragment,\n            doc,\n            text\n        );\n    }\n\n    private _insertJSXFactoryCall(\n        node: any,\n        openElement: any,\n        closeElement: any,\n        doc: Doc,\n        text: Text\n    ): void {\n        doc.clientID += 1;\n        const version = { '0': getClock(doc, 0) };\n\n        const openingFunctionCall = `${this._jsxFactory}(`;\n        const absoluteStart = createAbsolutePositionFromStateVector(\n            doc,\n            text,\n            version,\n            node.start,\n            undefined,\n            true\n        );\n        const end = createRelativePositionFromStateVector(\n            text,\n            version,\n            !!closeElement ? closeElement.end : node.end,\n            -1,\n            true\n        );\n        const nameStart =\n            node.type === 'JSXElement'\n                ? createRelativePositionFromStateVector(\n                      text,\n                      version,\n                      openElement.name.start,\n                      undefined,\n                      true\n                  )\n                : null;\n        const nameEnd =\n            node.type == 'JSXElement'\n                ? createRelativePositionFromStateVector(\n                      text,\n                      version,\n                      openElement.name.end,\n                      -1,\n                      true\n                  )\n                : null;\n\n        let currentIndex = absoluteStart.index;\n\n        text.insert(currentIndex, openingFunctionCall);\n        currentIndex += openingFunctionCall.length;\n\n        if (node.type === 'JSXElement') {\n            const nameElement = openElement.name;\n\n            let addQuotes = false;\n            if (nameElement.type === 'JSXIdentifier') {\n                const name = openElement.name.name;\n                if (/^[a-z]/.test(name)) {\n                    addQuotes = true;\n                }\n            }\n\n            // Add quotes around builtin component names\n            if (addQuotes) {\n                const startIndex = createAbsolutePositionFromRelativePosition(\n                    nameStart,\n                    doc\n                );\n                text.insert(startIndex.index, '\"');\n                const endIndex = createAbsolutePositionFromRelativePosition(\n                    nameEnd,\n                    doc\n                );\n                text.insert(endIndex.index, '\",');\n                currentIndex = endIndex.index + 2;\n            } else {\n                // Add the comma after variable reference names\n                const endIndex = createAbsolutePositionFromRelativePosition(\n                    nameEnd,\n                    doc\n                );\n                text.insert(endIndex.index, ',');\n                currentIndex = endIndex.index + 1;\n            }\n        } else {\n            // make string literal\n            const nodeName = this._jsxFragment + ',';\n            text.insert(currentIndex, nodeName);\n            currentIndex += nodeName.length;\n        }\n\n        if (openElement.attributes.length > 0) {\n            this._replaceJSXElementAttributes(\n                node,\n                openElement,\n                openElement.attributes,\n                doc,\n                text\n            );\n        } else {\n            const props = `null,`;\n            text.insert(currentIndex, props);\n        }\n\n        this._replaceJSXElementChildren(node, node.children, doc, text);\n\n        const absoluteEnd = createAbsolutePositionFromRelativePosition(\n            end,\n            doc\n        );\n        doc.clientID += 1;\n        text.insert(absoluteEnd.index, ')');\n    }\n\n    private _replaceJSXElementAttributes(\n        node: any,\n        openElement: any,\n        attributes: any[],\n        doc: Doc,\n        text: Text\n    ): void {\n        // doc.clientID += 1;\n        const version = { '0': getClock(doc, 0) };\n\n        const start = createRelativePositionFromStateVector(\n            text,\n            version,\n            openElement.name?.end ?? openElement.start + 1,\n            undefined,\n            true\n        );\n        const end = createRelativePositionFromStateVector(\n            text,\n            version,\n            openElement.selfClosing ? openElement.end - 2 : openElement.end,\n            -1,\n            true\n        );\n\n        let attrs = [];\n\n        for (let attr of attributes) {\n            const attrStart = createRelativePositionFromStateVector(\n                text,\n                version,\n                attr.start,\n                undefined,\n                true\n            );\n\n            if (attr.type === 'JSXSpreadAttribute') {\n                attrs.push([attr, attrStart]);\n            } else {\n                const attrName = attr.name.name;\n                attrs.push([attr, attrStart, attrName]);\n            }\n        }\n\n        let index = 0;\n        for (let [attr, start, name] of attrs) {\n            const pos = createAbsolutePositionFromRelativePosition(start, doc);\n            let val = '';\n            if (index > 0) {\n                val = ',';\n            }\n            if (attr.type !== 'JSXSpreadAttribute') {\n                val += `\"${name}\":`;\n\n                if (!attr.value) {\n                    val += 'true';\n                }\n            }\n            text.insert(pos.index, val);\n            index++;\n\n            if (attr.type === 'JSXSpreadAttribute') {\n                this._replace(attr.argument, doc, text);\n            } else {\n                this._replace(attr.value, doc, text);\n            }\n        }\n\n        const startAbsolute = createAbsolutePositionFromRelativePosition(\n            start,\n            doc\n        );\n        text.insert(startAbsolute.index, '{');\n\n        const endAbsolute = createAbsolutePositionFromRelativePosition(\n            end,\n            doc\n        );\n        text.insert(endAbsolute.index, '},');\n    }\n\n    private _replaceJSXElementChildren(\n        node: any,\n        children: any,\n        doc: Doc,\n        text: Text\n    ): void {\n        const version = { '0': getClock(doc, 0) };\n\n        for (let child of children) {\n            const pos = createRelativePositionFromStateVector(\n                text,\n                version,\n                child.end,\n                undefined,\n                true\n            );\n            this._replace(child, doc, text);\n\n            doc.clientID += 1;\n            const absoluteEnd = createAbsolutePositionFromRelativePosition(\n                pos,\n                doc\n            );\n            text.insert(absoluteEnd.index, ',');\n        }\n    }\n\n    private _replaceJSXText(node: any, doc: Doc, text: Text): any {\n        doc.clientID += 1;\n        const version = { '0': getClock(doc, 0) };\n\n        const startIndex = node.start;\n        const endIndex = node.end;\n\n        const absoluteStart = createAbsolutePositionFromStateVector(\n            doc,\n            text,\n            version,\n            startIndex,\n            undefined,\n            true\n        );\n        text.insert(absoluteStart.index, '`');\n\n        const absoluteEnd = createAbsolutePositionFromStateVector(\n            doc,\n            text,\n            version,\n            endIndex,\n            undefined,\n            true\n        );\n        text.insert(absoluteEnd.index, '`');\n    }\n\n    private _replaceJSXExpressionContainer(node: any, doc: Doc, text: Text) {\n        const version = { '0': getClock(doc, 0) };\n\n        // Positions for the opening \"{\"\n        const valueStartBegin = createRelativePositionFromStateVector(\n            text,\n            version,\n            node.start,\n            undefined,\n            true\n        );\n        const valueStartEnd = createRelativePositionFromStateVector(\n            text,\n            version,\n            node.start + 1,\n            -1,\n            true\n        );\n\n        // Positions for the closing \"}\"\n        const valueEndBegin = createRelativePositionFromStateVector(\n            text,\n            version,\n            node.end - 1,\n            undefined,\n            true\n        );\n        const valueEndEnd = createRelativePositionFromStateVector(\n            text,\n            version,\n            node.end + 1,\n            -1,\n            true\n        );\n\n        // Delete the opening \"{\"\n        const absoluteValueStartBegin =\n            createAbsolutePositionFromRelativePosition(valueStartBegin, doc);\n        const absoluteValueStartEnd =\n            createAbsolutePositionFromRelativePosition(valueStartEnd, doc);\n        text.delete(absoluteValueStartBegin.index, 1);\n\n        // Delete the closing \"}\"\n        const absoluteValueEndBegin =\n            createAbsolutePositionFromRelativePosition(valueEndBegin, doc);\n        const absoluteValueEndEnd = createAbsolutePositionFromRelativePosition(\n            valueEndEnd,\n            doc\n        );\n        text.delete(absoluteValueEndBegin.index, 1);\n    }\n\n    private _removeTag(\n        node: any,\n        openElement: any,\n        closeElement: any,\n        doc: Doc,\n        text: Text\n    ): void {\n        doc.clientID += 1;\n        const version = { '0': getClock(doc, 0) };\n\n        // Save relative positions here\n        const openStart = createRelativePositionFromStateVector(\n            text,\n            version,\n            openElement.start,\n            undefined,\n            true\n        );\n        const openNameEnd = createRelativePositionFromStateVector(\n            text,\n            version,\n            openElement.name?.end ?? openElement.start + 1,\n            -1,\n            true\n        );\n        const openEnd = createRelativePositionFromStateVector(\n            text,\n            version,\n            openElement.end - (closeElement ? 1 : 2),\n            undefined,\n            true\n        );\n        const closingStart = !!closeElement\n            ? createRelativePositionFromStateVector(\n                  text,\n                  version,\n                  closeElement.start,\n                  undefined,\n                  true\n              )\n            : null;\n        const closingEnd = !!closeElement\n            ? createRelativePositionFromStateVector(\n                  text,\n                  version,\n                  closeElement.end,\n                  -1,\n                  true\n              )\n            : null;\n\n        let attributePositions = [];\n        for (let attribute of openElement.attributes) {\n            if (attribute.type !== 'JSXSpreadAttribute') {\n                const nameStart = createRelativePositionFromStateVector(\n                    text,\n                    version,\n                    attribute.name.start,\n                    undefined,\n                    true\n                );\n                const nameEnd = createRelativePositionFromStateVector(\n                    text,\n                    version,\n                    !!attribute.value\n                        ? attribute.name.end + 1\n                        : attribute.name.end,\n                    -1,\n                    true\n                );\n\n                attributePositions.push([nameStart, nameEnd]);\n            } else {\n                const openBraceStart = createRelativePositionFromStateVector(\n                    text,\n                    version,\n                    attribute.start,\n                    undefined,\n                    true\n                );\n                const openBraceEnd = createRelativePositionFromStateVector(\n                    text,\n                    version,\n                    attribute.start + 1,\n                    undefined,\n                    true\n                );\n                const closeBraceStart = createRelativePositionFromStateVector(\n                    text,\n                    version,\n                    attribute.end - 1,\n                    -1,\n                    true\n                );\n                const closeBraceEnd = createRelativePositionFromStateVector(\n                    text,\n                    version,\n                    attribute.end,\n                    -1,\n                    true\n                );\n\n                attributePositions.push([openBraceStart, openBraceEnd]);\n                attributePositions.push([closeBraceStart, closeBraceEnd]);\n            }\n        }\n\n        for (let [start, end] of attributePositions) {\n            // remove attribute name\n            const nameStart = createAbsolutePositionFromRelativePosition(\n                start,\n                doc\n            );\n            const nameEnd = createAbsolutePositionFromRelativePosition(\n                end,\n                doc\n            );\n\n            // remove name + \"=\"\n            text.delete(nameStart.index, nameEnd.index - nameStart.index);\n        }\n\n        // remove open tag <\n        const openStartAbsolute = createAbsolutePositionFromRelativePosition(\n            openStart,\n            doc\n        );\n        text.delete(openStartAbsolute.index, 1);\n\n        // remove open tag >\n        const openEndAbsolute = createAbsolutePositionFromRelativePosition(\n            openEnd,\n            doc\n        );\n        text.delete(openEndAbsolute.index, closeElement ? 1 : 2);\n\n        if (closeElement) {\n            // remove closing tag\n            const closingStartAbsolute =\n                createAbsolutePositionFromRelativePosition(closingStart, doc);\n            const closingEndAbsolute =\n                createAbsolutePositionFromRelativePosition(closingEnd, doc);\n            text.delete(\n                closingStartAbsolute.index,\n                closingEndAbsolute.index - closingStartAbsolute.index\n            );\n        }\n    }\n\n    private _insertEnergyCheckIntoStatement(\n        doc: Doc,\n        text: Text,\n        statement: any\n    ) {\n        doc.clientID += 1;\n        const version = { '0': getClock(doc, 0) };\n        let startIndex: number;\n        let postfix: string = '';\n        let wrapWithBraces: boolean = false;\n\n        if (statement.type === 'BlockStatement') {\n            // Block statements look like this:\n            // while(true) { }\n            // Block statements are wrapped with curly braces\n            // so we should use a full statement \"__energyCheck();\"\n            startIndex = statement.start + 1;\n            postfix = ';';\n        } else if (statement.type === 'ExpressionStatement') {\n            // Expression statements look like this:\n            // while(true) abc();\n            // therefore, we can find the start of the expression and use a comma\n            // between our call and the other code to make it a sequence expression.\n            startIndex = statement.start;\n            postfix = ';';\n            wrapWithBraces = true;\n        } else if (statement.type === 'EmptyStatement') {\n            // Empty statements look like this:\n            // while(true) ;\n            // as a result, we only need to insert the call to convert the expression from empty to\n            // an expression statement containing a single function call.\n            startIndex = statement.start;\n        } else {\n            // Other statements (like \"if\", \"try\", \"throw\" and other loops)\n            // should be wrapped in curly braces\n            startIndex = statement.start;\n            postfix = ';';\n            wrapWithBraces = true;\n        }\n\n        this._insertEnergyCheck(\n            doc,\n            text,\n            version,\n            startIndex,\n            statement.end,\n            postfix,\n            wrapWithBraces\n        );\n    }\n\n    private _insertEnergyCheck(\n        doc: Doc,\n        text: Text,\n        version: VersionVector,\n        startIndex: number,\n        endIndex: number,\n        postfix: string,\n        wrapWithBraces: boolean\n    ) {\n        if (wrapWithBraces) {\n            const absolute = createAbsolutePositionFromStateVector(\n                doc,\n                text,\n                version,\n                startIndex,\n                undefined,\n                true\n            );\n            text.insert(absolute.index, '{');\n        }\n\n        const absolute = createAbsolutePositionFromStateVector(\n            doc,\n            text,\n            version,\n            startIndex,\n            undefined,\n            true\n        );\n        text.insert(absolute.index, ENERGY_CHECK_CALL + postfix);\n\n        if (wrapWithBraces) {\n            const absolute = createAbsolutePositionFromStateVector(\n                doc,\n                text,\n                version,\n                endIndex,\n                undefined,\n                true\n            );\n            text.insert(absolute.index, '}');\n        }\n    }\n\n    private _replaceAsyncFunction(node: any, doc: Doc, text: Text) {\n        doc.clientID += 1;\n        const version = { '0': getClock(doc, 0) };\n\n        const functionStart = createRelativePositionFromStateVector(\n            text,\n            version,\n            node.start,\n            undefined,\n            true\n        );\n        const functionStartAbsolute =\n            createAbsolutePositionFromRelativePosition(functionStart, doc);\n\n        text.delete(functionStartAbsolute.index, 'async '.length);\n    }\n\n    private _replaceAwaitExpression(node: any, doc: Doc, text: Text) {\n        doc.clientID += 1;\n        const version = { '0': getClock(doc, 0) };\n\n        const keywordStart = createRelativePositionFromStateVector(\n            text,\n            version,\n            node.start,\n            undefined,\n            true\n        );\n        const keywordStartAbsolute = createAbsolutePositionFromRelativePosition(\n            keywordStart,\n            doc\n        );\n\n        text.delete(keywordStartAbsolute.index, 'await '.length);\n    }\n}\n\nconst ENERGY_CHECK_CALL = '__energyCheck()';\n\nexport interface TranspilerResult {\n    /**\n     * The code that resulted from the transpiler.\n     */\n    code: string;\n\n    /**\n     * The original code.\n     */\n    original: string;\n\n    /**\n     * The metadata that the transpiler produced for the code.\n     */\n    metadata: {\n        /**\n         * The document that was used to edit the code.\n         */\n        doc: Doc;\n\n        /**\n         * The text structure that was used to edit the code.\n         */\n        text: Text;\n    };\n}\n\n/**\n * Defines an interface that represents a location in some code by line number and column.\n */\nexport interface CodeLocation {\n    /**\n     * The zero based line number that the location represents.\n     */\n    lineNumber: number;\n\n    /**\n     * The zero based column number that the location represents.\n     */\n    column: number;\n}\n\nexport function calculateOriginalLineLocation(\n    result: TranspilerResult,\n    location: CodeLocation\n): CodeLocation {\n    const index = calculateIndexFromLocation(result.code, location);\n\n    const relative = createRelativePositionFromTypeIndex(\n        result.metadata.text,\n        index\n    );\n\n    if (relative.item.client === 0) {\n        return calculateLocationFromIndex(result.original, relative.item.clock);\n    }\n\n    let item = getItem(result.metadata.doc.store, relative.item);\n\n    while (item && item.id.client !== 0) {\n        item = item.left;\n    }\n\n    return calculateLocationFromIndex(\n        result.original,\n        item.id.clock + item.length\n    );\n}\n\nexport function calculateIndexFromLocation(\n    code: string,\n    location: CodeLocation\n): number {\n    let line = location.lineNumber;\n    let column = location.column;\n    let index = 0;\n    for (; index < code.length; index++) {\n        const char = code[index];\n        if (line > 0) {\n            if (char === '\\n') {\n                line -= 1;\n            }\n        } else if (column > 0) {\n            column -= 1;\n            if (char === '\\n') {\n                index++;\n                break;\n            }\n        } else {\n            break;\n        }\n    }\n\n    return index;\n}\n\nexport function calculateLocationFromIndex(\n    code: string,\n    index: number\n): CodeLocation {\n    let line = 0;\n    let lastLineIndex = 0;\n    for (let counter = 0; counter < code.length && counter < index; counter++) {\n        const char = code[counter];\n        if (char === '\\n') {\n            line += 1;\n            lastLineIndex = counter + 1;\n        }\n    }\n\n    let column = index - lastLineIndex;\n\n    return {\n        lineNumber: line,\n        column,\n    };\n}\n","if (!globalThis.performance) {\n    globalThis.performance = {\n        now() {\n            return Date.now();\n        },\n    } as any;\n}\n","interface Array<T> {\n    first(): T | undefined;\n}\n\nif (!Array.prototype['first']) {\n    Object.defineProperty(Array.prototype, 'first', {\n        value: function() {\n            // 1. Let O be ? ToObject(this value).\n            if (this == null) {\n                throw new TypeError('\"this\" is null or not defined');\n            }\n\n            var o = Object(this);\n\n            // 2. Let len be ? ToLength(? Get(O, \"length\")).\n            var len = o.length >>> 0;\n\n            // 3. Check if we have at least one element\n            if (len > 0) {\n                // 4. Return first element\n                return o[0];\n            }\n\n            // 5. Return undefined.\n            return undefined;\n        },\n        configurable: true,\n        writable: true,\n    });\n}\n","interface Array<T> {\n    last(): T | undefined;\n}\n\nif (!Array.prototype['last']) {\n    Object.defineProperty(Array.prototype, 'last', {\n        value: function() {\n            // 1. Let O be ? ToObject(this value).\n            if (this == null) {\n                throw new TypeError('\"this\" is null or not defined');\n            }\n\n            var o = Object(this);\n\n            // 2. Let len be ? ToLength(? Get(O, \"length\")).\n            var len = o.length >>> 0;\n\n            // 3. Check if we have at least one element\n            if (len > 0) {\n                // 4. Return the last element\n                return o[len - 1];\n            }\n\n            // 5. Return undefined.\n            return undefined;\n        },\n        configurable: true,\n        writable: true,\n    });\n}\n","export interface CSPair {\n    /**\n\tThe ANSI terminal control sequence for starting this style.\n\t*/\n    readonly open: string;\n\n    /**\n\tThe ANSI terminal control sequence for ending this style.\n\t*/\n    readonly close: string;\n}\n\nexport interface ColorBase {\n    /**\n\tThe ANSI terminal control sequence for ending this color.\n\t*/\n    readonly close: string;\n\n    ansi(code: number): string;\n\n    ansi256(code: number): string;\n\n    ansi16m(red: number, green: number, blue: number): string;\n}\n\nexport interface Modifier {\n    /**\n\tResets the current color chain.\n\t*/\n    readonly reset: CSPair;\n\n    /**\n\tMake text bold.\n\t*/\n    readonly bold: CSPair;\n\n    /**\n\tEmitting only a small amount of light.\n\t*/\n    readonly dim: CSPair;\n\n    /**\n\tMake text italic. (Not widely supported)\n\t*/\n    readonly italic: CSPair;\n\n    /**\n\tMake text underline. (Not widely supported)\n\t*/\n    readonly underline: CSPair;\n\n    /**\n\tMake text overline.\n\n\tSupported on VTE-based terminals, the GNOME terminal, mintty, and Git Bash.\n\t*/\n    readonly overline: CSPair;\n\n    /**\n\tInverse background and foreground colors.\n\t*/\n    readonly inverse: CSPair;\n\n    /**\n\tPrints the text, but makes it invisible.\n\t*/\n    readonly hidden: CSPair;\n\n    /**\n\tPuts a horizontal line through the center of the text. (Not widely supported)\n\t*/\n    readonly strikethrough: CSPair;\n}\n\nexport interface ForegroundColor {\n    readonly black: CSPair;\n    readonly red: CSPair;\n    readonly green: CSPair;\n    readonly yellow: CSPair;\n    readonly blue: CSPair;\n    readonly cyan: CSPair;\n    readonly magenta: CSPair;\n    readonly white: CSPair;\n\n    /**\n\tAlias for `blackBright`.\n\t*/\n    readonly gray: CSPair;\n\n    /**\n\tAlias for `blackBright`.\n\t*/\n    readonly grey: CSPair;\n\n    readonly blackBright: CSPair;\n    readonly redBright: CSPair;\n    readonly greenBright: CSPair;\n    readonly yellowBright: CSPair;\n    readonly blueBright: CSPair;\n    readonly cyanBright: CSPair;\n    readonly magentaBright: CSPair;\n    readonly whiteBright: CSPair;\n}\n\nexport interface BackgroundColor {\n    readonly bgBlack: CSPair;\n    readonly bgRed: CSPair;\n    readonly bgGreen: CSPair;\n    readonly bgYellow: CSPair;\n    readonly bgBlue: CSPair;\n    readonly bgCyan: CSPair;\n    readonly bgMagenta: CSPair;\n    readonly bgWhite: CSPair;\n\n    /**\n\tAlias for `bgBlackBright`.\n\t*/\n    readonly bgGray: CSPair;\n\n    /**\n\tAlias for `bgBlackBright`.\n\t*/\n    readonly bgGrey: CSPair;\n\n    readonly bgBlackBright: CSPair;\n    readonly bgRedBright: CSPair;\n    readonly bgGreenBright: CSPair;\n    readonly bgYellowBright: CSPair;\n    readonly bgBlueBright: CSPair;\n    readonly bgCyanBright: CSPair;\n    readonly bgMagentaBright: CSPair;\n    readonly bgWhiteBright: CSPair;\n}\nexport interface ConvertColor {\n    /**\n\tConvert from the RGB color space to the ANSI 256 color space.\n\n\t@param red - (`0...255`)\n\t@param green - (`0...255`)\n\t@param blue - (`0...255`)\n\t*/\n    rgbToAnsi256(red: number, green: number, blue: number): number;\n\n    /**\n\tConvert from the RGB HEX color space to the RGB color space.\n\n\t@param hex - A hexadecimal string containing RGB data.\n\t*/\n    hexToRgb(hex: string | number): [red: number, green: number, blue: number];\n\n    /**\n\tConvert from the RGB HEX color space to the ANSI 256 color space.\n\n\t@param hex - A hexadecimal string containing RGB data.\n\t*/\n    hexToAnsi256(hex: string): number;\n\n    /**\n\tConvert from the ANSI 256 color space to the ANSI 16 color space.\n\n\t@param code - A number representing the ANSI 256 color.\n\t*/\n    ansi256ToAnsi(code: number): number;\n\n    /**\n\tConvert from the RGB color space to the ANSI 16 color space.\n\n\t@param red - (`0...255`)\n\t@param green - (`0...255`)\n\t@param blue - (`0...255`)\n\t*/\n    rgbToAnsi(red: number, green: number, blue: number): number;\n\n    /**\n\tConvert from the RGB HEX color space to the ANSI 16 color space.\n\n\t@param hex - A hexadecimal string containing RGB data.\n\t*/\n    hexToAnsi(hex: string): number;\n}\n\nexport type AnsiStyles = {\n    readonly modifier: Modifier;\n    readonly color: ColorBase & ForegroundColor;\n    readonly bgColor: ColorBase & BackgroundColor;\n    readonly codes: ReadonlyMap<number, number>;\n} & ForegroundColor &\n    BackgroundColor &\n    Modifier &\n    ConvertColor;\n\nconst ANSI_BACKGROUND_OFFSET = 10;\n\nconst wrapAnsi16 =\n    (offset = 0) =>\n    (code: any) =>\n        `\\u001B[${code + offset}m`;\n\nconst wrapAnsi256 =\n    (offset = 0) =>\n    (code: any) =>\n        `\\u001B[${38 + offset};5;${code}m`;\n\nconst wrapAnsi16m =\n    (offset = 0) =>\n    (red: number, green: number, blue: number) =>\n        `\\u001B[${38 + offset};2;${red};${green};${blue}m`;\n\nfunction assembleStyles(): AnsiStyles {\n    const codes = new Map();\n    const styles = {\n        modifier: {\n            reset: [0, 0],\n            // 21 isn't widely supported and 22 does the same thing\n            bold: [1, 22],\n            dim: [2, 22],\n            italic: [3, 23],\n            underline: [4, 24],\n            overline: [53, 55],\n            inverse: [7, 27],\n            hidden: [8, 28],\n            strikethrough: [9, 29],\n        },\n        color: {\n            black: [30, 39],\n            red: [31, 39],\n            green: [32, 39],\n            yellow: [33, 39],\n            blue: [34, 39],\n            magenta: [35, 39],\n            cyan: [36, 39],\n            white: [37, 39],\n\n            // Bright color\n            blackBright: [90, 39],\n            redBright: [91, 39],\n            greenBright: [92, 39],\n            yellowBright: [93, 39],\n            blueBright: [94, 39],\n            magentaBright: [95, 39],\n            cyanBright: [96, 39],\n            whiteBright: [97, 39],\n        },\n        bgColor: {\n            bgBlack: [40, 49],\n            bgRed: [41, 49],\n            bgGreen: [42, 49],\n            bgYellow: [43, 49],\n            bgBlue: [44, 49],\n            bgMagenta: [45, 49],\n            bgCyan: [46, 49],\n            bgWhite: [47, 49],\n\n            // Bright color\n            bgBlackBright: [100, 49],\n            bgRedBright: [101, 49],\n            bgGreenBright: [102, 49],\n            bgYellowBright: [103, 49],\n            bgBlueBright: [104, 49],\n            bgMagentaBright: [105, 49],\n            bgCyanBright: [106, 49],\n            bgWhiteBright: [107, 49],\n        },\n    } as any;\n\n    // Alias bright black as gray (and grey)\n    styles.color.gray = styles.color.blackBright;\n    styles.bgColor.bgGray = styles.bgColor.bgBlackBright;\n    styles.color.grey = styles.color.blackBright;\n    styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;\n\n    for (const [groupName, group] of Object.entries<any>(styles)) {\n        for (const [styleName, style] of Object.entries<any>(group)) {\n            styles[styleName] = {\n                open: `\\u001B[${style[0]}m`,\n                close: `\\u001B[${style[1]}m`,\n            };\n\n            group[styleName] = styles[styleName];\n\n            codes.set(style[0], style[1]);\n        }\n\n        Object.defineProperty(styles, groupName, {\n            value: group,\n            enumerable: false,\n        });\n    }\n\n    Object.defineProperty(styles, 'codes', {\n        value: codes,\n        enumerable: false,\n    });\n\n    styles.color.close = '\\u001B[39m';\n    styles.bgColor.close = '\\u001B[49m';\n\n    styles.color.ansi = wrapAnsi16();\n    styles.color.ansi256 = wrapAnsi256();\n    styles.color.ansi16m = wrapAnsi16m();\n    styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);\n    styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);\n    styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);\n\n    // From https://github.com/Qix-/color-convert/blob/3f0e0d4e92e235796ccb17f6e85c72094a651f49/conversions.js\n    Object.defineProperties(styles, {\n        rgbToAnsi256: {\n            value: (red: number, green: number, blue: number) => {\n                // We use the extended greyscale palette here, with the exception of\n                // black and white. normal palette only has 4 greyscale shades.\n                if (red === green && green === blue) {\n                    if (red < 8) {\n                        return 16;\n                    }\n\n                    if (red > 248) {\n                        return 231;\n                    }\n\n                    return Math.round(((red - 8) / 247) * 24) + 232;\n                }\n\n                return (\n                    16 +\n                    36 * Math.round((red / 255) * 5) +\n                    6 * Math.round((green / 255) * 5) +\n                    Math.round((blue / 255) * 5)\n                );\n            },\n            enumerable: false,\n        },\n        hexToRgb: {\n            value: (hex: string | number) => {\n                const matches = /(?<colorString>[a-f\\d]{6}|[a-f\\d]{3})/i.exec(\n                    hex.toString(16)\n                );\n                if (!matches) {\n                    return [0, 0, 0];\n                }\n\n                let { colorString } = matches.groups;\n\n                if (colorString.length === 3) {\n                    colorString = colorString\n                        .split('')\n                        .map((character) => character + character)\n                        .join('');\n                }\n\n                const integer = Number.parseInt(colorString, 16);\n\n                return [\n                    (integer >> 16) & 0xff,\n                    (integer >> 8) & 0xff,\n                    integer & 0xff,\n                ];\n            },\n            enumerable: false,\n        },\n        hexToAnsi256: {\n            value: (hex: string) =>\n                styles.rgbToAnsi256(...styles.hexToRgb(hex)),\n            enumerable: false,\n        },\n        ansi256ToAnsi: {\n            value: (code: number) => {\n                if (code < 8) {\n                    return 30 + code;\n                }\n\n                if (code < 16) {\n                    return 90 + (code - 8);\n                }\n\n                let red: number;\n                let green: number;\n                let blue: number;\n\n                if (code >= 232) {\n                    red = ((code - 232) * 10 + 8) / 255;\n                    green = red;\n                    blue = red;\n                } else {\n                    code -= 16;\n\n                    const remainder = code % 36;\n\n                    red = Math.floor(code / 36) / 5;\n                    green = Math.floor(remainder / 6) / 5;\n                    blue = (remainder % 6) / 5;\n                }\n\n                const value = Math.max(red, green, blue) * 2;\n\n                if (value === 0) {\n                    return 30;\n                }\n\n                let result =\n                    30 +\n                    ((Math.round(blue) << 2) |\n                        (Math.round(green) << 1) |\n                        Math.round(red));\n\n                if (value === 2) {\n                    result += 60;\n                }\n\n                return result;\n            },\n            enumerable: false,\n        },\n        rgbToAnsi: {\n            value: (red: number, green: number, blue: number) =>\n                styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),\n            enumerable: false,\n        },\n        hexToAnsi: {\n            value: (hex: string) =>\n                styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),\n            enumerable: false,\n        },\n    });\n\n    return styles;\n}\n\nconst ansiStyles = assembleStyles();\n\nexport default ansiStyles;\n","export function stringReplaceAll(\n    string: string,\n    substring: string,\n    replacer: string\n) {\n    let index = string.indexOf(substring);\n    if (index === -1) {\n        return string;\n    }\n\n    const substringLength = substring.length;\n    let endIndex = 0;\n    let returnValue = '';\n    do {\n        returnValue +=\n            string.substr(endIndex, index - endIndex) + substring + replacer;\n        endIndex = index + substringLength;\n        index = string.indexOf(substring, endIndex);\n    } while (index !== -1);\n\n    returnValue += string.slice(endIndex);\n    return returnValue;\n}\n\nexport function stringEncaseCRLFWithFirstIndex(\n    string: string,\n    prefix: string,\n    postfix: string,\n    index: number\n) {\n    let endIndex = 0;\n    let returnValue = '';\n    do {\n        const gotCR = string[index - 1] === '\\r';\n        returnValue +=\n            string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) +\n            prefix +\n            (gotCR ? '\\r\\n' : '\\n') +\n            postfix;\n        endIndex = index + 1;\n        index = string.indexOf('\\n', endIndex);\n    } while (index !== -1);\n\n    returnValue += string.slice(endIndex);\n    return returnValue;\n}\n","import ansiStyles from './ansi-styles';\nimport { stringReplaceAll, stringEncaseCRLFWithFirstIndex } from './util';\n\nconst GENERATOR = Symbol('GENERATOR');\nconst STYLER = Symbol('STYLER');\nconst IS_EMPTY = Symbol('IS_EMPTY');\n\n// `supportsColor.level`  `ansiStyles.color[name]` mapping\nconst levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m'];\n\nconst styles = Object.create(null);\n\n/**\nBasic foreground colors.\n\n[More colors here.](https://github.com/chalk/chalk/blob/main/readme.md#256-and-truecolor-color-support)\n*/\nexport type ForegroundColor =\n    | 'black'\n    | 'red'\n    | 'green'\n    | 'yellow'\n    | 'blue'\n    | 'magenta'\n    | 'cyan'\n    | 'white'\n    | 'gray'\n    | 'grey'\n    | 'blackBright'\n    | 'redBright'\n    | 'greenBright'\n    | 'yellowBright'\n    | 'blueBright'\n    | 'magentaBright'\n    | 'cyanBright'\n    | 'whiteBright';\n\n/**\nBasic background colors.\n\n[More colors here.](https://github.com/chalk/chalk/blob/main/readme.md#256-and-truecolor-color-support)\n*/\nexport type BackgroundColor =\n    | 'bgBlack'\n    | 'bgRed'\n    | 'bgGreen'\n    | 'bgYellow'\n    | 'bgBlue'\n    | 'bgMagenta'\n    | 'bgCyan'\n    | 'bgWhite'\n    | 'bgGray'\n    | 'bgGrey'\n    | 'bgBlackBright'\n    | 'bgRedBright'\n    | 'bgGreenBright'\n    | 'bgYellowBright'\n    | 'bgBlueBright'\n    | 'bgMagentaBright'\n    | 'bgCyanBright'\n    | 'bgWhiteBright';\n\n/**\nBasic colors.\n\n[More colors here.](https://github.com/chalk/chalk/blob/main/readme.md#256-and-truecolor-color-support)\n*/\nexport type Color = ForegroundColor | BackgroundColor;\n\nexport type Modifiers =\n    | 'reset'\n    | 'bold'\n    | 'dim'\n    | 'italic'\n    | 'underline'\n    | 'overline'\n    | 'inverse'\n    | 'hidden'\n    | 'strikethrough'\n    | 'visible';\n\n/**\nLevels:\n- `0` - All colors disabled.\n- `1` - Basic 16 colors support.\n- `2` - ANSI 256 colors support.\n- `3` - Truecolor 16 million colors support.\n*/\nexport type ColorSupportLevel = 0 | 1 | 2 | 3;\n\nexport interface Options {\n    /**\n\tSpecify the color support for Chalk.\n\n\tBy default, color support is automatically detected based on the environment.\n\n\tLevels:\n\t- `0` - All colors disabled.\n\t- `1` - Basic 16 colors support.\n\t- `2` - ANSI 256 colors support.\n\t- `3` - Truecolor 16 million colors support.\n\t*/\n    readonly level?: ColorSupportLevel;\n}\n\n/**\nDetect whether the terminal supports color.\n*/\nexport interface ColorSupport {\n    /**\n\tThe color level used by Chalk.\n\t*/\n    level: ColorSupportLevel;\n\n    /**\n\tReturn whether Chalk supports basic 16 colors.\n\t*/\n    hasBasic: boolean;\n\n    /**\n\tReturn whether Chalk supports ANSI 256 colors.\n\t*/\n    has256: boolean;\n\n    /**\n\tReturn whether Chalk supports Truecolor 16 million colors.\n\t*/\n    has16m: boolean;\n}\n\nexport interface ChalkInstance {\n    (...text: unknown[]): string;\n\n    /**\n\tThe color support for Chalk.\n\n\tBy default, color support is automatically detected based on the environment.\n\n\tLevels:\n\t- `0` - All colors disabled.\n\t- `1` - Basic 16 colors support.\n\t- `2` - ANSI 256 colors support.\n\t- `3` - Truecolor 16 million colors support.\n\t*/\n    level: ColorSupportLevel;\n\n    /**\n\tUse RGB values to set text color.\n\n\t@example\n\t```\n\timport chalk from 'chalk';\n\n\tchalk.rgb(222, 173, 237);\n\t```\n\t*/\n    rgb: (red: number, green: number, blue: number) => this;\n\n    /**\n\tUse HEX value to set text color.\n\n\t@param color - Hexadecimal value representing the desired color.\n\n\t@example\n\t```\n\timport chalk from 'chalk';\n\n\tchalk.hex('#DEADED');\n\t```\n\t*/\n    hex: (color: string) => this;\n\n    /**\n\tUse an [8-bit unsigned number](https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit) to set text color.\n\n\t@example\n\t```\n\timport chalk from 'chalk';\n\n\tchalk.ansi256(201);\n\t```\n\t*/\n    ansi256: (index: number) => this;\n\n    /**\n\tUse RGB values to set background color.\n\n\t@example\n\t```\n\timport chalk from 'chalk';\n\n\tchalk.bgRgb(222, 173, 237);\n\t```\n\t*/\n    bgRgb: (red: number, green: number, blue: number) => this;\n\n    /**\n\tUse HEX value to set background color.\n\n\t@param color - Hexadecimal value representing the desired color.\n\n\t@example\n\t```\n\timport chalk from 'chalk';\n\n\tchalk.bgHex('#DEADED');\n\t```\n\t*/\n    bgHex: (color: string) => this;\n\n    /**\n\tUse a [8-bit unsigned number](https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit) to set background color.\n\n\t@example\n\t```\n\timport chalk from 'chalk';\n\n\tchalk.bgAnsi256(201);\n\t```\n\t*/\n    bgAnsi256: (index: number) => this;\n\n    /**\n\tModifier: Reset the current style.\n\t*/\n    readonly reset: this;\n\n    /**\n\tModifier: Make the text bold.\n\t*/\n    readonly bold: this;\n\n    /**\n\tModifier: Make the text have lower opacity.\n\t*/\n    readonly dim: this;\n\n    /**\n\tModifier: Make the text italic. *(Not widely supported)*\n\t*/\n    readonly italic: this;\n\n    /**\n\tModifier: Put a horizontal line below the text. *(Not widely supported)*\n\t*/\n    readonly underline: this;\n\n    /**\n\tModifier: Put a horizontal line above the text. *(Not widely supported)*\n\t*/\n    readonly overline: this;\n\n    /**\n\tModifier: Invert background and foreground colors.\n\t*/\n    readonly inverse: this;\n\n    /**\n\tModifier: Print the text but make it invisible.\n\t*/\n    readonly hidden: this;\n\n    /**\n\tModifier: Puts a horizontal line through the center of the text. *(Not widely supported)*\n\t*/\n    readonly strikethrough: this;\n\n    /**\n\tModifier: Print the text only when Chalk has a color level above zero.\n\n\tCan be useful for things that are purely cosmetic.\n\t*/\n    readonly visible: this;\n\n    readonly black: this;\n    readonly red: this;\n    readonly green: this;\n    readonly yellow: this;\n    readonly blue: this;\n    readonly magenta: this;\n    readonly cyan: this;\n    readonly white: this;\n\n    /*\n\tAlias for `blackBright`.\n\t*/\n    readonly gray: this;\n\n    /*\n\tAlias for `blackBright`.\n\t*/\n    readonly grey: this;\n\n    readonly blackBright: this;\n    readonly redBright: this;\n    readonly greenBright: this;\n    readonly yellowBright: this;\n    readonly blueBright: this;\n    readonly magentaBright: this;\n    readonly cyanBright: this;\n    readonly whiteBright: this;\n\n    readonly bgBlack: this;\n    readonly bgRed: this;\n    readonly bgGreen: this;\n    readonly bgYellow: this;\n    readonly bgBlue: this;\n    readonly bgMagenta: this;\n    readonly bgCyan: this;\n    readonly bgWhite: this;\n\n    /*\n\tAlias for `bgBlackBright`.\n\t*/\n    readonly bgGray: this;\n\n    /*\n\tAlias for `bgBlackBright`.\n\t*/\n    readonly bgGrey: this;\n\n    readonly bgBlackBright: this;\n    readonly bgRedBright: this;\n    readonly bgGreenBright: this;\n    readonly bgYellowBright: this;\n    readonly bgBlueBright: this;\n    readonly bgMagentaBright: this;\n    readonly bgCyanBright: this;\n    readonly bgWhiteBright: this;\n}\n\n/**\nMain Chalk object that allows to chain styles together.\n\nCall the last one as a method with a string argument.\n\nOrder doesn't matter, and later styles take precedent in case of a conflict.\n\nThis simply means that `chalk.red.yellow.green` is equivalent to `chalk.green`.\n*/\n// declare const chalk: ChalkInstance;\n\n// export const supportsColor: ColorSupport | false;\n\n// export const chalkStderr: typeof chalk;\n// export const supportsColorStderr: typeof supportsColor;\n\n// export default chalk;\n\nconst applyOptions = (object: any, options: Options = {}) => {\n    if (\n        options.level &&\n        !(\n            Number.isInteger(options.level) &&\n            options.level >= 0 &&\n            options.level <= 3\n        )\n    ) {\n        throw new Error('The `level` option should be an integer from 0 to 3');\n    }\n\n    // Detect level if not set manually\n    const colorLevel = 0;\n    object.level = options.level === undefined ? colorLevel : options.level;\n};\n\nexport class Chalk {\n    constructor(options: Options) {\n        // eslint-disable-next-line no-constructor-return\n        return chalkFactory(options);\n    }\n}\n\nconst chalkFactory = (options: Options) => {\n    const chalk = (...strings: string[]) => strings.join(' ');\n    applyOptions(chalk, options);\n\n    Object.setPrototypeOf(chalk, createChalk.prototype);\n\n    return chalk as ChalkInstance;\n};\n\nfunction createChalk(options?: Options): ChalkInstance {\n    return chalkFactory(options);\n}\n\nObject.setPrototypeOf(createChalk.prototype, Function.prototype);\n\nfor (const [styleName, style] of Object.entries(ansiStyles)) {\n    styles[styleName] = {\n        get() {\n            const builder = createBuilder(\n                this,\n                createStyler(style.open, style.close, this[STYLER]),\n                this[IS_EMPTY]\n            );\n            Object.defineProperty(this, styleName, { value: builder });\n            return builder;\n        },\n    };\n}\n\nstyles.visible = {\n    get() {\n        const builder = createBuilder(this, this[STYLER], true);\n        Object.defineProperty(this, 'visible', { value: builder });\n        return builder;\n    },\n};\n\nconst getModelAnsi = (\n    model: any,\n    level: any,\n    type: any,\n    ...arguments_: any[]\n): any => {\n    if (model === 'rgb') {\n        if (level === 'ansi16m') {\n            // @ts-ignore\n            return ansiStyles[type].ansi16m(...arguments_);\n        }\n\n        if (level === 'ansi256') {\n            // @ts-ignore\n            return ansiStyles[type].ansi256(\n                // @ts-ignore\n                ansiStyles.rgbToAnsi256(...arguments_)\n            );\n        }\n\n        // @ts-ignore\n        return ansiStyles[type].ansi(ansiStyles.rgbToAnsi(...arguments_));\n    }\n\n    if (model === 'hex') {\n        return getModelAnsi(\n            'rgb',\n            level,\n            type,\n            // @ts-ignore\n            ...ansiStyles.hexToRgb(...arguments_)\n        );\n    }\n\n    // @ts-ignore\n    return ansiStyles[type][model](...arguments_);\n};\n\nconst usedModels = ['rgb', 'hex', 'ansi256'];\n\nfor (const model of usedModels) {\n    styles[model] = {\n        get() {\n            const { level } = this;\n            return function (...arguments_: any[]) {\n                const styler = createStyler(\n                    getModelAnsi(\n                        model,\n                        levelMapping[level],\n                        'color',\n                        ...arguments_\n                    ),\n                    ansiStyles.color.close,\n                    this[STYLER]\n                );\n                return createBuilder(this, styler, this[IS_EMPTY]);\n            };\n        },\n    };\n\n    const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);\n    styles[bgModel] = {\n        get() {\n            const { level } = this;\n            return function (...arguments_: any[]) {\n                const styler = createStyler(\n                    getModelAnsi(\n                        model,\n                        levelMapping[level],\n                        'bgColor',\n                        ...arguments_\n                    ),\n                    ansiStyles.bgColor.close,\n                    this[STYLER]\n                );\n                return createBuilder(this, styler, this[IS_EMPTY]);\n            };\n        },\n    };\n}\n\nconst proto = Object.defineProperties(() => {}, {\n    ...styles,\n    level: {\n        enumerable: true,\n        get() {\n            return this[GENERATOR].level;\n        },\n        set(level) {\n            this[GENERATOR].level = level;\n        },\n    },\n});\n\nconst createStyler = (open: any, close: any, parent: any) => {\n    let openAll;\n    let closeAll;\n    if (parent === undefined) {\n        openAll = open;\n        closeAll = close;\n    } else {\n        openAll = parent.openAll + open;\n        closeAll = close + parent.closeAll;\n    }\n\n    return {\n        open,\n        close,\n        openAll,\n        closeAll,\n        parent,\n    };\n};\n\nconst createBuilder = (self: any, _styler: any, _isEmpty: any) => {\n    // Single argument is hot path, implicit coercion is faster than anything\n    // eslint-disable-next-line no-implicit-coercion\n    const builder: any = (...arguments_: any[]) =>\n        applyStyle(\n            builder,\n            arguments_.length === 1 ? '' + arguments_[0] : arguments_.join(' ')\n        );\n\n    // We alter the prototype because we must return a function, but there is\n    // no way to create a function with a different prototype\n    Object.setPrototypeOf(builder, proto);\n\n    builder[GENERATOR] = self;\n    builder[STYLER] = _styler;\n    builder[IS_EMPTY] = _isEmpty;\n\n    return builder;\n};\n\nconst applyStyle = (self: any, string: string) => {\n    if (self.level <= 0 || !string) {\n        return self[IS_EMPTY] ? '' : string;\n    }\n\n    let styler = self[STYLER];\n\n    if (styler === undefined) {\n        return string;\n    }\n\n    const { openAll, closeAll } = styler;\n    if (string.includes('\\u001B')) {\n        while (styler !== undefined) {\n            // Replace any instances already present with a re-opening code\n            // otherwise only the part of the string until said closing code\n            // will be colored, and the rest will simply be 'plain'.\n            string = stringReplaceAll(string, styler.close, styler.open);\n\n            styler = styler.parent;\n        }\n    }\n\n    // We can move both next actions out of loop, because remaining actions in loop won't have\n    // any/visible effect on parts we add here. Close the styling before a linebreak and reopen\n    // after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92\n    const lfIndex = string.indexOf('\\n');\n    if (lfIndex !== -1) {\n        string = stringEncaseCRLFWithFirstIndex(\n            string,\n            closeAll,\n            openAll,\n            lfIndex\n        );\n    }\n\n    return openAll + string + closeAll;\n};\n\nObject.defineProperties(createChalk.prototype, styles);\n\nconst chalk = createChalk();\nexport const chalkStderr = createChalk({ level: 0 });\n\nexport default chalk;\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntype ValueType =\n    | 'array'\n    | 'bigint'\n    | 'boolean'\n    | 'function'\n    | 'null'\n    | 'number'\n    | 'object'\n    | 'regexp'\n    | 'map'\n    | 'set'\n    | 'date'\n    | 'string'\n    | 'symbol'\n    | 'undefined';\n\n// get the type of a value with handling the edge cases like `typeof []`\n// and `typeof null`\nexport function getType(value: unknown): ValueType {\n    if (value === undefined) {\n        return 'undefined';\n    } else if (value === null) {\n        return 'null';\n    } else if (Array.isArray(value)) {\n        return 'array';\n    } else if (typeof value === 'boolean') {\n        return 'boolean';\n    } else if (typeof value === 'function') {\n        return 'function';\n    } else if (typeof value === 'number') {\n        return 'number';\n    } else if (typeof value === 'string') {\n        return 'string';\n    } else if (typeof value === 'bigint') {\n        return 'bigint';\n    } else if (typeof value === 'object') {\n        if (value != null) {\n            if (value.constructor === RegExp) {\n                return 'regexp';\n            } else if (value.constructor === Map) {\n                return 'map';\n            } else if (value.constructor === Set) {\n                return 'set';\n            } else if (value.constructor === Date) {\n                return 'date';\n            }\n        }\n        return 'object';\n    } else if (typeof value === 'symbol') {\n        return 'symbol';\n    }\n\n    throw new Error(`value of unknown type: ${value}`);\n}\n\nexport const isPrimitive = (value: unknown): boolean => Object(value) !== value;\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type { CompareKeys, Config, Printer, Refs } from './types';\n\nconst getKeysOfEnumerableProperties = (\n    object: Record<string, unknown>,\n    compareKeys: CompareKeys\n) => {\n    const keys: Array<string | symbol> = Object.keys(object).sort(compareKeys);\n\n    if (Object.getOwnPropertySymbols) {\n        Object.getOwnPropertySymbols(object).forEach((symbol) => {\n            if (Object.getOwnPropertyDescriptor(object, symbol)!.enumerable) {\n                keys.push(symbol);\n            }\n        });\n    }\n\n    return keys as Array<string>;\n};\n\n/**\n * Return entries (for example, of a map)\n * with spacing, indentation, and comma\n * without surrounding punctuation (for example, braces)\n */\nexport function printIteratorEntries(\n    iterator: Iterator<[unknown, unknown]>,\n    config: Config,\n    indentation: string,\n    depth: number,\n    refs: Refs,\n    printer: Printer,\n    // Too bad, so sad that separator for ECMAScript Map has been ' => '\n    // What a distracting diff if you change a data structure to/from\n    // ECMAScript Object or Immutable.Map/OrderedMap which use the default.\n    separator: string = ': '\n): string {\n    let result = '';\n    let current = iterator.next();\n\n    if (!current.done) {\n        result += config.spacingOuter;\n\n        const indentationNext = indentation + config.indent;\n\n        while (!current.done) {\n            const name = printer(\n                current.value[0],\n                config,\n                indentationNext,\n                depth,\n                refs\n            );\n            const value = printer(\n                current.value[1],\n                config,\n                indentationNext,\n                depth,\n                refs\n            );\n\n            result += indentationNext + name + separator + value;\n\n            current = iterator.next();\n\n            if (!current.done) {\n                result += ',' + config.spacingInner;\n            } else if (!config.min) {\n                result += ',';\n            }\n        }\n\n        result += config.spacingOuter + indentation;\n    }\n\n    return result;\n}\n\n/**\n * Return values (for example, of a set)\n * with spacing, indentation, and comma\n * without surrounding punctuation (braces or brackets)\n */\nexport function printIteratorValues(\n    iterator: Iterator<unknown>,\n    config: Config,\n    indentation: string,\n    depth: number,\n    refs: Refs,\n    printer: Printer\n): string {\n    let result = '';\n    let current = iterator.next();\n\n    if (!current.done) {\n        result += config.spacingOuter;\n\n        const indentationNext = indentation + config.indent;\n\n        while (!current.done) {\n            result +=\n                indentationNext +\n                printer(current.value, config, indentationNext, depth, refs);\n\n            current = iterator.next();\n\n            if (!current.done) {\n                result += ',' + config.spacingInner;\n            } else if (!config.min) {\n                result += ',';\n            }\n        }\n\n        result += config.spacingOuter + indentation;\n    }\n\n    return result;\n}\n\n/**\n * Return items (for example, of an array)\n * with spacing, indentation, and comma\n * without surrounding punctuation (for example, brackets)\n **/\nexport function printListItems(\n    list: ArrayLike<unknown>,\n    config: Config,\n    indentation: string,\n    depth: number,\n    refs: Refs,\n    printer: Printer\n): string {\n    let result = '';\n\n    if (list.length) {\n        result += config.spacingOuter;\n\n        const indentationNext = indentation + config.indent;\n\n        for (let i = 0; i < list.length; i++) {\n            result += indentationNext;\n\n            if (i in list) {\n                result += printer(\n                    list[i],\n                    config,\n                    indentationNext,\n                    depth,\n                    refs\n                );\n            }\n\n            if (i < list.length - 1) {\n                result += ',' + config.spacingInner;\n            } else if (!config.min) {\n                result += ',';\n            }\n        }\n\n        result += config.spacingOuter + indentation;\n    }\n\n    return result;\n}\n\n/**\n * Return properties of an object\n * with spacing, indentation, and comma\n * without surrounding punctuation (for example, braces)\n */\nexport function printObjectProperties(\n    val: Record<string, unknown>,\n    config: Config,\n    indentation: string,\n    depth: number,\n    refs: Refs,\n    printer: Printer\n): string {\n    let result = '';\n    const keys = getKeysOfEnumerableProperties(val, config.compareKeys);\n\n    if (keys.length) {\n        result += config.spacingOuter;\n\n        const indentationNext = indentation + config.indent;\n\n        for (let i = 0; i < keys.length; i++) {\n            const key = keys[i];\n            const name = printer(key, config, indentationNext, depth, refs);\n            const value = printer(\n                val[key],\n                config,\n                indentationNext,\n                depth,\n                refs\n            );\n\n            result += indentationNext + name + ': ' + value;\n\n            if (i < keys.length - 1) {\n                result += ',' + config.spacingInner;\n            } else if (!config.min) {\n                result += ',';\n            }\n        }\n\n        result += config.spacingOuter + indentation;\n    }\n\n    return result;\n}\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport { printListItems, printObjectProperties } from '../collections';\nimport type { Config, NewPlugin, Printer, Refs } from '../types';\n\nconst asymmetricMatcher =\n    typeof Symbol === 'function' && Symbol.for\n        ? Symbol.for('jest.asymmetricMatcher')\n        : 0x1357a5;\nconst SPACE = ' ';\n\nexport const serialize: NewPlugin['serialize'] = (\n    val: any,\n    config: Config,\n    indentation: string,\n    depth: number,\n    refs: Refs,\n    printer: Printer\n) => {\n    const stringedValue = val.toString();\n\n    if (\n        stringedValue === 'ArrayContaining' ||\n        stringedValue === 'ArrayNotContaining'\n    ) {\n        if (++depth > config.maxDepth) {\n            return '[' + stringedValue + ']';\n        }\n        return (\n            stringedValue +\n            SPACE +\n            '[' +\n            printListItems(\n                val.sample,\n                config,\n                indentation,\n                depth,\n                refs,\n                printer\n            ) +\n            ']'\n        );\n    }\n\n    if (\n        stringedValue === 'ObjectContaining' ||\n        stringedValue === 'ObjectNotContaining'\n    ) {\n        if (++depth > config.maxDepth) {\n            return '[' + stringedValue + ']';\n        }\n        return (\n            stringedValue +\n            SPACE +\n            '{' +\n            printObjectProperties(\n                val.sample,\n                config,\n                indentation,\n                depth,\n                refs,\n                printer\n            ) +\n            '}'\n        );\n    }\n\n    if (\n        stringedValue === 'StringMatching' ||\n        stringedValue === 'StringNotMatching'\n    ) {\n        return (\n            stringedValue +\n            SPACE +\n            printer(val.sample, config, indentation, depth, refs)\n        );\n    }\n\n    if (\n        stringedValue === 'StringContaining' ||\n        stringedValue === 'StringNotContaining'\n    ) {\n        return (\n            stringedValue +\n            SPACE +\n            printer(val.sample, config, indentation, depth, refs)\n        );\n    }\n\n    return val.toAsymmetricMatcher();\n};\n\nexport const test: NewPlugin['test'] = (val: any) =>\n    val && val.$$typeof === asymmetricMatcher;\n\nconst plugin: NewPlugin = { serialize, test };\n\nexport default plugin;\n","/**\nRegular expression for matching ANSI escape codes.\n@example\n```\nimport ansiRegex from 'ansi-regex';\nansiRegex().test('\\u001B[4mcake\\u001B[0m');\n//=> true\nansiRegex().test('cake');\n//=> false\n'\\u001B[4mcake\\u001B[0m'.match(ansiRegex());\n//=> ['\\u001B[4m', '\\u001B[0m']\n'\\u001B[4mcake\\u001B[0m'.match(ansiRegex({onlyFirst: true}));\n//=> ['\\u001B[4m']\n'\\u001B]8;;https://github.com\\u0007click\\u001B]8;;\\u0007'.match(ansiRegex());\n//=> ['\\u001B]8;;https://github.com\\u0007', '\\u001B]8;;\\u0007']\n```\n*/\nexport default function ansiRegex({ onlyFirst = false } = {}): RegExp {\n    const pattern = [\n        '[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)',\n        '(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-nq-uy=><~]))',\n    ].join('|');\n\n    return new RegExp(pattern, onlyFirst ? undefined : 'g');\n}\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport ansiRegex from '@casual-simulation/chalk/ansi-regex';\nimport style from '@casual-simulation/chalk/ansi-styles';\nimport type { Config, NewPlugin, Printer, Refs } from '../types';\n\nconst toHumanReadableAnsi = (text: string) =>\n    text.replace(ansiRegex(), (match) => {\n        switch (match) {\n            case style.red.close:\n            case style.green.close:\n            case style.cyan.close:\n            case style.gray.close:\n            case style.white.close:\n            case style.yellow.close:\n            case style.bgRed.close:\n            case style.bgGreen.close:\n            case style.bgYellow.close:\n            case style.inverse.close:\n            case style.dim.close:\n            case style.bold.close:\n            case style.reset.open:\n            case style.reset.close:\n                return '</>';\n            case style.red.open:\n                return '<red>';\n            case style.green.open:\n                return '<green>';\n            case style.cyan.open:\n                return '<cyan>';\n            case style.gray.open:\n                return '<gray>';\n            case style.white.open:\n                return '<white>';\n            case style.yellow.open:\n                return '<yellow>';\n            case style.bgRed.open:\n                return '<bgRed>';\n            case style.bgGreen.open:\n                return '<bgGreen>';\n            case style.bgYellow.open:\n                return '<bgYellow>';\n            case style.inverse.open:\n                return '<inverse>';\n            case style.dim.open:\n                return '<dim>';\n            case style.bold.open:\n                return '<bold>';\n            default:\n                return '';\n        }\n    });\n\nexport const test: NewPlugin['test'] = (val: unknown) =>\n    typeof val === 'string' && !!val.match(ansiRegex());\n\nexport const serialize: NewPlugin['serialize'] = (\n    val: string,\n    config: Config,\n    indentation: string,\n    depth: number,\n    refs: Refs,\n    printer: Printer\n) => printer(toHumanReadableAnsi(val), config, indentation, depth, refs);\n\nconst plugin: NewPlugin = { serialize, test };\n\nexport default plugin;\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/* eslint-disable local/ban-types-eventually */\n\nimport { printListItems, printObjectProperties } from '../collections';\nimport type { Config, NewPlugin, Printer, Refs } from '../types';\n\nconst SPACE = ' ';\n\nconst OBJECT_NAMES = ['DOMStringMap', 'NamedNodeMap'];\nconst ARRAY_REGEXP = /^(HTML\\w*Collection|NodeList)$/;\n\nconst testName = (name: any) =>\n    OBJECT_NAMES.indexOf(name) !== -1 || ARRAY_REGEXP.test(name);\n\nexport const test: NewPlugin['test'] = (val: object) =>\n    val &&\n    val.constructor &&\n    !!val.constructor.name &&\n    testName(val.constructor.name);\n\nconst isNamedNodeMap = (collection: object): collection is NamedNodeMap =>\n    collection.constructor.name === 'NamedNodeMap';\n\nexport const serialize: NewPlugin['serialize'] = (\n    collection: any | NamedNodeMap,\n    config: Config,\n    indentation: string,\n    depth: number,\n    refs: Refs,\n    printer: Printer\n) => {\n    const name = collection.constructor.name;\n    if (++depth > config.maxDepth) {\n        return '[' + name + ']';\n    }\n\n    return (\n        (config.min ? '' : name + SPACE) +\n        (OBJECT_NAMES.indexOf(name) !== -1\n            ? '{' +\n              printObjectProperties(\n                  isNamedNodeMap(collection)\n                      ? Array.from(collection).reduce<Record<string, string>>(\n                            (props, attribute) => {\n                                props[attribute.name] = attribute.value;\n                                return props;\n                            },\n                            {}\n                        )\n                      : { ...collection },\n                  config,\n                  indentation,\n                  depth,\n                  refs,\n                  printer\n              ) +\n              '}'\n            : '[' +\n              printListItems(\n                  Array.from(collection),\n                  config,\n                  indentation,\n                  depth,\n                  refs,\n                  printer\n              ) +\n              ']')\n    );\n};\n\nconst plugin: NewPlugin = { serialize, test };\n\nexport default plugin;\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport default function escapeHTML(str: string): string {\n    return str.replace(/</g, '&lt;').replace(/>/g, '&gt;');\n}\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type { Config, Printer, Refs } from '../../types';\nimport escapeHTML from './escapeHTML';\n\n// Return empty string if keys is empty.\nexport const printProps = (\n    keys: Array<string>,\n    props: Record<string, unknown>,\n    config: Config,\n    indentation: string,\n    depth: number,\n    refs: Refs,\n    printer: Printer\n): string => {\n    const indentationNext = indentation + config.indent;\n    const colors = config.colors;\n    return keys\n        .map((key) => {\n            const value = props[key];\n            let printed = printer(value, config, indentationNext, depth, refs);\n\n            if (typeof value !== 'string') {\n                if (printed.indexOf('\\n') !== -1) {\n                    printed =\n                        config.spacingOuter +\n                        indentationNext +\n                        printed +\n                        config.spacingOuter +\n                        indentation;\n                }\n                printed = '{' + printed + '}';\n            }\n\n            return (\n                config.spacingInner +\n                indentation +\n                colors.prop.open +\n                key +\n                colors.prop.close +\n                '=' +\n                colors.value.open +\n                printed +\n                colors.value.close\n            );\n        })\n        .join('');\n};\n\n// Return empty string if children is empty.\nexport const printChildren = (\n    children: Array<unknown>,\n    config: Config,\n    indentation: string,\n    depth: number,\n    refs: Refs,\n    printer: Printer\n): string =>\n    children\n        .map(\n            (child) =>\n                config.spacingOuter +\n                indentation +\n                (typeof child === 'string'\n                    ? printText(child, config)\n                    : printer(child, config, indentation, depth, refs))\n        )\n        .join('');\n\nexport const printText = (text: string, config: Config): string => {\n    const contentColor = config.colors.content;\n    return contentColor.open + escapeHTML(text) + contentColor.close;\n};\n\nexport const printComment = (comment: string, config: Config): string => {\n    const commentColor = config.colors.comment;\n    return (\n        commentColor.open +\n        '<!--' +\n        escapeHTML(comment) +\n        '-->' +\n        commentColor.close\n    );\n};\n\n// Separate the functions to format props, children, and element,\n// so a plugin could override a particular function, if needed.\n// Too bad, so sad: the traditional (but unnecessary) space\n// in a self-closing tagColor requires a second test of printedProps.\nexport const printElement = (\n    type: string,\n    printedProps: string,\n    printedChildren: string,\n    config: Config,\n    indentation: string\n): string => {\n    const tagColor = config.colors.tag;\n    return (\n        tagColor.open +\n        '<' +\n        type +\n        (printedProps &&\n            tagColor.close +\n                printedProps +\n                config.spacingOuter +\n                indentation +\n                tagColor.open) +\n        (printedChildren\n            ? '>' +\n              tagColor.close +\n              printedChildren +\n              config.spacingOuter +\n              indentation +\n              tagColor.open +\n              '</' +\n              type\n            : (printedProps && !config.min ? '' : ' ') + '/') +\n        '>' +\n        tagColor.close\n    );\n};\n\nexport const printElementAsLeaf = (type: string, config: Config): string => {\n    const tagColor = config.colors.tag;\n    return (\n        tagColor.open +\n        '<' +\n        type +\n        tagColor.close +\n        ' ' +\n        tagColor.open +\n        ' />' +\n        tagColor.close\n    );\n};\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type { Config, NewPlugin, Printer, Refs } from '../types';\nimport {\n    printChildren,\n    printComment,\n    printElement,\n    printElementAsLeaf,\n    printProps,\n    printText,\n} from './lib/markup';\n\nconst ELEMENT_NODE = 1;\nconst TEXT_NODE = 3;\nconst COMMENT_NODE = 8;\nconst FRAGMENT_NODE = 11;\n\nconst ELEMENT_REGEXP = /^((HTML|SVG)\\w*)?Element$/;\n\nconst testHasAttribute = (val: any) => {\n    try {\n        return typeof val.hasAttribute === 'function' && val.hasAttribute('is');\n    } catch {\n        return false;\n    }\n};\n\nconst testNode = (val: any) => {\n    const constructorName = val.constructor.name;\n    const { nodeType, tagName } = val;\n    const isCustomElement =\n        (typeof tagName === 'string' && tagName.includes('-')) ||\n        testHasAttribute(val);\n\n    return (\n        (nodeType === ELEMENT_NODE &&\n            (ELEMENT_REGEXP.test(constructorName) || isCustomElement)) ||\n        (nodeType === TEXT_NODE && constructorName === 'Text') ||\n        (nodeType === COMMENT_NODE && constructorName === 'Comment') ||\n        (nodeType === FRAGMENT_NODE && constructorName === 'DocumentFragment')\n    );\n};\n\nexport const test: NewPlugin['test'] = (val: any) =>\n    val?.constructor?.name && testNode(val);\n\ntype HandledType = Element | Text | Comment | DocumentFragment;\n\nfunction nodeIsText(node: HandledType): node is Text {\n    return node.nodeType === TEXT_NODE;\n}\n\nfunction nodeIsComment(node: HandledType): node is Comment {\n    return node.nodeType === COMMENT_NODE;\n}\n\nfunction nodeIsFragment(node: HandledType): node is DocumentFragment {\n    return node.nodeType === FRAGMENT_NODE;\n}\n\nexport const serialize: NewPlugin['serialize'] = (\n    node: HandledType,\n    config: Config,\n    indentation: string,\n    depth: number,\n    refs: Refs,\n    printer: Printer\n) => {\n    if (nodeIsText(node)) {\n        return printText(node.data, config);\n    }\n\n    if (nodeIsComment(node)) {\n        return printComment(node.data, config);\n    }\n\n    const type = nodeIsFragment(node)\n        ? `DocumentFragment`\n        : node.tagName.toLowerCase();\n\n    if (++depth > config.maxDepth) {\n        return printElementAsLeaf(type, config);\n    }\n\n    return printElement(\n        type,\n        printProps(\n            nodeIsFragment(node)\n                ? []\n                : Array.from(node.attributes)\n                      .map((attr) => attr.name)\n                      .sort(),\n            nodeIsFragment(node)\n                ? {}\n                : Array.from(node.attributes).reduce<Record<string, string>>(\n                      (props, attribute) => {\n                          props[attribute.name] = attribute.value;\n                          return props;\n                      },\n                      {}\n                  ),\n            config,\n            indentation + config.indent,\n            depth,\n            refs,\n            printer\n        ),\n        printChildren(\n            Array.prototype.slice.call(node.childNodes || node.children),\n            config,\n            indentation + config.indent,\n            depth,\n            refs,\n            printer\n        ),\n        config,\n        indentation\n    );\n};\n\nconst plugin: NewPlugin = { serialize, test };\n\nexport default plugin;\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport { printIteratorEntries, printIteratorValues } from '../collections';\nimport type { Config, NewPlugin, Printer, Refs } from '../types';\n\n// SENTINEL constants are from https://github.com/facebook/immutable-js\nconst IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\nconst IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';\nconst IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\nconst IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';\nconst IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\nconst IS_RECORD_SENTINEL = '@@__IMMUTABLE_RECORD__@@'; // immutable v4\nconst IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';\nconst IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';\nconst IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';\n\nconst getImmutableName = (name: string) => 'Immutable.' + name;\nconst printAsLeaf = (name: string) => '[' + name + ']';\nconst SPACE = ' ';\nconst LAZY = ''; // Seq is lazy if it calls a method like filter\n\nconst printImmutableEntries = (\n    val: any,\n    config: Config,\n    indentation: string,\n    depth: number,\n    refs: Refs,\n    printer: Printer,\n    type: string\n): string =>\n    ++depth > config.maxDepth\n        ? printAsLeaf(getImmutableName(type))\n        : getImmutableName(type) +\n          SPACE +\n          '{' +\n          printIteratorEntries(\n              val.entries(),\n              config,\n              indentation,\n              depth,\n              refs,\n              printer\n          ) +\n          '}';\n\n// Record has an entries method because it is a collection in immutable v3.\n// Return an iterator for Immutable Record from version v3 or v4.\nfunction getRecordEntries(val: any): Iterator<any> {\n    let i = 0;\n    return {\n        next() {\n            if (i < val._keys.length) {\n                const key = val._keys[i++];\n                return { done: false, value: [key, val.get(key)] };\n            }\n            return { done: true, value: undefined };\n        },\n    };\n}\n\nconst printImmutableRecord = (\n    val: any,\n    config: Config,\n    indentation: string,\n    depth: number,\n    refs: Refs,\n    printer: Printer\n): string => {\n    // _name property is defined only for an Immutable Record instance\n    // which was constructed with a second optional descriptive name arg\n    const name = getImmutableName(val._name || 'Record');\n    return ++depth > config.maxDepth\n        ? printAsLeaf(name)\n        : name +\n              SPACE +\n              '{' +\n              printIteratorEntries(\n                  getRecordEntries(val),\n                  config,\n                  indentation,\n                  depth,\n                  refs,\n                  printer\n              ) +\n              '}';\n};\n\nconst printImmutableSeq = (\n    val: any,\n    config: Config,\n    indentation: string,\n    depth: number,\n    refs: Refs,\n    printer: Printer\n): string => {\n    const name = getImmutableName('Seq');\n\n    if (++depth > config.maxDepth) {\n        return printAsLeaf(name);\n    }\n\n    if (val[IS_KEYED_SENTINEL]) {\n        return (\n            name +\n            SPACE +\n            '{' +\n            // from Immutable collection of entries or from ECMAScript object\n            (val._iter || val._object\n                ? printIteratorEntries(\n                      val.entries(),\n                      config,\n                      indentation,\n                      depth,\n                      refs,\n                      printer\n                  )\n                : LAZY) +\n            '}'\n        );\n    }\n\n    return (\n        name +\n        SPACE +\n        '[' +\n        (val._iter || // from Immutable collection of values\n        val._array || // from ECMAScript array\n        val._collection || // from ECMAScript collection in immutable v4\n        val._iterable // from ECMAScript collection in immutable v3\n            ? printIteratorValues(\n                  val.values(),\n                  config,\n                  indentation,\n                  depth,\n                  refs,\n                  printer\n              )\n            : LAZY) +\n        ']'\n    );\n};\n\nconst printImmutableValues = (\n    val: any,\n    config: Config,\n    indentation: string,\n    depth: number,\n    refs: Refs,\n    printer: Printer,\n    type: string\n): string =>\n    ++depth > config.maxDepth\n        ? printAsLeaf(getImmutableName(type))\n        : getImmutableName(type) +\n          SPACE +\n          '[' +\n          printIteratorValues(\n              val.values(),\n              config,\n              indentation,\n              depth,\n              refs,\n              printer\n          ) +\n          ']';\n\nexport const serialize: NewPlugin['serialize'] = (\n    val: any,\n    config: Config,\n    indentation: string,\n    depth: number,\n    refs: Refs,\n    printer: Printer\n) => {\n    if (val[IS_MAP_SENTINEL]) {\n        return printImmutableEntries(\n            val,\n            config,\n            indentation,\n            depth,\n            refs,\n            printer,\n            val[IS_ORDERED_SENTINEL] ? 'OrderedMap' : 'Map'\n        );\n    }\n\n    if (val[IS_LIST_SENTINEL]) {\n        return printImmutableValues(\n            val,\n            config,\n            indentation,\n            depth,\n            refs,\n            printer,\n            'List'\n        );\n    }\n    if (val[IS_SET_SENTINEL]) {\n        return printImmutableValues(\n            val,\n            config,\n            indentation,\n            depth,\n            refs,\n            printer,\n            val[IS_ORDERED_SENTINEL] ? 'OrderedSet' : 'Set'\n        );\n    }\n    if (val[IS_STACK_SENTINEL]) {\n        return printImmutableValues(\n            val,\n            config,\n            indentation,\n            depth,\n            refs,\n            printer,\n            'Stack'\n        );\n    }\n\n    if (val[IS_SEQ_SENTINEL]) {\n        return printImmutableSeq(\n            val,\n            config,\n            indentation,\n            depth,\n            refs,\n            printer\n        );\n    }\n\n    // For compatibility with immutable v3 and v4, let record be the default.\n    return printImmutableRecord(val, config, indentation, depth, refs, printer);\n};\n\n// Explicitly comparing sentinel properties to true avoids false positive\n// when mock identity-obj-proxy returns the key as the value for any key.\nexport const test: NewPlugin['test'] = (val: any) =>\n    val &&\n    (val[IS_ITERABLE_SENTINEL] === true || val[IS_RECORD_SENTINEL] === true);\n\nconst plugin: NewPlugin = { serialize, test };\n\nexport default plugin;\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type { Config, NewPlugin, Printer, Refs } from '../types';\nimport {\n    printChildren,\n    printElement,\n    printElementAsLeaf,\n    printProps,\n} from './lib/markup';\n\nexport type ReactTestObject = {\n    $$typeof: symbol;\n    type: string;\n    props?: Record<string, unknown>;\n    children?: null | Array<ReactTestChild>;\n};\n\n// Child can be `number` in Stack renderer but not in Fiber renderer.\ntype ReactTestChild = ReactTestObject | string | number;\n\nconst testSymbol =\n    typeof Symbol === 'function' && Symbol.for\n        ? Symbol.for('react.test.json')\n        : 0xea71357;\n\nconst getPropKeys = (object: ReactTestObject) => {\n    const { props } = object;\n\n    return props\n        ? Object.keys(props)\n              .filter((key) => props[key] !== undefined)\n              .sort()\n        : [];\n};\n\nexport const serialize: NewPlugin['serialize'] = (\n    object: ReactTestObject,\n    config: Config,\n    indentation: string,\n    depth: number,\n    refs: Refs,\n    printer: Printer\n) =>\n    ++depth > config.maxDepth\n        ? printElementAsLeaf(object.type, config)\n        : printElement(\n              object.type,\n              object.props\n                  ? printProps(\n                        getPropKeys(object),\n                        object.props,\n                        config,\n                        indentation + config.indent,\n                        depth,\n                        refs,\n                        printer\n                    )\n                  : '',\n              object.children\n                  ? printChildren(\n                        object.children,\n                        config,\n                        indentation + config.indent,\n                        depth,\n                        refs,\n                        printer\n                    )\n                  : '',\n              config,\n              indentation\n          );\n\nexport const test: NewPlugin['test'] = (val) =>\n    val && val.$$typeof === testSymbol;\n\nconst plugin: NewPlugin = { serialize, test };\n\nexport default plugin;\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/* eslint-disable local/ban-types-eventually */\n\nimport style from '@casual-simulation/chalk/ansi-styles';\nimport {\n    printIteratorEntries,\n    printIteratorValues,\n    printListItems,\n    printObjectProperties,\n} from './collections';\nimport AsymmetricMatcher from './plugins/AsymmetricMatcher';\nimport ConvertAnsi from './plugins/ConvertAnsi';\nimport DOMCollection from './plugins/DOMCollection';\nimport DOMElement from './plugins/DOMElement';\nimport Immutable from './plugins/Immutable';\nimport ReactTestComponent from './plugins/ReactTestComponent';\nimport type {\n    Colors,\n    Config,\n    NewPlugin,\n    Options,\n    OptionsReceived,\n    Plugin,\n    Plugins,\n    Refs,\n    Theme,\n} from './types';\n\nexport type {\n    Colors,\n    CompareKeys,\n    Config,\n    Options,\n    OptionsReceived,\n    OldPlugin,\n    NewPlugin,\n    Plugin,\n    Plugins,\n    PrettyFormatOptions,\n    Printer,\n    Refs,\n    Theme,\n} from './types';\n\nconst toString = Object.prototype.toString;\nconst toISOString = Date.prototype.toISOString;\nconst errorToString = Error.prototype.toString;\nconst regExpToString = RegExp.prototype.toString;\n\n/**\n * Explicitly comparing typeof constructor to function avoids undefined as name\n * when mock identity-obj-proxy returns the key as the value for any key.\n */\nconst getConstructorName = (val: new (...args: Array<any>) => unknown) =>\n    (typeof val.constructor === 'function' && val.constructor.name) || 'Object';\n\n/* global window */\n/** Is val is equal to global window object? Works even if it does not exist :) */\nconst isWindow = (val: unknown) =>\n    typeof window !== 'undefined' && val === window;\n\nconst SYMBOL_REGEXP = /^Symbol\\((.*)\\)(.*)$/;\nconst NEWLINE_REGEXP = /\\n/gi;\n\nclass PrettyFormatPluginError extends Error {\n    constructor(message: string, stack: string) {\n        super(message);\n        this.stack = stack;\n        this.name = this.constructor.name;\n    }\n}\n\nfunction isToStringedArrayType(toStringed: string): boolean {\n    return (\n        toStringed === '[object Array]' ||\n        toStringed === '[object ArrayBuffer]' ||\n        toStringed === '[object DataView]' ||\n        toStringed === '[object Float32Array]' ||\n        toStringed === '[object Float64Array]' ||\n        toStringed === '[object Int8Array]' ||\n        toStringed === '[object Int16Array]' ||\n        toStringed === '[object Int32Array]' ||\n        toStringed === '[object Uint8Array]' ||\n        toStringed === '[object Uint8ClampedArray]' ||\n        toStringed === '[object Uint16Array]' ||\n        toStringed === '[object Uint32Array]'\n    );\n}\n\nfunction printNumber(val: number): string {\n    return Object.is(val, -0) ? '-0' : String(val);\n}\n\nfunction printBigInt(val: bigint): string {\n    return String(`${val}n`);\n}\n\nfunction printFunction(val: Function, printFunctionName: boolean): string {\n    if (!printFunctionName) {\n        return '[Function]';\n    }\n    return '[Function ' + (val.name || 'anonymous') + ']';\n}\n\nfunction printSymbol(val: symbol): string {\n    return String(val).replace(SYMBOL_REGEXP, 'Symbol($1)');\n}\n\nfunction printError(val: Error): string {\n    return '[' + errorToString.call(val) + ']';\n}\n\n/**\n * The first port of call for printing an object, handles most of the\n * data-types in JS.\n */\nfunction printBasicValue(\n    val: any,\n    printFunctionName: boolean,\n    escapeRegex: boolean,\n    escapeString: boolean\n): string | null {\n    if (val === true || val === false) {\n        return '' + val;\n    }\n    if (val === undefined) {\n        return 'undefined';\n    }\n    if (val === null) {\n        return 'null';\n    }\n\n    const typeOf = typeof val;\n\n    if (typeOf === 'number') {\n        return printNumber(val);\n    }\n    if (typeOf === 'bigint') {\n        return printBigInt(val);\n    }\n    if (typeOf === 'string') {\n        if (escapeString) {\n            return '\"' + val.replace(/\"|\\\\/g, '\\\\$&') + '\"';\n        }\n        return '\"' + val + '\"';\n    }\n    if (typeOf === 'function') {\n        return printFunction(val, printFunctionName);\n    }\n    if (typeOf === 'symbol') {\n        return printSymbol(val);\n    }\n\n    const toStringed = toString.call(val);\n\n    if (toStringed === '[object WeakMap]') {\n        return 'WeakMap {}';\n    }\n    if (toStringed === '[object WeakSet]') {\n        return 'WeakSet {}';\n    }\n    if (\n        toStringed === '[object Function]' ||\n        toStringed === '[object GeneratorFunction]'\n    ) {\n        return printFunction(val, printFunctionName);\n    }\n    if (toStringed === '[object Symbol]') {\n        return printSymbol(val);\n    }\n    if (toStringed === '[object Date]') {\n        return isNaN(+val) ? 'Date { NaN }' : toISOString.call(val);\n    }\n    if (toStringed === '[object Error]') {\n        return printError(val);\n    }\n    if (toStringed === '[object RegExp]') {\n        if (escapeRegex) {\n            // https://github.com/benjamingr/RegExp.escape/blob/main/polyfill.js\n            return regExpToString\n                .call(val)\n                .replace(/[\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n        }\n        return regExpToString.call(val);\n    }\n\n    if (val instanceof Error) {\n        return printError(val);\n    }\n\n    return null;\n}\n\n/**\n * Handles more complex objects ( such as objects with circular references.\n * maps and sets etc )\n */\nfunction printComplexValue(\n    val: any,\n    config: Config,\n    indentation: string,\n    depth: number,\n    refs: Refs,\n    hasCalledToJSON?: boolean\n): string {\n    if (refs.indexOf(val) !== -1) {\n        return '[Circular]';\n    }\n    refs = refs.slice();\n    refs.push(val);\n\n    const hitMaxDepth = ++depth > config.maxDepth;\n    const min = config.min;\n\n    if (\n        config.callToJSON &&\n        !hitMaxDepth &&\n        val.toJSON &&\n        typeof val.toJSON === 'function' &&\n        !hasCalledToJSON\n    ) {\n        return printer(val.toJSON(), config, indentation, depth, refs, true);\n    }\n\n    const toStringed = toString.call(val);\n    if (toStringed === '[object Arguments]') {\n        return hitMaxDepth\n            ? '[Arguments]'\n            : (min ? '' : 'Arguments ') +\n                  '[' +\n                  printListItems(\n                      val,\n                      config,\n                      indentation,\n                      depth,\n                      refs,\n                      printer\n                  ) +\n                  ']';\n    }\n    if (isToStringedArrayType(toStringed)) {\n        return hitMaxDepth\n            ? '[' + val.constructor.name + ']'\n            : (min\n                  ? ''\n                  : !config.printBasicPrototype &&\n                    val.constructor.name === 'Array'\n                  ? ''\n                  : val.constructor.name + ' ') +\n                  '[' +\n                  printListItems(\n                      val,\n                      config,\n                      indentation,\n                      depth,\n                      refs,\n                      printer\n                  ) +\n                  ']';\n    }\n    if (toStringed === '[object Map]') {\n        return hitMaxDepth\n            ? '[Map]'\n            : 'Map {' +\n                  printIteratorEntries(\n                      val.entries(),\n                      config,\n                      indentation,\n                      depth,\n                      refs,\n                      printer,\n                      ' => '\n                  ) +\n                  '}';\n    }\n    if (toStringed === '[object Set]') {\n        return hitMaxDepth\n            ? '[Set]'\n            : 'Set {' +\n                  printIteratorValues(\n                      val.values(),\n                      config,\n                      indentation,\n                      depth,\n                      refs,\n                      printer\n                  ) +\n                  '}';\n    }\n\n    // Avoid failure to serialize global window object in jsdom test environment.\n    // For example, not even relevant if window is prop of React element.\n    return hitMaxDepth || isWindow(val)\n        ? '[' + getConstructorName(val) + ']'\n        : (min\n              ? ''\n              : !config.printBasicPrototype &&\n                getConstructorName(val) === 'Object'\n              ? ''\n              : getConstructorName(val) + ' ') +\n              '{' +\n              printObjectProperties(\n                  val,\n                  config,\n                  indentation,\n                  depth,\n                  refs,\n                  printer\n              ) +\n              '}';\n}\n\nfunction isNewPlugin(plugin: Plugin): plugin is NewPlugin {\n    return (plugin as NewPlugin).serialize != null;\n}\n\nfunction printPlugin(\n    plugin: Plugin,\n    val: any,\n    config: Config,\n    indentation: string,\n    depth: number,\n    refs: Refs\n): string {\n    let printed;\n\n    try {\n        printed = isNewPlugin(plugin)\n            ? plugin.serialize(val, config, indentation, depth, refs, printer)\n            : plugin.print(\n                  val,\n                  (valChild) =>\n                      printer(valChild, config, indentation, depth, refs),\n                  (str) => {\n                      const indentationNext = indentation + config.indent;\n                      return (\n                          indentationNext +\n                          str.replace(NEWLINE_REGEXP, '\\n' + indentationNext)\n                      );\n                  },\n                  {\n                      edgeSpacing: config.spacingOuter,\n                      min: config.min,\n                      spacing: config.spacingInner,\n                  },\n                  config.colors\n              );\n    } catch (error: any) {\n        throw new PrettyFormatPluginError(error.message, error.stack);\n    }\n    if (typeof printed !== 'string') {\n        throw new Error(\n            `pretty-format: Plugin must return type \"string\" but instead returned \"${typeof printed}\".`\n        );\n    }\n    return printed;\n}\n\nfunction findPlugin(plugins: Plugins, val: unknown) {\n    for (let p = 0; p < plugins.length; p++) {\n        try {\n            if (plugins[p].test(val)) {\n                return plugins[p];\n            }\n        } catch (error: any) {\n            throw new PrettyFormatPluginError(error.message, error.stack);\n        }\n    }\n\n    return null;\n}\n\nfunction printer(\n    val: unknown,\n    config: Config,\n    indentation: string,\n    depth: number,\n    refs: Refs,\n    hasCalledToJSON?: boolean\n): string {\n    const plugin = findPlugin(config.plugins, val);\n    if (plugin !== null) {\n        return printPlugin(plugin, val, config, indentation, depth, refs);\n    }\n\n    const basicResult = printBasicValue(\n        val,\n        config.printFunctionName,\n        config.escapeRegex,\n        config.escapeString\n    );\n    if (basicResult !== null) {\n        return basicResult;\n    }\n\n    return printComplexValue(\n        val,\n        config,\n        indentation,\n        depth,\n        refs,\n        hasCalledToJSON\n    );\n}\n\nconst DEFAULT_THEME: Theme = {\n    comment: 'gray',\n    content: 'reset',\n    prop: 'yellow',\n    tag: 'cyan',\n    value: 'green',\n};\n\nconst DEFAULT_THEME_KEYS = Object.keys(DEFAULT_THEME) as Array<\n    keyof typeof DEFAULT_THEME\n>;\n\nexport const DEFAULT_OPTIONS: Options = {\n    callToJSON: true,\n    compareKeys: undefined,\n    escapeRegex: false,\n    escapeString: true,\n    highlight: false,\n    indent: 2,\n    maxDepth: Infinity,\n    min: false,\n    plugins: [],\n    printBasicPrototype: true,\n    printFunctionName: true,\n    theme: DEFAULT_THEME,\n};\n\nfunction validateOptions(options: OptionsReceived) {\n    Object.keys(options).forEach((key) => {\n        if (!DEFAULT_OPTIONS.hasOwnProperty(key)) {\n            throw new Error(`pretty-format: Unknown option \"${key}\".`);\n        }\n    });\n\n    if (options.min && options.indent !== undefined && options.indent !== 0) {\n        throw new Error(\n            'pretty-format: Options \"min\" and \"indent\" cannot be used together.'\n        );\n    }\n\n    if (options.theme !== undefined) {\n        if (options.theme === null) {\n            throw new Error(`pretty-format: Option \"theme\" must not be null.`);\n        }\n\n        if (typeof options.theme !== 'object') {\n            throw new Error(\n                `pretty-format: Option \"theme\" must be of type \"object\" but instead received \"${typeof options.theme}\".`\n            );\n        }\n    }\n}\n\nconst getColorsHighlight = (options: OptionsReceived): Colors =>\n    DEFAULT_THEME_KEYS.reduce((colors, key) => {\n        const value =\n            options.theme && options.theme[key] !== undefined\n                ? options.theme[key]\n                : DEFAULT_THEME[key];\n        const color = value && (style as any)[value];\n        if (\n            color &&\n            typeof color.close === 'string' &&\n            typeof color.open === 'string'\n        ) {\n            colors[key] = color;\n        } else {\n            throw new Error(\n                `pretty-format: Option \"theme\" has a key \"${key}\" whose value \"${value}\" is undefined in ansi-styles.`\n            );\n        }\n        return colors;\n    }, Object.create(null));\n\nconst getColorsEmpty = (): Colors =>\n    DEFAULT_THEME_KEYS.reduce((colors, key) => {\n        colors[key] = { close: '', open: '' };\n        return colors;\n    }, Object.create(null));\n\nconst getPrintFunctionName = (options?: OptionsReceived) =>\n    options && options.printFunctionName !== undefined\n        ? options.printFunctionName\n        : DEFAULT_OPTIONS.printFunctionName;\n\nconst getEscapeRegex = (options?: OptionsReceived) =>\n    options && options.escapeRegex !== undefined\n        ? options.escapeRegex\n        : DEFAULT_OPTIONS.escapeRegex;\n\nconst getEscapeString = (options?: OptionsReceived) =>\n    options && options.escapeString !== undefined\n        ? options.escapeString\n        : DEFAULT_OPTIONS.escapeString;\n\nconst getConfig = (options?: OptionsReceived): Config => ({\n    callToJSON:\n        options && options.callToJSON !== undefined\n            ? options.callToJSON\n            : DEFAULT_OPTIONS.callToJSON,\n    colors:\n        options && options.highlight\n            ? getColorsHighlight(options)\n            : getColorsEmpty(),\n    compareKeys:\n        options && typeof options.compareKeys === 'function'\n            ? options.compareKeys\n            : DEFAULT_OPTIONS.compareKeys,\n    escapeRegex: getEscapeRegex(options),\n    escapeString: getEscapeString(options),\n    indent:\n        options && options.min\n            ? ''\n            : createIndent(\n                  options && options.indent !== undefined\n                      ? options.indent\n                      : DEFAULT_OPTIONS.indent\n              ),\n    maxDepth:\n        options && options.maxDepth !== undefined\n            ? options.maxDepth\n            : DEFAULT_OPTIONS.maxDepth,\n    min:\n        options && options.min !== undefined\n            ? options.min\n            : DEFAULT_OPTIONS.min,\n    plugins:\n        options && options.plugins !== undefined\n            ? options.plugins\n            : DEFAULT_OPTIONS.plugins,\n    printBasicPrototype: options?.printBasicPrototype ?? true,\n    printFunctionName: getPrintFunctionName(options),\n    spacingInner: options && options.min ? ' ' : '\\n',\n    spacingOuter: options && options.min ? '' : '\\n',\n});\n\nfunction createIndent(indent: number): string {\n    return new Array(indent + 1).join(' ');\n}\n\n/**\n * Returns a presentation string of your `val` object\n * @param val any potential JavaScript object\n * @param options Custom settings\n */\nexport function format(val: unknown, options?: OptionsReceived): string {\n    if (options) {\n        validateOptions(options);\n        if (options.plugins) {\n            const plugin = findPlugin(options.plugins, val);\n            if (plugin !== null) {\n                return printPlugin(plugin, val, getConfig(options), '', 0, []);\n            }\n        }\n    }\n\n    const basicResult = printBasicValue(\n        val,\n        getPrintFunctionName(options),\n        getEscapeRegex(options),\n        getEscapeString(options)\n    );\n    if (basicResult !== null) {\n        return basicResult;\n    }\n\n    return printComplexValue(val, getConfig(options), '', 0, []);\n}\n\nexport const plugins = {\n    AsymmetricMatcher,\n    ConvertAnsi,\n    DOMCollection,\n    DOMElement,\n    Immutable,\n    ReactTestComponent,\n};\n\nexport default format;\n","/**\n * Diff Match and Patch\n * Copyright 2018 The diff-match-patch Authors.\n * https://github.com/google/diff-match-patch\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Computes the difference between two texts to create a patch.\n * Applies the patch onto another text, allowing for errors.\n * @author fraser@google.com (Neil Fraser)\n */\n\n/**\n * CHANGES by pedrottimark to diff_match_patch_uncompressed.ts file:\n *\n * 1. Delete anything not needed to use diff_cleanupSemantic method\n * 2. Convert from prototype properties to var declarations\n * 3. Convert Diff to class from constructor and prototype\n * 4. Add type annotations for arguments and return values\n * 5. Add exports\n */\n\n/**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n */\nvar DIFF_DELETE = -1;\nvar DIFF_INSERT = 1;\nvar DIFF_EQUAL = 0;\n\n/**\n * Class representing one diff tuple.\n * Attempts to look like a two-element array (which is what this used to be).\n * @param {number} op Operation, one of: DIFF_DELETE, DIFF_INSERT, DIFF_EQUAL.\n * @param {string} text Text to be deleted, inserted, or retained.\n * @constructor\n */\nclass Diff {\n    0: number;\n    1: string;\n\n    constructor(op: number, text: string) {\n        this[0] = op;\n        this[1] = text;\n    }\n}\n\n/**\n * Determine the common prefix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the start of each\n *     string.\n */\nvar diff_commonPrefix = function (text1: string, text2: string): number {\n    // Quick check for common null cases.\n    if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\n        return 0;\n    }\n    // Binary search.\n    // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n    var pointermin = 0;\n    var pointermax = Math.min(text1.length, text2.length);\n    var pointermid = pointermax;\n    var pointerstart = 0;\n    while (pointermin < pointermid) {\n        if (\n            text1.substring(pointerstart, pointermid) ==\n            text2.substring(pointerstart, pointermid)\n        ) {\n            pointermin = pointermid;\n            pointerstart = pointermin;\n        } else {\n            pointermax = pointermid;\n        }\n        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n    }\n    return pointermid;\n};\n\n/**\n * Determine the common suffix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of each string.\n */\nvar diff_commonSuffix = function (text1: string, text2: string): number {\n    // Quick check for common null cases.\n    if (\n        !text1 ||\n        !text2 ||\n        text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)\n    ) {\n        return 0;\n    }\n    // Binary search.\n    // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n    var pointermin = 0;\n    var pointermax = Math.min(text1.length, text2.length);\n    var pointermid = pointermax;\n    var pointerend = 0;\n    while (pointermin < pointermid) {\n        if (\n            text1.substring(\n                text1.length - pointermid,\n                text1.length - pointerend\n            ) ==\n            text2.substring(\n                text2.length - pointermid,\n                text2.length - pointerend\n            )\n        ) {\n            pointermin = pointermid;\n            pointerend = pointermin;\n        } else {\n            pointermax = pointermid;\n        }\n        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n    }\n    return pointermid;\n};\n\n/**\n * Determine if the suffix of one string is the prefix of another.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of the first\n *     string and the start of the second string.\n * @private\n */\nvar diff_commonOverlap_ = function (text1: string, text2: string): number {\n    // Cache the text lengths to prevent multiple calls.\n    var text1_length = text1.length;\n    var text2_length = text2.length;\n    // Eliminate the null case.\n    if (text1_length == 0 || text2_length == 0) {\n        return 0;\n    }\n    // Truncate the longer string.\n    if (text1_length > text2_length) {\n        text1 = text1.substring(text1_length - text2_length);\n    } else if (text1_length < text2_length) {\n        text2 = text2.substring(0, text1_length);\n    }\n    var text_length = Math.min(text1_length, text2_length);\n    // Quick check for the worst case.\n    if (text1 == text2) {\n        return text_length;\n    }\n\n    // Start by looking for a single character match\n    // and increase length until no match is found.\n    // Performance analysis: https://neil.fraser.name/news/2010/11/04/\n    var best = 0;\n    var length = 1;\n    while (true) {\n        var pattern = text1.substring(text_length - length);\n        var found = text2.indexOf(pattern);\n        if (found == -1) {\n            return best;\n        }\n        length += found;\n        if (\n            found == 0 ||\n            text1.substring(text_length - length) == text2.substring(0, length)\n        ) {\n            best = length;\n            length++;\n        }\n    }\n};\n\n/**\n * Reduce the number of edits by eliminating semantically trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\nvar diff_cleanupSemantic = function (diffs: Array<Diff>) {\n    var changes = false;\n    var equalities = []; // Stack of indices where equalities are found.\n    var equalitiesLength = 0; // Keeping our own length var is faster in JS.\n    /** @type {?string} */\n    var lastEquality = null;\n    // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n    var pointer = 0; // Index of current position.\n    // Number of characters that changed prior to the equality.\n    var length_insertions1 = 0;\n    var length_deletions1 = 0;\n    // Number of characters that changed after the equality.\n    var length_insertions2 = 0;\n    var length_deletions2 = 0;\n    while (pointer < diffs.length) {\n        if (diffs[pointer][0] == DIFF_EQUAL) {\n            // Equality found.\n            equalities[equalitiesLength++] = pointer;\n            length_insertions1 = length_insertions2;\n            length_deletions1 = length_deletions2;\n            length_insertions2 = 0;\n            length_deletions2 = 0;\n            lastEquality = diffs[pointer][1];\n        } else {\n            // An insertion or deletion.\n            if (diffs[pointer][0] == DIFF_INSERT) {\n                length_insertions2 += diffs[pointer][1].length;\n            } else {\n                length_deletions2 += diffs[pointer][1].length;\n            }\n            // Eliminate an equality that is smaller or equal to the edits on both\n            // sides of it.\n            if (\n                lastEquality &&\n                lastEquality.length <=\n                    Math.max(length_insertions1, length_deletions1) &&\n                lastEquality.length <=\n                    Math.max(length_insertions2, length_deletions2)\n            ) {\n                // Duplicate record.\n                diffs.splice(\n                    equalities[equalitiesLength - 1],\n                    0,\n                    new Diff(DIFF_DELETE, lastEquality)\n                );\n                // Change second copy to insert.\n                diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n                // Throw away the equality we just deleted.\n                equalitiesLength--;\n                // Throw away the previous equality (it needs to be reevaluated).\n                equalitiesLength--;\n                pointer =\n                    equalitiesLength > 0\n                        ? equalities[equalitiesLength - 1]\n                        : -1;\n                length_insertions1 = 0; // Reset the counters.\n                length_deletions1 = 0;\n                length_insertions2 = 0;\n                length_deletions2 = 0;\n                lastEquality = null;\n                changes = true;\n            }\n        }\n        pointer++;\n    }\n\n    // Normalize the diff.\n    if (changes) {\n        diff_cleanupMerge(diffs);\n    }\n    diff_cleanupSemanticLossless(diffs);\n\n    // Find any overlaps between deletions and insertions.\n    // e.g: <del>abcxxx</del><ins>xxxdef</ins>\n    //   -> <del>abc</del>xxx<ins>def</ins>\n    // e.g: <del>xxxabc</del><ins>defxxx</ins>\n    //   -> <ins>def</ins>xxx<del>abc</del>\n    // Only extract an overlap if it is as big as the edit ahead or behind it.\n    pointer = 1;\n    while (pointer < diffs.length) {\n        if (\n            diffs[pointer - 1][0] == DIFF_DELETE &&\n            diffs[pointer][0] == DIFF_INSERT\n        ) {\n            var deletion = diffs[pointer - 1][1];\n            var insertion = diffs[pointer][1];\n            var overlap_length1 = diff_commonOverlap_(deletion, insertion);\n            var overlap_length2 = diff_commonOverlap_(insertion, deletion);\n            if (overlap_length1 >= overlap_length2) {\n                if (\n                    overlap_length1 >= deletion.length / 2 ||\n                    overlap_length1 >= insertion.length / 2\n                ) {\n                    // Overlap found.  Insert an equality and trim the surrounding edits.\n                    diffs.splice(\n                        pointer,\n                        0,\n                        new Diff(\n                            DIFF_EQUAL,\n                            insertion.substring(0, overlap_length1)\n                        )\n                    );\n                    diffs[pointer - 1][1] = deletion.substring(\n                        0,\n                        deletion.length - overlap_length1\n                    );\n                    diffs[pointer + 1][1] =\n                        insertion.substring(overlap_length1);\n                    pointer++;\n                }\n            } else {\n                if (\n                    overlap_length2 >= deletion.length / 2 ||\n                    overlap_length2 >= insertion.length / 2\n                ) {\n                    // Reverse overlap found.\n                    // Insert an equality and swap and trim the surrounding edits.\n                    diffs.splice(\n                        pointer,\n                        0,\n                        new Diff(\n                            DIFF_EQUAL,\n                            deletion.substring(0, overlap_length2)\n                        )\n                    );\n                    diffs[pointer - 1][0] = DIFF_INSERT;\n                    diffs[pointer - 1][1] = insertion.substring(\n                        0,\n                        insertion.length - overlap_length2\n                    );\n                    diffs[pointer + 1][0] = DIFF_DELETE;\n                    diffs[pointer + 1][1] = deletion.substring(overlap_length2);\n                    pointer++;\n                }\n            }\n            pointer++;\n        }\n        pointer++;\n    }\n};\n\n/**\n * Look for single edits surrounded on both sides by equalities\n * which can be shifted sideways to align the edit to a word boundary.\n * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\nvar diff_cleanupSemanticLossless = function (diffs: Array<Diff>) {\n    /**\n     * Given two strings, compute a score representing whether the internal\n     * boundary falls on logical boundaries.\n     * Scores range from 6 (best) to 0 (worst).\n     * Closure, but does not reference any external variables.\n     * @param {string} one First string.\n     * @param {string} two Second string.\n     * @return {number} The score.\n     * @private\n     */\n    function diff_cleanupSemanticScore_(one: string, two: string): number {\n        if (!one || !two) {\n            // Edges are the best.\n            return 6;\n        }\n\n        // Each port of this function behaves slightly differently due to\n        // subtle differences in each language's definition of things like\n        // 'whitespace'.  Since this function's purpose is largely cosmetic,\n        // the choice has been made to use each language's native features\n        // rather than force total conformity.\n        var char1 = one.charAt(one.length - 1);\n        var char2 = two.charAt(0);\n        var nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);\n        var nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);\n        var whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_);\n        var whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_);\n        var lineBreak1 = whitespace1 && char1.match(linebreakRegex_);\n        var lineBreak2 = whitespace2 && char2.match(linebreakRegex_);\n        var blankLine1 = lineBreak1 && one.match(blanklineEndRegex_);\n        var blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);\n\n        if (blankLine1 || blankLine2) {\n            // Five points for blank lines.\n            return 5;\n        } else if (lineBreak1 || lineBreak2) {\n            // Four points for line breaks.\n            return 4;\n        } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\n            // Three points for end of sentences.\n            return 3;\n        } else if (whitespace1 || whitespace2) {\n            // Two points for whitespace.\n            return 2;\n        } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\n            // One point for non-alphanumeric.\n            return 1;\n        }\n        return 0;\n    }\n\n    var pointer = 1;\n    // Intentionally ignore the first and last element (don't need checking).\n    while (pointer < diffs.length - 1) {\n        if (\n            diffs[pointer - 1][0] == DIFF_EQUAL &&\n            diffs[pointer + 1][0] == DIFF_EQUAL\n        ) {\n            // This is a single edit surrounded by equalities.\n            var equality1 = diffs[pointer - 1][1];\n            var edit = diffs[pointer][1];\n            var equality2 = diffs[pointer + 1][1];\n\n            // First, shift the edit as far left as possible.\n            var commonOffset = diff_commonSuffix(equality1, edit);\n            if (commonOffset) {\n                var commonString = edit.substring(edit.length - commonOffset);\n                equality1 = equality1.substring(\n                    0,\n                    equality1.length - commonOffset\n                );\n                edit =\n                    commonString +\n                    edit.substring(0, edit.length - commonOffset);\n                equality2 = commonString + equality2;\n            }\n\n            // Second, step character by character right, looking for the best fit.\n            var bestEquality1 = equality1;\n            var bestEdit = edit;\n            var bestEquality2 = equality2;\n            var bestScore =\n                diff_cleanupSemanticScore_(equality1, edit) +\n                diff_cleanupSemanticScore_(edit, equality2);\n            while (edit.charAt(0) === equality2.charAt(0)) {\n                equality1 += edit.charAt(0);\n                edit = edit.substring(1) + equality2.charAt(0);\n                equality2 = equality2.substring(1);\n                var score =\n                    diff_cleanupSemanticScore_(equality1, edit) +\n                    diff_cleanupSemanticScore_(edit, equality2);\n                // The >= encourages trailing rather than leading whitespace on edits.\n                if (score >= bestScore) {\n                    bestScore = score;\n                    bestEquality1 = equality1;\n                    bestEdit = edit;\n                    bestEquality2 = equality2;\n                }\n            }\n\n            if (diffs[pointer - 1][1] != bestEquality1) {\n                // We have an improvement, save it back to the diff.\n                if (bestEquality1) {\n                    diffs[pointer - 1][1] = bestEquality1;\n                } else {\n                    diffs.splice(pointer - 1, 1);\n                    pointer--;\n                }\n                diffs[pointer][1] = bestEdit;\n                if (bestEquality2) {\n                    diffs[pointer + 1][1] = bestEquality2;\n                } else {\n                    diffs.splice(pointer + 1, 1);\n                    pointer--;\n                }\n            }\n        }\n        pointer++;\n    }\n};\n\n// Define some regex patterns for matching boundaries.\nvar nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;\nvar whitespaceRegex_ = /\\s/;\nvar linebreakRegex_ = /[\\r\\n]/;\nvar blanklineEndRegex_ = /\\n\\r?\\n$/;\nvar blanklineStartRegex_ = /^\\r?\\n\\r?\\n/;\n\n/**\n * Reorder and merge like edit sections.  Merge equalities.\n * Any edit section can move as long as it doesn't cross an equality.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\nvar diff_cleanupMerge = function (diffs: Array<Diff>) {\n    // Add a dummy entry at the end.\n    diffs.push(new Diff(DIFF_EQUAL, ''));\n    var pointer = 0;\n    var count_delete = 0;\n    var count_insert = 0;\n    var text_delete = '';\n    var text_insert = '';\n    var commonlength;\n    while (pointer < diffs.length) {\n        switch (diffs[pointer][0]) {\n            case DIFF_INSERT:\n                count_insert++;\n                text_insert += diffs[pointer][1];\n                pointer++;\n                break;\n            case DIFF_DELETE:\n                count_delete++;\n                text_delete += diffs[pointer][1];\n                pointer++;\n                break;\n            case DIFF_EQUAL:\n                // Upon reaching an equality, check for prior redundancies.\n                if (count_delete + count_insert > 1) {\n                    if (count_delete !== 0 && count_insert !== 0) {\n                        // Factor out any common prefixies.\n                        commonlength = diff_commonPrefix(\n                            text_insert,\n                            text_delete\n                        );\n                        if (commonlength !== 0) {\n                            if (\n                                pointer - count_delete - count_insert > 0 &&\n                                diffs[\n                                    pointer - count_delete - count_insert - 1\n                                ][0] == DIFF_EQUAL\n                            ) {\n                                diffs[\n                                    pointer - count_delete - count_insert - 1\n                                ][1] += text_insert.substring(0, commonlength);\n                            } else {\n                                diffs.splice(\n                                    0,\n                                    0,\n                                    new Diff(\n                                        DIFF_EQUAL,\n                                        text_insert.substring(0, commonlength)\n                                    )\n                                );\n                                pointer++;\n                            }\n                            text_insert = text_insert.substring(commonlength);\n                            text_delete = text_delete.substring(commonlength);\n                        }\n                        // Factor out any common suffixies.\n                        commonlength = diff_commonSuffix(\n                            text_insert,\n                            text_delete\n                        );\n                        if (commonlength !== 0) {\n                            diffs[pointer][1] =\n                                text_insert.substring(\n                                    text_insert.length - commonlength\n                                ) + diffs[pointer][1];\n                            text_insert = text_insert.substring(\n                                0,\n                                text_insert.length - commonlength\n                            );\n                            text_delete = text_delete.substring(\n                                0,\n                                text_delete.length - commonlength\n                            );\n                        }\n                    }\n                    // Delete the offending records and add the merged ones.\n                    pointer -= count_delete + count_insert;\n                    diffs.splice(pointer, count_delete + count_insert);\n                    if (text_delete.length) {\n                        diffs.splice(\n                            pointer,\n                            0,\n                            new Diff(DIFF_DELETE, text_delete)\n                        );\n                        pointer++;\n                    }\n                    if (text_insert.length) {\n                        diffs.splice(\n                            pointer,\n                            0,\n                            new Diff(DIFF_INSERT, text_insert)\n                        );\n                        pointer++;\n                    }\n                    pointer++;\n                } else if (\n                    pointer !== 0 &&\n                    diffs[pointer - 1][0] == DIFF_EQUAL\n                ) {\n                    // Merge this equality with the previous one.\n                    diffs[pointer - 1][1] += diffs[pointer][1];\n                    diffs.splice(pointer, 1);\n                } else {\n                    pointer++;\n                }\n                count_insert = 0;\n                count_delete = 0;\n                text_delete = '';\n                text_insert = '';\n                break;\n        }\n    }\n    if (diffs[diffs.length - 1][1] === '') {\n        diffs.pop(); // Remove the dummy entry at the end.\n    }\n\n    // Second pass: look for single edits surrounded on both sides by equalities\n    // which can be shifted sideways to eliminate an equality.\n    // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n    var changes = false;\n    pointer = 1;\n    // Intentionally ignore the first and last element (don't need checking).\n    while (pointer < diffs.length - 1) {\n        if (\n            diffs[pointer - 1][0] == DIFF_EQUAL &&\n            diffs[pointer + 1][0] == DIFF_EQUAL\n        ) {\n            // This is a single edit surrounded by equalities.\n            if (\n                diffs[pointer][1].substring(\n                    diffs[pointer][1].length - diffs[pointer - 1][1].length\n                ) == diffs[pointer - 1][1]\n            ) {\n                // Shift the edit over the previous equality.\n                diffs[pointer][1] =\n                    diffs[pointer - 1][1] +\n                    diffs[pointer][1].substring(\n                        0,\n                        diffs[pointer][1].length - diffs[pointer - 1][1].length\n                    );\n                diffs[pointer + 1][1] =\n                    diffs[pointer - 1][1] + diffs[pointer + 1][1];\n                diffs.splice(pointer - 1, 1);\n                changes = true;\n            } else if (\n                diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\n                diffs[pointer + 1][1]\n            ) {\n                // Shift the edit over the next equality.\n                diffs[pointer - 1][1] += diffs[pointer + 1][1];\n                diffs[pointer][1] =\n                    diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\n                    diffs[pointer + 1][1];\n                diffs.splice(pointer + 1, 1);\n                changes = true;\n            }\n        }\n        pointer++;\n    }\n    // If shifts were made, the diff needs reordering and another shift sweep.\n    if (changes) {\n        diff_cleanupMerge(diffs);\n    }\n};\n\nexport {\n    Diff,\n    DIFF_EQUAL,\n    DIFF_DELETE,\n    DIFF_INSERT,\n    diff_cleanupSemantic as cleanupSemantic,\n};\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport const NO_DIFF_MESSAGE = 'Compared values have no visual difference.';\n\nexport const SIMILAR_MESSAGE =\n    'Compared values serialize to the same structure.\\n' +\n    'Printing internal object structure without calling `toJSON` instead.';\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// This diff-sequences package implements the linear space variation in\n// An O(ND) Difference Algorithm and Its Variations by Eugene W. Myers\n\n// Relationship in notation between Myers paper and this package:\n// A is a\n// N is aLength, aEnd - aStart, and so on\n// x is aIndex, aFirst, aLast, and so on\n// B is b\n// M is bLength, bEnd - bStart, and so on\n// y is bIndex, bFirst, bLast, and so on\n//  = N - M is negative of baDeltaLength = bLength - aLength\n// D is d\n// k is kF\n// k +  is kF = kR - baDeltaLength\n// V is aIndexesF or aIndexesR (see comment below about Indexes type)\n// index intervals [1, N] and [1, M] are [0, aLength) and [0, bLength)\n// starting point in forward direction (0, 0) is (-1, -1)\n// starting point in reverse direction (N + 1, M + 1) is (aLength, bLength)\n\n// The edit graph for sequences a and b corresponds to items:\n// in a on the horizontal axis\n// in b on the vertical axis\n//\n// Given a-coordinate of a point in a diagonal, you can compute b-coordinate.\n//\n// Forward diagonals kF:\n// zero diagonal intersects top left corner\n// positive diagonals intersect top edge\n// negative diagonals insersect left edge\n//\n// Reverse diagonals kR:\n// zero diagonal intersects bottom right corner\n// positive diagonals intersect right edge\n// negative diagonals intersect bottom edge\n\n// The graph contains a directed acyclic graph of edges:\n// horizontal: delete an item from a\n// vertical: insert an item from b\n// diagonal: common item in a and b\n//\n// The algorithm solves dual problems in the graph analogy:\n// Find longest common subsequence: path with maximum number of diagonal edges\n// Find shortest edit script: path with minimum number of non-diagonal edges\n\n// Input callback function compares items at indexes in the sequences.\ntype IsCommon = (\n    aIndex: number, // caller can assume: 0 <= aIndex && aIndex < aLength\n    bIndex: number // caller can assume: 0 <= bIndex && bIndex < bLength\n) => boolean;\n\n// Output callback function receives the number of adjacent items\n// and starting indexes of each common subsequence.\ntype FoundSubsequence = (\n    nCommon: number, // caller can assume: 0 < nCommon\n    aCommon: number, // caller can assume: 0 <= aCommon && aCommon < aLength\n    bCommon: number // caller can assume: 0 <= bCommon && bCommon < bLength\n) => void;\n\n// Either original functions or wrapped to swap indexes if graph is transposed.\nexport type Callbacks = {\n    foundSubsequence: FoundSubsequence;\n    isCommon: IsCommon;\n};\n\n// Indexes in sequence a of last point of forward or reverse paths in graph.\n// Myers algorithm indexes by diagonal k which for negative is bad deopt in V8.\n// This package indexes by iF and iR which are greater than or equal to zero.\n// and also updates the index arrays in place to cut memory in half.\n// kF = 2 * iF - d\n// kR = d - 2 * iR\ntype Indexes = Array<number>;\n\n// Division of index intervals in sequences a and b at the middle change.\n// Invariant: intervals do not have common items at the start or end.\ntype Division = {\n    // The end of interval preceding division is open like array slice method.\n    nChangePreceding: number; // number of change items\n    aEndPreceding: number;\n    bEndPreceding: number;\n\n    nCommonPreceding: number; // 0 if no common items preceding middle change\n    aCommonPreceding: number; // ignore prop value if nCommonPreceding === 0\n    bCommonPreceding: number; // ignore prop value if nCommonPreceding === 0\n\n    nCommonFollowing: number; // 0 if no common items following middle change\n    aCommonFollowing: number; // ignore prop value if nCommonFollowing === 0\n    bCommonFollowing: number; // ignore prop value if nCommonFollowing === 0\n\n    // The start of interval following division is closed like array slice method.\n    nChangeFollowing: number; // number of change items\n    aStartFollowing: number;\n    bStartFollowing: number;\n};\n\nconst pkg = 'diff-sequences'; // for error messages\nconst NOT_YET_SET = 0; // small int instead of undefined to avoid deopt in V8\n\n// Return the number of common items that follow in forward direction.\n// The length of what Myers paper calls a snake in a forward path.\nconst countCommonItemsF = (\n    aIndex: number,\n    aEnd: number,\n    bIndex: number,\n    bEnd: number,\n    isCommon: IsCommon\n) => {\n    let nCommon = 0;\n    while (aIndex < aEnd && bIndex < bEnd && isCommon(aIndex, bIndex)) {\n        aIndex += 1;\n        bIndex += 1;\n        nCommon += 1;\n    }\n    return nCommon;\n};\n\n// Return the number of common items that precede in reverse direction.\n// The length of what Myers paper calls a snake in a reverse path.\nconst countCommonItemsR = (\n    aStart: number,\n    aIndex: number,\n    bStart: number,\n    bIndex: number,\n    isCommon: IsCommon\n) => {\n    let nCommon = 0;\n    while (aStart <= aIndex && bStart <= bIndex && isCommon(aIndex, bIndex)) {\n        aIndex -= 1;\n        bIndex -= 1;\n        nCommon += 1;\n    }\n    return nCommon;\n};\n\n// A simple function to extend forward paths from (d - 1) to d changes\n// when forward and reverse paths cannot yet overlap.\nconst extendPathsF = (\n    d: number,\n    aEnd: number,\n    bEnd: number,\n    bF: number, // bIndex = bF + aIndex - kF\n    isCommon: IsCommon,\n    aIndexesF: Indexes, // update indexes in sequence a of paths in diagonals kF\n    iMaxF: number // return the value because optimization might decrease it\n): number => {\n    // Unroll the first iteration.\n    let iF = 0;\n    let kF = -d; // kF = 2 * iF - d\n    let aFirst = aIndexesF[iF]; // in first iteration always insert\n    let aIndexPrev1 = aFirst; // prev value of [iF - 1] in next iteration\n    aIndexesF[iF] += countCommonItemsF(\n        aFirst + 1,\n        aEnd,\n        bF + aFirst - kF + 1,\n        bEnd,\n        isCommon\n    );\n\n    // Optimization: skip diagonals in which paths cannot ever overlap.\n    const nF = d < iMaxF ? d : iMaxF;\n\n    // The diagonals kF are odd when d is odd and even when d is even.\n    for (iF += 1, kF += 2; iF <= nF; iF += 1, kF += 2) {\n        // To get first point of path segment, move one change in forward direction\n        // from last point of previous path segment in an adjacent diagonal.\n        // In last possible iteration when iF === d and kF === d always delete.\n        if (iF !== d && aIndexPrev1 < aIndexesF[iF]) {\n            aFirst = aIndexesF[iF]; // vertical to insert from b\n        } else {\n            aFirst = aIndexPrev1 + 1; // horizontal to delete from a\n\n            if (aEnd <= aFirst) {\n                // Optimization: delete moved past right of graph.\n                return iF - 1;\n            }\n        }\n\n        // To get last point of path segment, move along diagonal of common items.\n        aIndexPrev1 = aIndexesF[iF];\n        aIndexesF[iF] =\n            aFirst +\n            countCommonItemsF(\n                aFirst + 1,\n                aEnd,\n                bF + aFirst - kF + 1,\n                bEnd,\n                isCommon\n            );\n    }\n\n    return iMaxF;\n};\n\n// A simple function to extend reverse paths from (d - 1) to d changes\n// when reverse and forward paths cannot yet overlap.\nconst extendPathsR = (\n    d: number,\n    aStart: number,\n    bStart: number,\n    bR: number, // bIndex = bR + aIndex - kR\n    isCommon: IsCommon,\n    aIndexesR: Indexes, // update indexes in sequence a of paths in diagonals kR\n    iMaxR: number // return the value because optimization might decrease it\n): number => {\n    // Unroll the first iteration.\n    let iR = 0;\n    let kR = d; // kR = d - 2 * iR\n    let aFirst = aIndexesR[iR]; // in first iteration always insert\n    let aIndexPrev1 = aFirst; // prev value of [iR - 1] in next iteration\n    aIndexesR[iR] -= countCommonItemsR(\n        aStart,\n        aFirst - 1,\n        bStart,\n        bR + aFirst - kR - 1,\n        isCommon\n    );\n\n    // Optimization: skip diagonals in which paths cannot ever overlap.\n    const nR = d < iMaxR ? d : iMaxR;\n\n    // The diagonals kR are odd when d is odd and even when d is even.\n    for (iR += 1, kR -= 2; iR <= nR; iR += 1, kR -= 2) {\n        // To get first point of path segment, move one change in reverse direction\n        // from last point of previous path segment in an adjacent diagonal.\n        // In last possible iteration when iR === d and kR === -d always delete.\n        if (iR !== d && aIndexesR[iR] < aIndexPrev1) {\n            aFirst = aIndexesR[iR]; // vertical to insert from b\n        } else {\n            aFirst = aIndexPrev1 - 1; // horizontal to delete from a\n\n            if (aFirst < aStart) {\n                // Optimization: delete moved past left of graph.\n                return iR - 1;\n            }\n        }\n\n        // To get last point of path segment, move along diagonal of common items.\n        aIndexPrev1 = aIndexesR[iR];\n        aIndexesR[iR] =\n            aFirst -\n            countCommonItemsR(\n                aStart,\n                aFirst - 1,\n                bStart,\n                bR + aFirst - kR - 1,\n                isCommon\n            );\n    }\n\n    return iMaxR;\n};\n\n// A complete function to extend forward paths from (d - 1) to d changes.\n// Return true if a path overlaps reverse path of (d - 1) changes in its diagonal.\nconst extendOverlappablePathsF = (\n    d: number,\n    aStart: number,\n    aEnd: number,\n    bStart: number,\n    bEnd: number,\n    isCommon: IsCommon,\n    aIndexesF: Indexes, // update indexes in sequence a of paths in diagonals kF\n    iMaxF: number,\n    aIndexesR: Indexes,\n    iMaxR: number,\n    division: Division // update prop values if return true\n): boolean => {\n    const bF = bStart - aStart; // bIndex = bF + aIndex - kF\n    const aLength = aEnd - aStart;\n    const bLength = bEnd - bStart;\n    const baDeltaLength = bLength - aLength; // kF = kR - baDeltaLength\n\n    // Range of diagonals in which forward and reverse paths might overlap.\n    const kMinOverlapF = -baDeltaLength - (d - 1); // -(d - 1) <= kR\n    const kMaxOverlapF = -baDeltaLength + (d - 1); // kR <= (d - 1)\n\n    let aIndexPrev1 = NOT_YET_SET; // prev value of [iF - 1] in next iteration\n\n    // Optimization: skip diagonals in which paths cannot ever overlap.\n    const nF = d < iMaxF ? d : iMaxF;\n\n    // The diagonals kF = 2 * iF - d are odd when d is odd and even when d is even.\n    for (let iF = 0, kF = -d; iF <= nF; iF += 1, kF += 2) {\n        // To get first point of path segment, move one change in forward direction\n        // from last point of previous path segment in an adjacent diagonal.\n        // In first iteration when iF === 0 and kF === -d always insert.\n        // In last possible iteration when iF === d and kF === d always delete.\n        const insert = iF === 0 || (iF !== d && aIndexPrev1 < aIndexesF[iF]);\n        const aLastPrev = insert ? aIndexesF[iF] : aIndexPrev1;\n        const aFirst = insert\n            ? aLastPrev // vertical to insert from b\n            : aLastPrev + 1; // horizontal to delete from a\n\n        // To get last point of path segment, move along diagonal of common items.\n        const bFirst = bF + aFirst - kF;\n        const nCommonF = countCommonItemsF(\n            aFirst + 1,\n            aEnd,\n            bFirst + 1,\n            bEnd,\n            isCommon\n        );\n        const aLast = aFirst + nCommonF;\n\n        aIndexPrev1 = aIndexesF[iF];\n        aIndexesF[iF] = aLast;\n\n        if (kMinOverlapF <= kF && kF <= kMaxOverlapF) {\n            // Solve for iR of reverse path with (d - 1) changes in diagonal kF:\n            // kR = kF + baDeltaLength\n            // kR = (d - 1) - 2 * iR\n            const iR = (d - 1 - (kF + baDeltaLength)) / 2;\n\n            // If this forward path overlaps the reverse path in this diagonal,\n            // then this is the middle change of the index intervals.\n            if (iR <= iMaxR && aIndexesR[iR] - 1 <= aLast) {\n                // Unlike the Myers algorithm which finds only the middle snake\n                // this package can find two common subsequences per division.\n                // Last point of previous path segment is on an adjacent diagonal.\n                const bLastPrev = bF + aLastPrev - (insert ? kF + 1 : kF - 1);\n\n                // Because of invariant that intervals preceding the middle change\n                // cannot have common items at the end,\n                // move in reverse direction along a diagonal of common items.\n                const nCommonR = countCommonItemsR(\n                    aStart,\n                    aLastPrev,\n                    bStart,\n                    bLastPrev,\n                    isCommon\n                );\n\n                const aIndexPrevFirst = aLastPrev - nCommonR;\n                const bIndexPrevFirst = bLastPrev - nCommonR;\n\n                const aEndPreceding = aIndexPrevFirst + 1;\n                const bEndPreceding = bIndexPrevFirst + 1;\n\n                division.nChangePreceding = d - 1;\n                if (d - 1 === aEndPreceding + bEndPreceding - aStart - bStart) {\n                    // Optimization: number of preceding changes in forward direction\n                    // is equal to number of items in preceding interval,\n                    // therefore it cannot contain any common items.\n                    division.aEndPreceding = aStart;\n                    division.bEndPreceding = bStart;\n                } else {\n                    division.aEndPreceding = aEndPreceding;\n                    division.bEndPreceding = bEndPreceding;\n                }\n\n                division.nCommonPreceding = nCommonR;\n                if (nCommonR !== 0) {\n                    division.aCommonPreceding = aEndPreceding;\n                    division.bCommonPreceding = bEndPreceding;\n                }\n\n                division.nCommonFollowing = nCommonF;\n                if (nCommonF !== 0) {\n                    division.aCommonFollowing = aFirst + 1;\n                    division.bCommonFollowing = bFirst + 1;\n                }\n\n                const aStartFollowing = aLast + 1;\n                const bStartFollowing = bFirst + nCommonF + 1;\n\n                division.nChangeFollowing = d - 1;\n                if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {\n                    // Optimization: number of changes in reverse direction\n                    // is equal to number of items in following interval,\n                    // therefore it cannot contain any common items.\n                    division.aStartFollowing = aEnd;\n                    division.bStartFollowing = bEnd;\n                } else {\n                    division.aStartFollowing = aStartFollowing;\n                    division.bStartFollowing = bStartFollowing;\n                }\n\n                return true;\n            }\n        }\n    }\n\n    return false;\n};\n\n// A complete function to extend reverse paths from (d - 1) to d changes.\n// Return true if a path overlaps forward path of d changes in its diagonal.\nconst extendOverlappablePathsR = (\n    d: number,\n    aStart: number,\n    aEnd: number,\n    bStart: number,\n    bEnd: number,\n    isCommon: IsCommon,\n    aIndexesF: Indexes,\n    iMaxF: number,\n    aIndexesR: Indexes, // update indexes in sequence a of paths in diagonals kR\n    iMaxR: number,\n    division: Division // update prop values if return true\n): boolean => {\n    const bR = bEnd - aEnd; // bIndex = bR + aIndex - kR\n    const aLength = aEnd - aStart;\n    const bLength = bEnd - bStart;\n    const baDeltaLength = bLength - aLength; // kR = kF + baDeltaLength\n\n    // Range of diagonals in which forward and reverse paths might overlap.\n    const kMinOverlapR = baDeltaLength - d; // -d <= kF\n    const kMaxOverlapR = baDeltaLength + d; // kF <= d\n\n    let aIndexPrev1 = NOT_YET_SET; // prev value of [iR - 1] in next iteration\n\n    // Optimization: skip diagonals in which paths cannot ever overlap.\n    const nR = d < iMaxR ? d : iMaxR;\n\n    // The diagonals kR = d - 2 * iR are odd when d is odd and even when d is even.\n    for (let iR = 0, kR = d; iR <= nR; iR += 1, kR -= 2) {\n        // To get first point of path segment, move one change in reverse direction\n        // from last point of previous path segment in an adjacent diagonal.\n        // In first iteration when iR === 0 and kR === d always insert.\n        // In last possible iteration when iR === d and kR === -d always delete.\n        const insert = iR === 0 || (iR !== d && aIndexesR[iR] < aIndexPrev1);\n        const aLastPrev = insert ? aIndexesR[iR] : aIndexPrev1;\n        const aFirst = insert\n            ? aLastPrev // vertical to insert from b\n            : aLastPrev - 1; // horizontal to delete from a\n\n        // To get last point of path segment, move along diagonal of common items.\n        const bFirst = bR + aFirst - kR;\n        const nCommonR = countCommonItemsR(\n            aStart,\n            aFirst - 1,\n            bStart,\n            bFirst - 1,\n            isCommon\n        );\n        const aLast = aFirst - nCommonR;\n\n        aIndexPrev1 = aIndexesR[iR];\n        aIndexesR[iR] = aLast;\n\n        if (kMinOverlapR <= kR && kR <= kMaxOverlapR) {\n            // Solve for iF of forward path with d changes in diagonal kR:\n            // kF = kR - baDeltaLength\n            // kF = 2 * iF - d\n            const iF = (d + (kR - baDeltaLength)) / 2;\n\n            // If this reverse path overlaps the forward path in this diagonal,\n            // then this is a middle change of the index intervals.\n            if (iF <= iMaxF && aLast - 1 <= aIndexesF[iF]) {\n                const bLast = bFirst - nCommonR;\n\n                division.nChangePreceding = d;\n                if (d === aLast + bLast - aStart - bStart) {\n                    // Optimization: number of changes in reverse direction\n                    // is equal to number of items in preceding interval,\n                    // therefore it cannot contain any common items.\n                    division.aEndPreceding = aStart;\n                    division.bEndPreceding = bStart;\n                } else {\n                    division.aEndPreceding = aLast;\n                    division.bEndPreceding = bLast;\n                }\n\n                division.nCommonPreceding = nCommonR;\n                if (nCommonR !== 0) {\n                    // The last point of reverse path segment is start of common subsequence.\n                    division.aCommonPreceding = aLast;\n                    division.bCommonPreceding = bLast;\n                }\n\n                division.nChangeFollowing = d - 1;\n                if (d === 1) {\n                    // There is no previous path segment.\n                    division.nCommonFollowing = 0;\n                    division.aStartFollowing = aEnd;\n                    division.bStartFollowing = bEnd;\n                } else {\n                    // Unlike the Myers algorithm which finds only the middle snake\n                    // this package can find two common subsequences per division.\n                    // Last point of previous path segment is on an adjacent diagonal.\n                    const bLastPrev =\n                        bR + aLastPrev - (insert ? kR - 1 : kR + 1);\n\n                    // Because of invariant that intervals following the middle change\n                    // cannot have common items at the start,\n                    // move in forward direction along a diagonal of common items.\n                    const nCommonF = countCommonItemsF(\n                        aLastPrev,\n                        aEnd,\n                        bLastPrev,\n                        bEnd,\n                        isCommon\n                    );\n\n                    division.nCommonFollowing = nCommonF;\n                    if (nCommonF !== 0) {\n                        // The last point of reverse path segment is start of common subsequence.\n                        division.aCommonFollowing = aLastPrev;\n                        division.bCommonFollowing = bLastPrev;\n                    }\n\n                    const aStartFollowing = aLastPrev + nCommonF; // aFirstPrev\n                    const bStartFollowing = bLastPrev + nCommonF; // bFirstPrev\n\n                    if (\n                        d - 1 ===\n                        aEnd + bEnd - aStartFollowing - bStartFollowing\n                    ) {\n                        // Optimization: number of changes in forward direction\n                        // is equal to number of items in following interval,\n                        // therefore it cannot contain any common items.\n                        division.aStartFollowing = aEnd;\n                        division.bStartFollowing = bEnd;\n                    } else {\n                        division.aStartFollowing = aStartFollowing;\n                        division.bStartFollowing = bStartFollowing;\n                    }\n                }\n\n                return true;\n            }\n        }\n    }\n\n    return false;\n};\n\n// Given index intervals and input function to compare items at indexes,\n// divide at the middle change.\n//\n// DO NOT CALL if start === end, because interval cannot contain common items\n// and because this function will throw the no overlap error.\nconst divide = (\n    nChange: number,\n    aStart: number,\n    aEnd: number,\n    bStart: number,\n    bEnd: number,\n    isCommon: IsCommon,\n    aIndexesF: Indexes, // temporary memory, not input nor output\n    aIndexesR: Indexes, // temporary memory, not input nor output\n    division: Division // output\n) => {\n    const bF = bStart - aStart; // bIndex = bF + aIndex - kF\n    const bR = bEnd - aEnd; // bIndex = bR + aIndex - kR\n    const aLength = aEnd - aStart;\n    const bLength = bEnd - bStart;\n\n    // Because graph has square or portrait orientation,\n    // length difference is minimum number of items to insert from b.\n    // Corresponding forward and reverse diagonals in graph\n    // depend on length difference of the sequences:\n    // kF = kR - baDeltaLength\n    // kR = kF + baDeltaLength\n    const baDeltaLength = bLength - aLength;\n\n    // Optimization: max diagonal in graph intersects corner of shorter side.\n    let iMaxF = aLength;\n    let iMaxR = aLength;\n\n    // Initialize no changes yet in forward or reverse direction:\n    aIndexesF[0] = aStart - 1; // at open start of interval, outside closed start\n    aIndexesR[0] = aEnd; // at open end of interval\n\n    if (baDeltaLength % 2 === 0) {\n        // The number of changes in paths is 2 * d if length difference is even.\n        const dMin = (nChange || baDeltaLength) / 2;\n        const dMax = (aLength + bLength) / 2;\n\n        for (let d = 1; d <= dMax; d += 1) {\n            iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);\n\n            if (d < dMin) {\n                iMaxR = extendPathsR(\n                    d,\n                    aStart,\n                    bStart,\n                    bR,\n                    isCommon,\n                    aIndexesR,\n                    iMaxR\n                );\n            } else if (\n                // If a reverse path overlaps a forward path in the same diagonal,\n                // return a division of the index intervals at the middle change.\n                extendOverlappablePathsR(\n                    d,\n                    aStart,\n                    aEnd,\n                    bStart,\n                    bEnd,\n                    isCommon,\n                    aIndexesF,\n                    iMaxF,\n                    aIndexesR,\n                    iMaxR,\n                    division\n                )\n            ) {\n                return;\n            }\n        }\n    } else {\n        // The number of changes in paths is 2 * d - 1 if length difference is odd.\n        const dMin = ((nChange || baDeltaLength) + 1) / 2;\n        const dMax = (aLength + bLength + 1) / 2;\n\n        // Unroll first half iteration so loop extends the relevant pairs of paths.\n        // Because of invariant that intervals have no common items at start or end,\n        // and limitation not to call divide with empty intervals,\n        // therefore it cannot be called if a forward path with one change\n        // would overlap a reverse path with no changes, even if dMin === 1.\n        let d = 1;\n        iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);\n\n        for (d += 1; d <= dMax; d += 1) {\n            iMaxR = extendPathsR(\n                d - 1,\n                aStart,\n                bStart,\n                bR,\n                isCommon,\n                aIndexesR,\n                iMaxR\n            );\n\n            if (d < dMin) {\n                iMaxF = extendPathsF(\n                    d,\n                    aEnd,\n                    bEnd,\n                    bF,\n                    isCommon,\n                    aIndexesF,\n                    iMaxF\n                );\n            } else if (\n                // If a forward path overlaps a reverse path in the same diagonal,\n                // return a division of the index intervals at the middle change.\n                extendOverlappablePathsF(\n                    d,\n                    aStart,\n                    aEnd,\n                    bStart,\n                    bEnd,\n                    isCommon,\n                    aIndexesF,\n                    iMaxF,\n                    aIndexesR,\n                    iMaxR,\n                    division\n                )\n            ) {\n                return;\n            }\n        }\n    }\n\n    /* istanbul ignore next */\n    throw new Error(\n        `${pkg}: no overlap aStart=${aStart} aEnd=${aEnd} bStart=${bStart} bEnd=${bEnd}`\n    );\n};\n\n// Given index intervals and input function to compare items at indexes,\n// return by output function the number of adjacent items and starting indexes\n// of each common subsequence. Divide and conquer with only linear space.\n//\n// The index intervals are half open [start, end) like array slice method.\n// DO NOT CALL if start === end, because interval cannot contain common items\n// and because divide function will throw the no overlap error.\nconst findSubsequences = (\n    nChange: number,\n    aStart: number,\n    aEnd: number,\n    bStart: number,\n    bEnd: number,\n    transposed: boolean,\n    callbacks: Array<Callbacks>,\n    aIndexesF: Indexes, // temporary memory, not input nor output\n    aIndexesR: Indexes, // temporary memory, not input nor output\n    division: Division // temporary memory, not input nor output\n) => {\n    if (bEnd - bStart < aEnd - aStart) {\n        // Transpose graph so it has portrait instead of landscape orientation.\n        // Always compare shorter to longer sequence for consistency and optimization.\n        transposed = !transposed;\n        if (transposed && callbacks.length === 1) {\n            // Lazily wrap callback functions to swap args if graph is transposed.\n            const { foundSubsequence, isCommon } = callbacks[0];\n            callbacks[1] = {\n                foundSubsequence: (nCommon, bCommon, aCommon) => {\n                    foundSubsequence(nCommon, aCommon, bCommon);\n                },\n                isCommon: (bIndex, aIndex) => isCommon(aIndex, bIndex),\n            };\n        }\n\n        const tStart = aStart;\n        const tEnd = aEnd;\n        aStart = bStart;\n        aEnd = bEnd;\n        bStart = tStart;\n        bEnd = tEnd;\n    }\n    const { foundSubsequence, isCommon } = callbacks[transposed ? 1 : 0];\n\n    // Divide the index intervals at the middle change.\n    divide(\n        nChange,\n        aStart,\n        aEnd,\n        bStart,\n        bEnd,\n        isCommon,\n        aIndexesF,\n        aIndexesR,\n        division\n    );\n    const {\n        nChangePreceding,\n        aEndPreceding,\n        bEndPreceding,\n        nCommonPreceding,\n        aCommonPreceding,\n        bCommonPreceding,\n        nCommonFollowing,\n        aCommonFollowing,\n        bCommonFollowing,\n        nChangeFollowing,\n        aStartFollowing,\n        bStartFollowing,\n    } = division;\n\n    // Unless either index interval is empty, they might contain common items.\n    if (aStart < aEndPreceding && bStart < bEndPreceding) {\n        // Recursely find and return common subsequences preceding the division.\n        findSubsequences(\n            nChangePreceding,\n            aStart,\n            aEndPreceding,\n            bStart,\n            bEndPreceding,\n            transposed,\n            callbacks,\n            aIndexesF,\n            aIndexesR,\n            division\n        );\n    }\n\n    // Return common subsequences that are adjacent to the middle change.\n    if (nCommonPreceding !== 0) {\n        foundSubsequence(nCommonPreceding, aCommonPreceding, bCommonPreceding);\n    }\n    if (nCommonFollowing !== 0) {\n        foundSubsequence(nCommonFollowing, aCommonFollowing, bCommonFollowing);\n    }\n\n    // Unless either index interval is empty, they might contain common items.\n    if (aStartFollowing < aEnd && bStartFollowing < bEnd) {\n        // Recursely find and return common subsequences following the division.\n        findSubsequences(\n            nChangeFollowing,\n            aStartFollowing,\n            aEnd,\n            bStartFollowing,\n            bEnd,\n            transposed,\n            callbacks,\n            aIndexesF,\n            aIndexesR,\n            division\n        );\n    }\n};\n\nconst validateLength = (name: string, arg: unknown) => {\n    if (typeof arg !== 'number') {\n        throw new TypeError(\n            `${pkg}: ${name} typeof ${typeof arg} is not a number`\n        );\n    }\n    if (!Number.isSafeInteger(arg)) {\n        throw new RangeError(\n            `${pkg}: ${name} value ${arg} is not a safe integer`\n        );\n    }\n    if (arg < 0) {\n        throw new RangeError(\n            `${pkg}: ${name} value ${arg} is a negative integer`\n        );\n    }\n};\n\nconst validateCallback = (name: string, arg: unknown) => {\n    const type = typeof arg;\n    if (type !== 'function') {\n        throw new TypeError(`${pkg}: ${name} typeof ${type} is not a function`);\n    }\n};\n\n// Compare items in two sequences to find a longest common subsequence.\n// Given lengths of sequences and input function to compare items at indexes,\n// return by output function the number of adjacent items and starting indexes\n// of each common subsequence.\nexport default (\n    aLength: number,\n    bLength: number,\n    isCommon: IsCommon,\n    foundSubsequence: FoundSubsequence\n): void => {\n    validateLength('aLength', aLength);\n    validateLength('bLength', bLength);\n    validateCallback('isCommon', isCommon);\n    validateCallback('foundSubsequence', foundSubsequence);\n\n    // Count common items from the start in the forward direction.\n    const nCommonF = countCommonItemsF(0, aLength, 0, bLength, isCommon);\n\n    if (nCommonF !== 0) {\n        foundSubsequence(nCommonF, 0, 0);\n    }\n\n    // Unless both sequences consist of common items only,\n    // find common items in the half-trimmed index intervals.\n    if (aLength !== nCommonF || bLength !== nCommonF) {\n        // Invariant: intervals do not have common items at the start.\n        // The start of an index interval is closed like array slice method.\n        const aStart = nCommonF;\n        const bStart = nCommonF;\n\n        // Count common items from the end in the reverse direction.\n        const nCommonR = countCommonItemsR(\n            aStart,\n            aLength - 1,\n            bStart,\n            bLength - 1,\n            isCommon\n        );\n\n        // Invariant: intervals do not have common items at the end.\n        // The end of an index interval is open like array slice method.\n        const aEnd = aLength - nCommonR;\n        const bEnd = bLength - nCommonR;\n\n        // Unless one sequence consists of common items only,\n        // therefore the other trimmed index interval consists of changes only,\n        // find common items in the trimmed index intervals.\n        const nCommonFR = nCommonF + nCommonR;\n        if (aLength !== nCommonFR && bLength !== nCommonFR) {\n            const nChange = 0; // number of change items is not yet known\n            const transposed = false; // call the original unwrapped functions\n            const callbacks = [{ foundSubsequence, isCommon }];\n\n            // Indexes in sequence a of last points in furthest reaching paths\n            // from outside the start at top left in the forward direction:\n            const aIndexesF = [NOT_YET_SET];\n            // from the end at bottom right in the reverse direction:\n            const aIndexesR = [NOT_YET_SET];\n\n            // Initialize one object as output of all calls to divide function.\n            const division = {\n                aCommonFollowing: NOT_YET_SET,\n                aCommonPreceding: NOT_YET_SET,\n                aEndPreceding: NOT_YET_SET,\n                aStartFollowing: NOT_YET_SET,\n                bCommonFollowing: NOT_YET_SET,\n                bCommonPreceding: NOT_YET_SET,\n                bEndPreceding: NOT_YET_SET,\n                bStartFollowing: NOT_YET_SET,\n                nChangeFollowing: NOT_YET_SET,\n                nChangePreceding: NOT_YET_SET,\n                nCommonFollowing: NOT_YET_SET,\n                nCommonPreceding: NOT_YET_SET,\n            };\n\n            // Find and return common subsequences in the trimmed index intervals.\n            findSubsequences(\n                nChange,\n                aStart,\n                aEnd,\n                bStart,\n                bEnd,\n                transposed,\n                callbacks,\n                aIndexesF,\n                aIndexesR,\n                division\n            );\n        }\n\n        if (nCommonR !== 0) {\n            foundSubsequence(nCommonR, aEnd, bEnd);\n        }\n    }\n};\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport { DIFF_DELETE, DIFF_EQUAL, DIFF_INSERT, Diff } from './cleanupSemantic';\nimport type { DiffOptionsColor, DiffOptionsNormalized } from './types';\n\nconst formatTrailingSpaces = (\n    line: string,\n    trailingSpaceFormatter: DiffOptionsColor\n): string => line.replace(/\\s+$/, (match) => trailingSpaceFormatter(match));\n\nconst printDiffLine = (\n    line: string,\n    isFirstOrLast: boolean,\n    color: DiffOptionsColor,\n    indicator: string,\n    trailingSpaceFormatter: DiffOptionsColor,\n    emptyFirstOrLastLinePlaceholder: string\n): string =>\n    line.length !== 0\n        ? color(\n              indicator +\n                  ' ' +\n                  formatTrailingSpaces(line, trailingSpaceFormatter)\n          )\n        : indicator !== ' '\n        ? color(indicator)\n        : isFirstOrLast && emptyFirstOrLastLinePlaceholder.length !== 0\n        ? color(indicator + ' ' + emptyFirstOrLastLinePlaceholder)\n        : '';\n\nconst printDeleteLine = (\n    line: string,\n    isFirstOrLast: boolean,\n    {\n        aColor,\n        aIndicator,\n        changeLineTrailingSpaceColor,\n        emptyFirstOrLastLinePlaceholder,\n    }: DiffOptionsNormalized\n): string =>\n    printDiffLine(\n        line,\n        isFirstOrLast,\n        aColor,\n        aIndicator,\n        changeLineTrailingSpaceColor,\n        emptyFirstOrLastLinePlaceholder\n    );\n\nconst printInsertLine = (\n    line: string,\n    isFirstOrLast: boolean,\n    {\n        bColor,\n        bIndicator,\n        changeLineTrailingSpaceColor,\n        emptyFirstOrLastLinePlaceholder,\n    }: DiffOptionsNormalized\n): string =>\n    printDiffLine(\n        line,\n        isFirstOrLast,\n        bColor,\n        bIndicator,\n        changeLineTrailingSpaceColor,\n        emptyFirstOrLastLinePlaceholder\n    );\n\nconst printCommonLine = (\n    line: string,\n    isFirstOrLast: boolean,\n    {\n        commonColor,\n        commonIndicator,\n        commonLineTrailingSpaceColor,\n        emptyFirstOrLastLinePlaceholder,\n    }: DiffOptionsNormalized\n): string =>\n    printDiffLine(\n        line,\n        isFirstOrLast,\n        commonColor,\n        commonIndicator,\n        commonLineTrailingSpaceColor,\n        emptyFirstOrLastLinePlaceholder\n    );\n\n// In GNU diff format, indexes are one-based instead of zero-based.\nconst createPatchMark = (\n    aStart: number,\n    aEnd: number,\n    bStart: number,\n    bEnd: number,\n    { patchColor }: DiffOptionsNormalized\n): string =>\n    patchColor(\n        `@@ -${aStart + 1},${aEnd - aStart} +${bStart + 1},${bEnd - bStart} @@`\n    );\n\n// jest --no-expand\n//\n// Given array of aligned strings with inverse highlight formatting,\n// return joined lines with diff formatting (and patch marks, if needed).\nexport const joinAlignedDiffsNoExpand = (\n    diffs: Array<Diff>,\n    options: DiffOptionsNormalized\n): string => {\n    const iLength = diffs.length;\n    const nContextLines = options.contextLines;\n    const nContextLines2 = nContextLines + nContextLines;\n\n    // First pass: count output lines and see if it has patches.\n    let jLength = iLength;\n    let hasExcessAtStartOrEnd = false;\n    let nExcessesBetweenChanges = 0;\n    let i = 0;\n    while (i !== iLength) {\n        const iStart = i;\n        while (i !== iLength && diffs[i][0] === DIFF_EQUAL) {\n            i += 1;\n        }\n\n        if (iStart !== i) {\n            if (iStart === 0) {\n                // at start\n                if (i > nContextLines) {\n                    jLength -= i - nContextLines; // subtract excess common lines\n                    hasExcessAtStartOrEnd = true;\n                }\n            } else if (i === iLength) {\n                // at end\n                const n = i - iStart;\n                if (n > nContextLines) {\n                    jLength -= n - nContextLines; // subtract excess common lines\n                    hasExcessAtStartOrEnd = true;\n                }\n            } else {\n                // between changes\n                const n = i - iStart;\n                if (n > nContextLines2) {\n                    jLength -= n - nContextLines2; // subtract excess common lines\n                    nExcessesBetweenChanges += 1;\n                }\n            }\n        }\n\n        while (i !== iLength && diffs[i][0] !== DIFF_EQUAL) {\n            i += 1;\n        }\n    }\n\n    const hasPatch = nExcessesBetweenChanges !== 0 || hasExcessAtStartOrEnd;\n    if (nExcessesBetweenChanges !== 0) {\n        jLength += nExcessesBetweenChanges + 1; // add patch lines\n    } else if (hasExcessAtStartOrEnd) {\n        jLength += 1; // add patch line\n    }\n    const jLast = jLength - 1;\n\n    const lines: Array<string> = [];\n\n    let jPatchMark = 0; // index of placeholder line for current patch mark\n    if (hasPatch) {\n        lines.push(''); // placeholder line for first patch mark\n    }\n\n    // Indexes of expected or received lines in current patch:\n    let aStart = 0;\n    let bStart = 0;\n    let aEnd = 0;\n    let bEnd = 0;\n\n    const pushCommonLine = (line: string): void => {\n        const j = lines.length;\n        lines.push(printCommonLine(line, j === 0 || j === jLast, options));\n        aEnd += 1;\n        bEnd += 1;\n    };\n\n    const pushDeleteLine = (line: string): void => {\n        const j = lines.length;\n        lines.push(printDeleteLine(line, j === 0 || j === jLast, options));\n        aEnd += 1;\n    };\n\n    const pushInsertLine = (line: string): void => {\n        const j = lines.length;\n        lines.push(printInsertLine(line, j === 0 || j === jLast, options));\n        bEnd += 1;\n    };\n\n    // Second pass: push lines with diff formatting (and patch marks, if needed).\n    i = 0;\n    while (i !== iLength) {\n        let iStart = i;\n        while (i !== iLength && diffs[i][0] === DIFF_EQUAL) {\n            i += 1;\n        }\n\n        if (iStart !== i) {\n            if (iStart === 0) {\n                // at beginning\n                if (i > nContextLines) {\n                    iStart = i - nContextLines;\n                    aStart = iStart;\n                    bStart = iStart;\n                    aEnd = aStart;\n                    bEnd = bStart;\n                }\n\n                for (let iCommon = iStart; iCommon !== i; iCommon += 1) {\n                    pushCommonLine(diffs[iCommon][1]);\n                }\n            } else if (i === iLength) {\n                // at end\n                const iEnd =\n                    i - iStart > nContextLines ? iStart + nContextLines : i;\n\n                for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1) {\n                    pushCommonLine(diffs[iCommon][1]);\n                }\n            } else {\n                // between changes\n                const nCommon = i - iStart;\n\n                if (nCommon > nContextLines2) {\n                    const iEnd = iStart + nContextLines;\n\n                    for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1) {\n                        pushCommonLine(diffs[iCommon][1]);\n                    }\n\n                    lines[jPatchMark] = createPatchMark(\n                        aStart,\n                        aEnd,\n                        bStart,\n                        bEnd,\n                        options\n                    );\n                    jPatchMark = lines.length;\n                    lines.push(''); // placeholder line for next patch mark\n\n                    const nOmit = nCommon - nContextLines2;\n                    aStart = aEnd + nOmit;\n                    bStart = bEnd + nOmit;\n                    aEnd = aStart;\n                    bEnd = bStart;\n\n                    for (\n                        let iCommon = i - nContextLines;\n                        iCommon !== i;\n                        iCommon += 1\n                    ) {\n                        pushCommonLine(diffs[iCommon][1]);\n                    }\n                } else {\n                    for (let iCommon = iStart; iCommon !== i; iCommon += 1) {\n                        pushCommonLine(diffs[iCommon][1]);\n                    }\n                }\n            }\n        }\n\n        while (i !== iLength && diffs[i][0] === DIFF_DELETE) {\n            pushDeleteLine(diffs[i][1]);\n            i += 1;\n        }\n\n        while (i !== iLength && diffs[i][0] === DIFF_INSERT) {\n            pushInsertLine(diffs[i][1]);\n            i += 1;\n        }\n    }\n\n    if (hasPatch) {\n        lines[jPatchMark] = createPatchMark(\n            aStart,\n            aEnd,\n            bStart,\n            bEnd,\n            options\n        );\n    }\n\n    return lines.join('\\n');\n};\n\n// jest --expand\n//\n// Given array of aligned strings with inverse highlight formatting,\n// return joined lines with diff formatting.\nexport const joinAlignedDiffsExpand = (\n    diffs: Array<Diff>,\n    options: DiffOptionsNormalized\n): string =>\n    diffs\n        .map((diff: Diff, i: number, diffs: Array<Diff>): string => {\n            const line = diff[1];\n            const isFirstOrLast = i === 0 || i === diffs.length - 1;\n\n            switch (diff[0]) {\n                case DIFF_DELETE:\n                    return printDeleteLine(line, isFirstOrLast, options);\n\n                case DIFF_INSERT:\n                    return printInsertLine(line, isFirstOrLast, options);\n\n                default:\n                    return printCommonLine(line, isFirstOrLast, options);\n            }\n        })\n        .join('\\n');\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk from '@casual-simulation/chalk';\nimport type { CompareKeys } from '../pretty-format';\nimport type { DiffOptions, DiffOptionsNormalized } from './types';\n\nexport const noColor = (string: string): string => string;\n\nconst DIFF_CONTEXT_DEFAULT = 5;\n\nconst OPTIONS_DEFAULT: DiffOptionsNormalized = {\n    aAnnotation: 'Expected',\n    aColor: chalk.green,\n    aIndicator: '-',\n    bAnnotation: 'Received',\n    bColor: chalk.red,\n    bIndicator: '+',\n    changeColor: chalk.inverse,\n    changeLineTrailingSpaceColor: noColor,\n    commonColor: chalk.dim,\n    commonIndicator: ' ',\n    commonLineTrailingSpaceColor: noColor,\n    compareKeys: undefined,\n    contextLines: DIFF_CONTEXT_DEFAULT,\n    emptyFirstOrLastLinePlaceholder: '',\n    expand: true,\n    includeChangeCounts: false,\n    omitAnnotationLines: false,\n    patchColor: chalk.yellow,\n};\n\nconst getCompareKeys = (compareKeys?: CompareKeys): CompareKeys =>\n    compareKeys && typeof compareKeys === 'function'\n        ? compareKeys\n        : OPTIONS_DEFAULT.compareKeys;\n\nconst getContextLines = (contextLines?: number): number =>\n    typeof contextLines === 'number' &&\n    Number.isSafeInteger(contextLines) &&\n    contextLines >= 0\n        ? contextLines\n        : DIFF_CONTEXT_DEFAULT;\n\n// Pure function returns options with all properties.\nexport const normalizeDiffOptions = (\n    options: DiffOptions = {}\n): DiffOptionsNormalized => ({\n    ...OPTIONS_DEFAULT,\n    ...options,\n    compareKeys: getCompareKeys(options.compareKeys),\n    contextLines: getContextLines(options.contextLines),\n});\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport diff from '../diff-sequences';\nimport { DIFF_DELETE, DIFF_EQUAL, DIFF_INSERT, Diff } from './cleanupSemantic';\nimport {\n    joinAlignedDiffsExpand,\n    joinAlignedDiffsNoExpand,\n} from './joinAlignedDiffs';\nimport { normalizeDiffOptions } from './normalizeDiffOptions';\nimport type { DiffOptions, DiffOptionsNormalized } from './types';\n\nconst isEmptyString = (lines: Array<string>) =>\n    lines.length === 1 && lines[0].length === 0;\n\ntype ChangeCounts = {\n    a: number;\n    b: number;\n};\n\nconst countChanges = (diffs: Array<Diff>): ChangeCounts => {\n    let a = 0;\n    let b = 0;\n\n    diffs.forEach((diff) => {\n        switch (diff[0]) {\n            case DIFF_DELETE:\n                a += 1;\n                break;\n\n            case DIFF_INSERT:\n                b += 1;\n                break;\n        }\n    });\n\n    return { a, b };\n};\n\nconst printAnnotation = (\n    {\n        aAnnotation,\n        aColor,\n        aIndicator,\n        bAnnotation,\n        bColor,\n        bIndicator,\n        includeChangeCounts,\n        omitAnnotationLines,\n    }: DiffOptionsNormalized,\n    changeCounts: ChangeCounts\n): string => {\n    if (omitAnnotationLines) {\n        return '';\n    }\n\n    let aRest = '';\n    let bRest = '';\n\n    if (includeChangeCounts) {\n        const aCount = String(changeCounts.a);\n        const bCount = String(changeCounts.b);\n\n        // Padding right aligns the ends of the annotations.\n        const baAnnotationLengthDiff = bAnnotation.length - aAnnotation.length;\n        const aAnnotationPadding = ' '.repeat(\n            Math.max(0, baAnnotationLengthDiff)\n        );\n        const bAnnotationPadding = ' '.repeat(\n            Math.max(0, -baAnnotationLengthDiff)\n        );\n\n        // Padding left aligns the ends of the counts.\n        const baCountLengthDiff = bCount.length - aCount.length;\n        const aCountPadding = ' '.repeat(Math.max(0, baCountLengthDiff));\n        const bCountPadding = ' '.repeat(Math.max(0, -baCountLengthDiff));\n\n        aRest =\n            aAnnotationPadding +\n            '  ' +\n            aIndicator +\n            ' ' +\n            aCountPadding +\n            aCount;\n        bRest =\n            bAnnotationPadding +\n            '  ' +\n            bIndicator +\n            ' ' +\n            bCountPadding +\n            bCount;\n    }\n\n    return (\n        aColor(aIndicator + ' ' + aAnnotation + aRest) +\n        '\\n' +\n        bColor(bIndicator + ' ' + bAnnotation + bRest) +\n        '\\n\\n'\n    );\n};\n\nexport const printDiffLines = (\n    diffs: Array<Diff>,\n    options: DiffOptionsNormalized\n): string =>\n    printAnnotation(options, countChanges(diffs)) +\n    (options.expand\n        ? joinAlignedDiffsExpand(diffs, options)\n        : joinAlignedDiffsNoExpand(diffs, options));\n\n// Compare two arrays of strings line-by-line. Format as comparison lines.\nexport const diffLinesUnified = (\n    aLines: Array<string>,\n    bLines: Array<string>,\n    options?: DiffOptions\n): string =>\n    printDiffLines(\n        diffLinesRaw(\n            isEmptyString(aLines) ? [] : aLines,\n            isEmptyString(bLines) ? [] : bLines\n        ),\n        normalizeDiffOptions(options)\n    );\n\n// Given two pairs of arrays of strings:\n// Compare the pair of comparison arrays line-by-line.\n// Format the corresponding lines in the pair of displayable arrays.\nexport const diffLinesUnified2 = (\n    aLinesDisplay: Array<string>,\n    bLinesDisplay: Array<string>,\n    aLinesCompare: Array<string>,\n    bLinesCompare: Array<string>,\n    options?: DiffOptions\n): string => {\n    if (isEmptyString(aLinesDisplay) && isEmptyString(aLinesCompare)) {\n        aLinesDisplay = [];\n        aLinesCompare = [];\n    }\n    if (isEmptyString(bLinesDisplay) && isEmptyString(bLinesCompare)) {\n        bLinesDisplay = [];\n        bLinesCompare = [];\n    }\n\n    if (\n        aLinesDisplay.length !== aLinesCompare.length ||\n        bLinesDisplay.length !== bLinesCompare.length\n    ) {\n        // Fall back to diff of display lines.\n        return diffLinesUnified(aLinesDisplay, bLinesDisplay, options);\n    }\n\n    const diffs = diffLinesRaw(aLinesCompare, bLinesCompare);\n\n    // Replace comparison lines with displayable lines.\n    let aIndex = 0;\n    let bIndex = 0;\n    diffs.forEach((diff: Diff) => {\n        switch (diff[0]) {\n            case DIFF_DELETE:\n                diff[1] = aLinesDisplay[aIndex];\n                aIndex += 1;\n                break;\n\n            case DIFF_INSERT:\n                diff[1] = bLinesDisplay[bIndex];\n                bIndex += 1;\n                break;\n\n            default:\n                diff[1] = bLinesDisplay[bIndex];\n                aIndex += 1;\n                bIndex += 1;\n        }\n    });\n\n    return printDiffLines(diffs, normalizeDiffOptions(options));\n};\n\n// Compare two arrays of strings line-by-line.\nexport const diffLinesRaw = (\n    aLines: Array<string>,\n    bLines: Array<string>\n): Array<Diff> => {\n    const aLength = aLines.length;\n    const bLength = bLines.length;\n\n    const isCommon = (aIndex: number, bIndex: number) =>\n        aLines[aIndex] === bLines[bIndex];\n\n    const diffs: Array<Diff> = [];\n    let aIndex = 0;\n    let bIndex = 0;\n\n    const foundSubsequence = (\n        nCommon: number,\n        aCommon: number,\n        bCommon: number\n    ) => {\n        for (; aIndex !== aCommon; aIndex += 1) {\n            diffs.push(new Diff(DIFF_DELETE, aLines[aIndex]));\n        }\n        for (; bIndex !== bCommon; bIndex += 1) {\n            diffs.push(new Diff(DIFF_INSERT, bLines[bIndex]));\n        }\n        for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n            diffs.push(new Diff(DIFF_EQUAL, bLines[bIndex]));\n        }\n    };\n\n    diff(aLength, bLength, isCommon, foundSubsequence);\n\n    // After the last common subsequence, push remaining change items.\n    for (; aIndex !== aLength; aIndex += 1) {\n        diffs.push(new Diff(DIFF_DELETE, aLines[aIndex]));\n    }\n    for (; bIndex !== bLength; bIndex += 1) {\n        diffs.push(new Diff(DIFF_INSERT, bLines[bIndex]));\n    }\n\n    return diffs;\n};\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport diffSequences from '../diff-sequences';\nimport { DIFF_DELETE, DIFF_EQUAL, DIFF_INSERT, Diff } from './cleanupSemantic';\n\nconst diffStrings = (a: string, b: string): Array<Diff> => {\n    const isCommon = (aIndex: number, bIndex: number) =>\n        a[aIndex] === b[bIndex];\n\n    let aIndex = 0;\n    let bIndex = 0;\n    const diffs: Array<Diff> = [];\n\n    const foundSubsequence = (\n        nCommon: number,\n        aCommon: number,\n        bCommon: number\n    ) => {\n        if (aIndex !== aCommon) {\n            diffs.push(new Diff(DIFF_DELETE, a.slice(aIndex, aCommon)));\n        }\n        if (bIndex !== bCommon) {\n            diffs.push(new Diff(DIFF_INSERT, b.slice(bIndex, bCommon)));\n        }\n\n        aIndex = aCommon + nCommon; // number of characters compared in a\n        bIndex = bCommon + nCommon; // number of characters compared in b\n        diffs.push(new Diff(DIFF_EQUAL, b.slice(bCommon, bIndex)));\n    };\n\n    diffSequences(a.length, b.length, isCommon, foundSubsequence);\n\n    // After the last common subsequence, push remaining change items.\n    if (aIndex !== a.length) {\n        diffs.push(new Diff(DIFF_DELETE, a.slice(aIndex)));\n    }\n    if (bIndex !== b.length) {\n        diffs.push(new Diff(DIFF_INSERT, b.slice(bIndex)));\n    }\n\n    return diffs;\n};\n\nexport default diffStrings;\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport { DIFF_DELETE, DIFF_EQUAL, DIFF_INSERT, Diff } from './cleanupSemantic';\nimport type { DiffOptionsColor } from './types';\n\n// Given change op and array of diffs, return concatenated string:\n// * include common strings\n// * include change strings which have argument op with changeColor\n// * exclude change strings which have opposite op\nconst concatenateRelevantDiffs = (\n    op: number,\n    diffs: Array<Diff>,\n    changeColor: DiffOptionsColor\n): string =>\n    diffs.reduce(\n        (reduced: string, diff: Diff): string =>\n            reduced +\n            (diff[0] === DIFF_EQUAL\n                ? diff[1]\n                : diff[0] === op && diff[1].length !== 0 // empty if change is newline\n                ? changeColor(diff[1])\n                : ''),\n        ''\n    );\n\n// Encapsulate change lines until either a common newline or the end.\nclass ChangeBuffer {\n    private op: number;\n    private line: Array<Diff>; // incomplete line\n    private lines: Array<Diff>; // complete lines\n    private changeColor: DiffOptionsColor;\n\n    constructor(op: number, changeColor: DiffOptionsColor) {\n        this.op = op;\n        this.line = [];\n        this.lines = [];\n        this.changeColor = changeColor;\n    }\n\n    private pushSubstring(substring: string): void {\n        this.pushDiff(new Diff(this.op, substring));\n    }\n\n    private pushLine(): void {\n        // Assume call only if line has at least one diff,\n        // therefore an empty line must have a diff which has an empty string.\n\n        // If line has multiple diffs, then assume it has a common diff,\n        // therefore change diffs have change color;\n        // otherwise then it has line color only.\n        this.lines.push(\n            this.line.length !== 1\n                ? new Diff(\n                      this.op,\n                      concatenateRelevantDiffs(\n                          this.op,\n                          this.line,\n                          this.changeColor\n                      )\n                  )\n                : this.line[0][0] === this.op\n                ? this.line[0] // can use instance\n                : new Diff(this.op, this.line[0][1]) // was common diff\n        );\n        this.line.length = 0;\n    }\n\n    isLineEmpty() {\n        return this.line.length === 0;\n    }\n\n    // Minor input to buffer.\n    pushDiff(diff: Diff): void {\n        this.line.push(diff);\n    }\n\n    // Main input to buffer.\n    align(diff: Diff): void {\n        const string = diff[1];\n\n        if (string.includes('\\n')) {\n            const substrings = string.split('\\n');\n            const iLast = substrings.length - 1;\n            substrings.forEach((substring, i) => {\n                if (i < iLast) {\n                    // The first substring completes the current change line.\n                    // A middle substring is a change line.\n                    this.pushSubstring(substring);\n                    this.pushLine();\n                } else if (substring.length !== 0) {\n                    // The last substring starts a change line, if it is not empty.\n                    // Important: This non-empty condition also automatically omits\n                    // the newline appended to the end of expected and received strings.\n                    this.pushSubstring(substring);\n                }\n            });\n        } else {\n            // Append non-multiline string to current change line.\n            this.pushDiff(diff);\n        }\n    }\n\n    // Output from buffer.\n    moveLinesTo(lines: Array<Diff>): void {\n        if (!this.isLineEmpty()) {\n            this.pushLine();\n        }\n\n        lines.push(...this.lines);\n        this.lines.length = 0;\n    }\n}\n\n// Encapsulate common and change lines.\nclass CommonBuffer {\n    private deleteBuffer: ChangeBuffer;\n    private insertBuffer: ChangeBuffer;\n    private lines: Array<Diff>;\n\n    constructor(deleteBuffer: ChangeBuffer, insertBuffer: ChangeBuffer) {\n        this.deleteBuffer = deleteBuffer;\n        this.insertBuffer = insertBuffer;\n        this.lines = [];\n    }\n\n    private pushDiffCommonLine(diff: Diff): void {\n        this.lines.push(diff);\n    }\n\n    private pushDiffChangeLines(diff: Diff): void {\n        const isDiffEmpty = diff[1].length === 0;\n\n        // An empty diff string is redundant, unless a change line is empty.\n        if (!isDiffEmpty || this.deleteBuffer.isLineEmpty()) {\n            this.deleteBuffer.pushDiff(diff);\n        }\n        if (!isDiffEmpty || this.insertBuffer.isLineEmpty()) {\n            this.insertBuffer.pushDiff(diff);\n        }\n    }\n\n    private flushChangeLines(): void {\n        this.deleteBuffer.moveLinesTo(this.lines);\n        this.insertBuffer.moveLinesTo(this.lines);\n    }\n\n    // Input to buffer.\n    align(diff: Diff): void {\n        const op = diff[0];\n        const string = diff[1];\n\n        if (string.includes('\\n')) {\n            const substrings = string.split('\\n');\n            const iLast = substrings.length - 1;\n            substrings.forEach((substring, i) => {\n                if (i === 0) {\n                    const subdiff = new Diff(op, substring);\n                    if (\n                        this.deleteBuffer.isLineEmpty() &&\n                        this.insertBuffer.isLineEmpty()\n                    ) {\n                        // If both current change lines are empty,\n                        // then the first substring is a common line.\n                        this.flushChangeLines();\n                        this.pushDiffCommonLine(subdiff);\n                    } else {\n                        // If either current change line is non-empty,\n                        // then the first substring completes the change lines.\n                        this.pushDiffChangeLines(subdiff);\n                        this.flushChangeLines();\n                    }\n                } else if (i < iLast) {\n                    // A middle substring is a common line.\n                    this.pushDiffCommonLine(new Diff(op, substring));\n                } else if (substring.length !== 0) {\n                    // The last substring starts a change line, if it is not empty.\n                    // Important: This non-empty condition also automatically omits\n                    // the newline appended to the end of expected and received strings.\n                    this.pushDiffChangeLines(new Diff(op, substring));\n                }\n            });\n        } else {\n            // Append non-multiline string to current change lines.\n            // Important: It cannot be at the end following empty change lines,\n            // because newline appended to the end of expected and received strings.\n            this.pushDiffChangeLines(diff);\n        }\n    }\n\n    // Output from buffer.\n    getLines(): Array<Diff> {\n        this.flushChangeLines();\n        return this.lines;\n    }\n}\n\n// Given diffs from expected and received strings,\n// return new array of diffs split or joined into lines.\n//\n// To correctly align a change line at the end, the algorithm:\n// * assumes that a newline was appended to the strings\n// * omits the last newline from the output array\n//\n// Assume the function is not called:\n// * if either expected or received is empty string\n// * if neither expected nor received is multiline string\nconst getAlignedDiffs = (\n    diffs: Array<Diff>,\n    changeColor: DiffOptionsColor\n): Array<Diff> => {\n    const deleteBuffer = new ChangeBuffer(DIFF_DELETE, changeColor);\n    const insertBuffer = new ChangeBuffer(DIFF_INSERT, changeColor);\n    const commonBuffer = new CommonBuffer(deleteBuffer, insertBuffer);\n\n    diffs.forEach((diff) => {\n        switch (diff[0]) {\n            case DIFF_DELETE:\n                deleteBuffer.align(diff);\n                break;\n\n            case DIFF_INSERT:\n                insertBuffer.align(diff);\n                break;\n\n            default:\n                commonBuffer.align(diff);\n        }\n    });\n\n    return commonBuffer.getLines();\n};\n\nexport default getAlignedDiffs;\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport { DIFF_EQUAL, Diff, cleanupSemantic } from './cleanupSemantic';\nimport { diffLinesUnified, printDiffLines } from './diffLines';\nimport diffStrings from './diffStrings';\nimport getAlignedDiffs from './getAlignedDiffs';\nimport { normalizeDiffOptions } from './normalizeDiffOptions';\nimport type { DiffOptions } from './types';\n\nconst hasCommonDiff = (diffs: Array<Diff>, isMultiline: boolean): boolean => {\n    if (isMultiline) {\n        // Important: Ignore common newline that was appended to multiline strings!\n        const iLast = diffs.length - 1;\n        return diffs.some(\n            (diff, i) =>\n                diff[0] === DIFF_EQUAL && (i !== iLast || diff[1] !== '\\n')\n        );\n    }\n\n    return diffs.some((diff) => diff[0] === DIFF_EQUAL);\n};\n\n// Compare two strings character-by-character.\n// Format as comparison lines in which changed substrings have inverse colors.\nexport const diffStringsUnified = (\n    a: string,\n    b: string,\n    options?: DiffOptions\n): string => {\n    if (a !== b && a.length !== 0 && b.length !== 0) {\n        const isMultiline = a.includes('\\n') || b.includes('\\n');\n\n        // getAlignedDiffs assumes that a newline was appended to the strings.\n        const diffs = diffStringsRaw(\n            isMultiline ? a + '\\n' : a,\n            isMultiline ? b + '\\n' : b,\n            true // cleanupSemantic\n        );\n\n        if (hasCommonDiff(diffs, isMultiline)) {\n            const optionsNormalized = normalizeDiffOptions(options);\n            const lines = getAlignedDiffs(diffs, optionsNormalized.changeColor);\n            return printDiffLines(lines, optionsNormalized);\n        }\n    }\n\n    // Fall back to line-by-line diff.\n    return diffLinesUnified(a.split('\\n'), b.split('\\n'), options);\n};\n\n// Compare two strings character-by-character.\n// Optionally clean up small common substrings, also known as chaff.\nexport const diffStringsRaw = (\n    a: string,\n    b: string,\n    cleanup: boolean\n): Array<Diff> => {\n    const diffs = diffStrings(a, b);\n\n    if (cleanup) {\n        cleanupSemantic(diffs); // impure function\n    }\n\n    return diffs;\n};\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk from '@casual-simulation/chalk';\nimport { getType } from '../get-type';\nimport {\n    format as prettyFormat,\n    plugins as prettyFormatPlugins,\n} from '../pretty-format';\nimport type { PrettyFormatOptions } from '../pretty-format';\nimport { DIFF_DELETE, DIFF_EQUAL, DIFF_INSERT, Diff } from './cleanupSemantic';\nimport { NO_DIFF_MESSAGE, SIMILAR_MESSAGE } from './constants';\nimport { diffLinesRaw, diffLinesUnified, diffLinesUnified2 } from './diffLines';\nimport { normalizeDiffOptions } from './normalizeDiffOptions';\nimport { diffStringsRaw, diffStringsUnified } from './printDiffs';\nimport type { DiffOptions } from './types';\n\nexport type { DiffOptions, DiffOptionsColor } from './types';\n\nexport { diffLinesRaw, diffLinesUnified, diffLinesUnified2 };\nexport { diffStringsRaw, diffStringsUnified };\nexport { DIFF_DELETE, DIFF_EQUAL, DIFF_INSERT, Diff };\n\nconst getCommonMessage = (message: string, options?: DiffOptions) => {\n    const { commonColor } = normalizeDiffOptions(options);\n    return commonColor(message);\n};\n\nconst {\n    AsymmetricMatcher,\n    DOMCollection,\n    DOMElement,\n    Immutable,\n    ReactTestComponent,\n} = prettyFormatPlugins;\n\nconst PLUGINS = [\n    ReactTestComponent,\n    DOMElement,\n    DOMCollection,\n    Immutable,\n    AsymmetricMatcher,\n];\nconst FORMAT_OPTIONS = {\n    plugins: PLUGINS,\n};\nconst FALLBACK_FORMAT_OPTIONS = {\n    callToJSON: false,\n    maxDepth: 10,\n    plugins: PLUGINS,\n};\n\n// Generate a string that will highlight the difference between two values\n// with green and red. (similar to how github does code diffing)\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function diff(a: any, b: any, options?: DiffOptions): string | null {\n    if (Object.is(a, b)) {\n        return getCommonMessage(NO_DIFF_MESSAGE, options);\n    }\n\n    const aType = getType(a);\n    let expectedType = aType;\n    let omitDifference = false;\n    if (aType === 'object' && typeof a.asymmetricMatch === 'function') {\n        if (a.$$typeof !== Symbol.for('jest.asymmetricMatcher')) {\n            // Do not know expected type of user-defined asymmetric matcher.\n            return null;\n        }\n        if (typeof a.getExpectedType !== 'function') {\n            // For example, expect.anything() matches either null or undefined\n            return null;\n        }\n        expectedType = a.getExpectedType();\n        // Primitive types boolean and number omit difference below.\n        // For example, omit difference for expect.stringMatching(regexp)\n        omitDifference = expectedType === 'string';\n    }\n\n    if (expectedType !== getType(b)) {\n        return (\n            '  Comparing two different types of values.' +\n            ` Expected ${chalk.green(expectedType)} but ` +\n            `received ${chalk.red(getType(b))}.`\n        );\n    }\n\n    if (omitDifference) {\n        return null;\n    }\n\n    switch (aType) {\n        case 'string':\n            return diffLinesUnified(a.split('\\n'), b.split('\\n'), options);\n        case 'boolean':\n        case 'number':\n            return comparePrimitive(a, b, options);\n        case 'map':\n            return compareObjects(sortMap(a), sortMap(b), options);\n        case 'set':\n            return compareObjects(sortSet(a), sortSet(b), options);\n        default:\n            return compareObjects(a, b, options);\n    }\n}\n\nfunction comparePrimitive(\n    a: number | boolean,\n    b: number | boolean,\n    options?: DiffOptions\n) {\n    const aFormat = prettyFormat(a, FORMAT_OPTIONS);\n    const bFormat = prettyFormat(b, FORMAT_OPTIONS);\n    return aFormat === bFormat\n        ? getCommonMessage(NO_DIFF_MESSAGE, options)\n        : diffLinesUnified(aFormat.split('\\n'), bFormat.split('\\n'), options);\n}\n\nfunction sortMap(map: Map<unknown, unknown>) {\n    return new Map(Array.from(map.entries()).sort());\n}\n\nfunction sortSet(set: Set<unknown>) {\n    return new Set(Array.from(set.values()).sort());\n}\n\nfunction compareObjects(\n    a: Record<string, any>,\n    b: Record<string, any>,\n    options?: DiffOptions\n) {\n    let difference;\n    let hasThrown = false;\n\n    try {\n        const formatOptions = getFormatOptions(FORMAT_OPTIONS, options);\n        difference = getObjectsDifference(a, b, formatOptions, options);\n    } catch {\n        hasThrown = true;\n    }\n\n    const noDiffMessage = getCommonMessage(NO_DIFF_MESSAGE, options);\n    // If the comparison yields no results, compare again but this time\n    // without calling `toJSON`. It's also possible that toJSON might throw.\n    if (difference === undefined || difference === noDiffMessage) {\n        const formatOptions = getFormatOptions(\n            FALLBACK_FORMAT_OPTIONS,\n            options\n        );\n        difference = getObjectsDifference(a, b, formatOptions, options);\n\n        if (difference !== noDiffMessage && !hasThrown) {\n            difference =\n                getCommonMessage(SIMILAR_MESSAGE, options) +\n                '\\n\\n' +\n                difference;\n        }\n    }\n\n    return difference;\n}\n\nfunction getFormatOptions(\n    formatOptions: PrettyFormatOptions,\n    options?: DiffOptions\n): PrettyFormatOptions {\n    const { compareKeys } = normalizeDiffOptions(options);\n\n    return {\n        ...formatOptions,\n        compareKeys,\n    };\n}\n\nfunction getObjectsDifference(\n    a: Record<string, any>,\n    b: Record<string, any>,\n    formatOptions: PrettyFormatOptions,\n    options?: DiffOptions\n): string {\n    const formatOptionsZeroIndent = { ...formatOptions, indent: 0 };\n    const aCompare = prettyFormat(a, formatOptionsZeroIndent);\n    const bCompare = prettyFormat(b, formatOptionsZeroIndent);\n\n    if (aCompare === bCompare) {\n        return getCommonMessage(NO_DIFF_MESSAGE, options);\n    } else {\n        const aDisplay = prettyFormat(a, formatOptions);\n        const bDisplay = prettyFormat(b, formatOptions);\n\n        return diffLinesUnified2(\n            aDisplay.split('\\n'),\n            bDisplay.split('\\n'),\n            aCompare.split('\\n'),\n            bCompare.split('\\n'),\n            options\n        );\n    }\n}\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport { getType } from '../get-type';\n\nconst supportTypes = ['map', 'array', 'object'];\n\ntype ReplaceableForEachCallBack = (\n    value: unknown,\n    key: unknown,\n    object: unknown\n) => void;\n\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\nexport default class Replaceable {\n    object: any;\n    type: string;\n\n    constructor(object: any) {\n        this.object = object;\n        this.type = getType(object);\n        if (!supportTypes.includes(this.type)) {\n            throw new Error(`Type ${this.type} is not support in Replaceable!`);\n        }\n    }\n\n    static isReplaceable(obj1: unknown, obj2: unknown): boolean {\n        const obj1Type = getType(obj1);\n        const obj2Type = getType(obj2);\n        return obj1Type === obj2Type && supportTypes.includes(obj1Type);\n    }\n\n    forEach(cb: ReplaceableForEachCallBack): void {\n        if (this.type === 'object') {\n            const descriptors = Object.getOwnPropertyDescriptors(this.object);\n            [\n                ...Object.keys(descriptors),\n                ...Object.getOwnPropertySymbols(descriptors),\n            ]\n                //@ts-expect-error because typescript do not support symbol key in object\n                //https://github.com/microsoft/TypeScript/issues/1863\n                .filter((key) => descriptors[key].enumerable)\n                .forEach((key) => {\n                    cb(this.object[key], key, this.object);\n                });\n        } else {\n            this.object.forEach(cb);\n        }\n    }\n\n    get(key: any): any {\n        if (this.type === 'map') {\n            return this.object.get(key);\n        }\n        return this.object[key];\n    }\n\n    set(key: any, value: any): void {\n        if (this.type === 'map') {\n            this.object.set(key, value);\n        } else {\n            this.object[key] = value;\n        }\n    }\n}\n/* eslint-enable */\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport { plugins } from '../pretty-format';\n\nconst builtInObject: Array<unknown> = [\n    Array,\n    Date,\n    Float32Array,\n    Float64Array,\n    Int16Array,\n    Int32Array,\n    Int8Array,\n    Map,\n    Set,\n    RegExp,\n    Uint16Array,\n    Uint32Array,\n    Uint8Array,\n    Uint8ClampedArray,\n];\n\nif (typeof Buffer !== 'undefined') {\n    builtInObject.push(Buffer);\n}\n\nconst isBuiltInObject = (object: any) =>\n    builtInObject.includes(object.constructor);\n\nconst isMap = (value: any): value is Map<unknown, unknown> =>\n    value.constructor === Map;\n\nexport default function deepCyclicCopyReplaceable<T>(\n    value: T,\n    cycles: WeakMap<any, any> = new WeakMap()\n): T {\n    if (typeof value !== 'object' || value === null) {\n        return value;\n    } else if (cycles.has(value)) {\n        return cycles.get(value);\n    } else if (Array.isArray(value)) {\n        return deepCyclicCopyArray(value, cycles);\n    } else if (isMap(value)) {\n        return deepCyclicCopyMap(value, cycles);\n    } else if (isBuiltInObject(value)) {\n        return value;\n    } else if (plugins.DOMElement.test(value)) {\n        return (value as unknown as Element).cloneNode(true) as unknown as T;\n    } else {\n        return deepCyclicCopyObject(value, cycles);\n    }\n}\n\nfunction deepCyclicCopyObject<T>(object: T, cycles: WeakMap<any, unknown>): T {\n    const newObject = Object.create(Object.getPrototypeOf(object));\n    const descriptors: {\n        [x: string]: PropertyDescriptor;\n    } = Object.getOwnPropertyDescriptors(object);\n\n    cycles.set(object, newObject);\n\n    const newDescriptors = [\n        ...Object.keys(descriptors),\n        ...Object.getOwnPropertySymbols(descriptors),\n    ].reduce(\n        // @ts-ignore because typescript do not support symbol key in object\n        // https://github.com/microsoft/TypeScript/issues/1863\n        (newDescriptors: { [x: string]: PropertyDescriptor }, key: string) => {\n            const enumerable = descriptors[key].enumerable;\n\n            newDescriptors[key] = {\n                configurable: true,\n                enumerable,\n                value: deepCyclicCopyReplaceable(\n                    // this accesses the value or getter, depending. We just care about the value anyways, and this allows us to not mess with accessors\n                    // it has the side effect of invoking the getter here though, rather than copying it over\n                    (object as Record<string | symbol, unknown>)[key],\n                    cycles\n                ),\n                writable: true,\n            };\n            return newDescriptors;\n        },\n        {}\n    );\n    // @ts-ignore because typescript do not support symbol key in object\n    //https://github.com/microsoft/TypeScript/issues/1863\n    return Object.defineProperties(newObject, newDescriptors);\n}\n\nfunction deepCyclicCopyArray<T>(\n    array: Array<T>,\n    cycles: WeakMap<any, unknown>\n): T {\n    const newArray = new (Object.getPrototypeOf(array).constructor)(\n        array.length\n    );\n    const length = array.length;\n\n    cycles.set(array, newArray);\n\n    for (let i = 0; i < length; i++) {\n        newArray[i] = deepCyclicCopyReplaceable(array[i], cycles);\n    }\n\n    return newArray;\n}\n\nfunction deepCyclicCopyMap<T>(\n    map: Map<unknown, unknown>,\n    cycles: WeakMap<any, unknown>\n): T {\n    const newMap = new Map();\n\n    cycles.set(map, newMap);\n\n    map.forEach((value, key) => {\n        newMap.set(key, deepCyclicCopyReplaceable(value, cycles));\n    });\n\n    return newMap as any;\n}\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/* eslint-disable local/ban-types-eventually */\n\nimport chalk from '@casual-simulation/chalk';\nimport {\n    DIFF_DELETE,\n    DIFF_EQUAL,\n    DIFF_INSERT,\n    Diff,\n    DiffOptions as ImportDiffOptions,\n    diff as diffDefault,\n    diffStringsRaw,\n    diffStringsUnified,\n} from '../diff';\nimport { getType, isPrimitive } from '../get-type';\nimport {\n    format as prettyFormat,\n    plugins as prettyFormatPlugins,\n} from '../pretty-format';\nimport Replaceable from './Replaceable';\nimport deepCyclicCopyReplaceable from './deepCyclicCopyReplaceable';\n\nconst {\n    AsymmetricMatcher,\n    DOMCollection,\n    DOMElement,\n    Immutable,\n    ReactTestComponent,\n} = prettyFormatPlugins;\n\nconst PLUGINS = [\n    ReactTestComponent,\n    DOMElement,\n    DOMCollection,\n    Immutable,\n    AsymmetricMatcher,\n];\n\ntype MatcherHintColor = (arg: string) => string; // subset of Chalk type\n\nexport type MatcherHintOptions = {\n    comment?: string;\n    expectedColor?: MatcherHintColor;\n    isDirectExpectCall?: boolean;\n    isNot?: boolean;\n    promise?: string;\n    receivedColor?: MatcherHintColor;\n    secondArgument?: string;\n    secondArgumentColor?: MatcherHintColor;\n};\n\nexport type DiffOptions = ImportDiffOptions;\n\nexport const EXPECTED_COLOR = chalk.green;\nexport const RECEIVED_COLOR = chalk.red;\nexport const INVERTED_COLOR = chalk.inverse;\nexport const BOLD_WEIGHT = chalk.bold;\nexport const DIM_COLOR = chalk.dim;\n\nconst MULTILINE_REGEXP = /\\n/;\nconst SPACE_SYMBOL = '\\u{00B7}'; // middle dot\n\nconst NUMBERS = [\n    'zero',\n    'one',\n    'two',\n    'three',\n    'four',\n    'five',\n    'six',\n    'seven',\n    'eight',\n    'nine',\n    'ten',\n    'eleven',\n    'twelve',\n    'thirteen',\n];\n\nexport const SUGGEST_TO_CONTAIN_EQUAL = chalk.dim(\n    'Looks like you wanted to test for object/array equality with the stricter `toContain` matcher. You probably need to use `toContainEqual` instead.'\n);\n\nexport const stringify = (object: unknown, maxDepth: number = 10): string => {\n    const MAX_LENGTH = 10000;\n    let result;\n\n    try {\n        result = prettyFormat(object, {\n            maxDepth,\n            min: true,\n            plugins: PLUGINS,\n        });\n    } catch {\n        result = prettyFormat(object, {\n            callToJSON: false,\n            maxDepth,\n            min: true,\n            plugins: PLUGINS,\n        });\n    }\n\n    return result.length >= MAX_LENGTH && maxDepth > 1\n        ? stringify(object, Math.floor(maxDepth / 2))\n        : result;\n};\n\nexport const highlightTrailingWhitespace = (text: string): string =>\n    text.replace(/\\s+$/gm, chalk.inverse('$&'));\n\n// Instead of inverse highlight which now implies a change,\n// replace common spaces with middle dot at the end of any line.\nconst replaceTrailingSpaces = (text: string): string =>\n    text.replace(/\\s+$/gm, (spaces) => SPACE_SYMBOL.repeat(spaces.length));\n\nexport const printReceived = (object: unknown): string =>\n    RECEIVED_COLOR(replaceTrailingSpaces(stringify(object)));\nexport const printExpected = (value: unknown): string =>\n    EXPECTED_COLOR(replaceTrailingSpaces(stringify(value)));\n\nexport const printWithType = (\n    name: string, // 'Expected' or 'Received'\n    value: unknown,\n    print: (value: unknown) => string // printExpected or printReceived\n): string => {\n    const type = getType(value);\n    const hasType =\n        type !== 'null' && type !== 'undefined'\n            ? `${name} has type:  ${type}\\n`\n            : '';\n    const hasValue = `${name} has value: ${print(value)}`;\n    return hasType + hasValue;\n};\n\nexport const ensureNoExpected = (\n    expected: unknown,\n    matcherName: string,\n    options?: MatcherHintOptions\n): void => {\n    if (typeof expected !== 'undefined') {\n        // Prepend maybe not only for backward compatibility.\n        const matcherString = (options ? '' : '[.not]') + matcherName;\n        throw new Error(\n            matcherErrorMessage(\n                matcherHint(matcherString, undefined, '', options),\n                // Because expected is omitted in hint above,\n                // expected is black instead of green in message below.\n                'this matcher must not have an expected argument',\n                printWithType('Expected', expected, printExpected)\n            )\n        );\n    }\n};\n\n/**\n * Ensures that `actual` is of type `number | bigint`\n */\nexport const ensureActualIsNumber = (\n    actual: unknown,\n    matcherName: string,\n    options?: MatcherHintOptions\n): void => {\n    if (typeof actual !== 'number' && typeof actual !== 'bigint') {\n        // Prepend maybe not only for backward compatibility.\n        const matcherString = (options ? '' : '[.not]') + matcherName;\n        throw new Error(\n            matcherErrorMessage(\n                matcherHint(matcherString, undefined, undefined, options),\n                `${RECEIVED_COLOR(\n                    'received'\n                )} value must be a number or bigint`,\n                printWithType('Received', actual, printReceived)\n            )\n        );\n    }\n};\n\n/**\n * Ensures that `expected` is of type `number | bigint`\n */\nexport const ensureExpectedIsNumber = (\n    expected: unknown,\n    matcherName: string,\n    options?: MatcherHintOptions\n): void => {\n    if (typeof expected !== 'number' && typeof expected !== 'bigint') {\n        // Prepend maybe not only for backward compatibility.\n        const matcherString = (options ? '' : '[.not]') + matcherName;\n        throw new Error(\n            matcherErrorMessage(\n                matcherHint(matcherString, undefined, undefined, options),\n                `${EXPECTED_COLOR(\n                    'expected'\n                )} value must be a number or bigint`,\n                printWithType('Expected', expected, printExpected)\n            )\n        );\n    }\n};\n\n/**\n * Ensures that `actual` & `expected` are of type `number | bigint`\n */\nexport const ensureNumbers = (\n    actual: unknown,\n    expected: unknown,\n    matcherName: string,\n    options?: MatcherHintOptions\n): void => {\n    ensureActualIsNumber(actual, matcherName, options);\n    ensureExpectedIsNumber(expected, matcherName, options);\n};\n\nexport const ensureExpectedIsNonNegativeInteger = (\n    expected: unknown,\n    matcherName: string,\n    options?: MatcherHintOptions\n): void => {\n    if (\n        typeof expected !== 'number' ||\n        !Number.isSafeInteger(expected) ||\n        expected < 0\n    ) {\n        // Prepend maybe not only for backward compatibility.\n        const matcherString = (options ? '' : '[.not]') + matcherName;\n        throw new Error(\n            matcherErrorMessage(\n                matcherHint(matcherString, undefined, undefined, options),\n                `${EXPECTED_COLOR(\n                    'expected'\n                )} value must be a non-negative integer`,\n                printWithType('Expected', expected, printExpected)\n            )\n        );\n    }\n};\n\n// Given array of diffs, return concatenated string:\n// * include common substrings\n// * exclude change substrings which have opposite op\n// * include change substrings which have argument op\n//   with inverse highlight only if there is a common substring\nconst getCommonAndChangedSubstrings = (\n    diffs: Array<Diff>,\n    op: number,\n    hasCommonDiff: boolean\n): string =>\n    diffs.reduce(\n        (reduced: string, diff: Diff): string =>\n            reduced +\n            (diff[0] === DIFF_EQUAL\n                ? diff[1]\n                : diff[0] !== op\n                ? ''\n                : hasCommonDiff\n                ? INVERTED_COLOR(diff[1])\n                : diff[1]),\n        ''\n    );\n\nconst isLineDiffable = (expected: unknown, received: unknown): boolean => {\n    const expectedType = getType(expected);\n    const receivedType = getType(received);\n\n    if (expectedType !== receivedType) {\n        return false;\n    }\n\n    if (isPrimitive(expected)) {\n        // Print generic line diff for strings only:\n        // * if neither string is empty\n        // * if either string has more than one line\n        return (\n            typeof expected === 'string' &&\n            typeof received === 'string' &&\n            expected.length !== 0 &&\n            received.length !== 0 &&\n            (MULTILINE_REGEXP.test(expected) || MULTILINE_REGEXP.test(received))\n        );\n    }\n\n    if (\n        expectedType === 'date' ||\n        expectedType === 'function' ||\n        expectedType === 'regexp'\n    ) {\n        return false;\n    }\n\n    if (expected instanceof Error && received instanceof Error) {\n        return false;\n    }\n\n    if (\n        expectedType === 'object' &&\n        typeof (expected as any).asymmetricMatch === 'function'\n    ) {\n        return false;\n    }\n\n    if (\n        receivedType === 'object' &&\n        typeof (received as any).asymmetricMatch === 'function'\n    ) {\n        return false;\n    }\n\n    return true;\n};\n\nconst MAX_DIFF_STRING_LENGTH = 20000;\n\nexport const printDiffOrStringify = (\n    expected: unknown,\n    received: unknown,\n    expectedLabel: string,\n    receivedLabel: string,\n    expand: boolean // CLI options: true if `--expand` or false if `--no-expand`\n): string => {\n    if (\n        typeof expected === 'string' &&\n        typeof received === 'string' &&\n        expected.length !== 0 &&\n        received.length !== 0 &&\n        expected.length <= MAX_DIFF_STRING_LENGTH &&\n        received.length <= MAX_DIFF_STRING_LENGTH &&\n        expected !== received\n    ) {\n        if (expected.includes('\\n') || received.includes('\\n')) {\n            return diffStringsUnified(expected, received, {\n                aAnnotation: expectedLabel,\n                bAnnotation: receivedLabel,\n                changeLineTrailingSpaceColor: chalk.bgYellow,\n                commonLineTrailingSpaceColor: chalk.bgYellow,\n                emptyFirstOrLastLinePlaceholder: '', // U+21B5\n                expand,\n                includeChangeCounts: true,\n            });\n        }\n\n        const diffs = diffStringsRaw(expected, received, true);\n        const hasCommonDiff = diffs.some((diff) => diff[0] === DIFF_EQUAL);\n\n        const printLabel = getLabelPrinter(expectedLabel, receivedLabel);\n        const expectedLine =\n            printLabel(expectedLabel) +\n            printExpected(\n                getCommonAndChangedSubstrings(diffs, DIFF_DELETE, hasCommonDiff)\n            );\n        const receivedLine =\n            printLabel(receivedLabel) +\n            printReceived(\n                getCommonAndChangedSubstrings(diffs, DIFF_INSERT, hasCommonDiff)\n            );\n\n        return expectedLine + '\\n' + receivedLine;\n    }\n\n    if (isLineDiffable(expected, received)) {\n        const { replacedExpected, replacedReceived } =\n            replaceMatchedToAsymmetricMatcher(\n                deepCyclicCopyReplaceable(expected),\n                deepCyclicCopyReplaceable(received),\n                [],\n                []\n            );\n        const difference = diffDefault(replacedExpected, replacedReceived, {\n            aAnnotation: expectedLabel,\n            bAnnotation: receivedLabel,\n            expand,\n            includeChangeCounts: true,\n        });\n\n        if (\n            typeof difference === 'string' &&\n            difference.includes('- ' + expectedLabel) &&\n            difference.includes('+ ' + receivedLabel)\n        ) {\n            return difference;\n        }\n    }\n\n    const printLabel = getLabelPrinter(expectedLabel, receivedLabel);\n    const expectedLine = printLabel(expectedLabel) + printExpected(expected);\n    const receivedLine =\n        printLabel(receivedLabel) +\n        (stringify(expected) === stringify(received)\n            ? 'serializes to the same string'\n            : printReceived(received));\n\n    return expectedLine + '\\n' + receivedLine;\n};\n\n// Sometimes, e.g. when comparing two numbers, the output from jest-diff\n// does not contain more information than the `Expected:` / `Received:` already gives.\n// In those cases, we do not print a diff to make the output shorter and not redundant.\nconst shouldPrintDiff = (actual: unknown, expected: unknown) => {\n    if (typeof actual === 'number' && typeof expected === 'number') {\n        return false;\n    }\n    if (typeof actual === 'bigint' && typeof expected === 'bigint') {\n        return false;\n    }\n    if (typeof actual === 'boolean' && typeof expected === 'boolean') {\n        return false;\n    }\n    return true;\n};\n\nfunction replaceMatchedToAsymmetricMatcher(\n    replacedExpected: unknown,\n    replacedReceived: unknown,\n    expectedCycles: Array<unknown>,\n    receivedCycles: Array<unknown>\n) {\n    if (!Replaceable.isReplaceable(replacedExpected, replacedReceived)) {\n        return { replacedExpected, replacedReceived };\n    }\n\n    if (\n        expectedCycles.includes(replacedExpected) ||\n        receivedCycles.includes(replacedReceived)\n    ) {\n        return { replacedExpected, replacedReceived };\n    }\n\n    expectedCycles.push(replacedExpected);\n    receivedCycles.push(replacedReceived);\n\n    const expectedReplaceable = new Replaceable(replacedExpected);\n    const receivedReplaceable = new Replaceable(replacedReceived);\n\n    expectedReplaceable.forEach((expectedValue: unknown, key: unknown) => {\n        const receivedValue = receivedReplaceable.get(key);\n        if (isAsymmetricMatcher(expectedValue)) {\n            if (expectedValue.asymmetricMatch(receivedValue)) {\n                receivedReplaceable.set(key, expectedValue);\n            }\n        } else if (isAsymmetricMatcher(receivedValue)) {\n            if (receivedValue.asymmetricMatch(expectedValue)) {\n                expectedReplaceable.set(key, receivedValue);\n            }\n        } else if (Replaceable.isReplaceable(expectedValue, receivedValue)) {\n            const replaced = replaceMatchedToAsymmetricMatcher(\n                expectedValue,\n                receivedValue,\n                expectedCycles,\n                receivedCycles\n            );\n            expectedReplaceable.set(key, replaced.replacedExpected);\n            receivedReplaceable.set(key, replaced.replacedReceived);\n        }\n    });\n\n    return {\n        replacedExpected: expectedReplaceable.object,\n        replacedReceived: receivedReplaceable.object,\n    };\n}\n\ntype AsymmetricMatcher = {\n    asymmetricMatch: Function;\n};\n\nfunction isAsymmetricMatcher(data: any): data is AsymmetricMatcher {\n    const type = getType(data);\n    return type === 'object' && typeof data.asymmetricMatch === 'function';\n}\n\nexport const diff = (\n    a: unknown,\n    b: unknown,\n    options?: DiffOptions\n): string | null => (shouldPrintDiff(a, b) ? diffDefault(a, b, options) : null);\n\nexport const pluralize = (word: string, count: number): string =>\n    (NUMBERS[count] || count) + ' ' + word + (count === 1 ? '' : 's');\n\n// To display lines of labeled values as two columns with monospace alignment:\n// given the strings which will describe the values,\n// return function which given each string, returns the label:\n// string, colon, space, and enough padding spaces to align the value.\n\ntype PrintLabel = (string: string) => string;\n\nexport const getLabelPrinter = (...strings: Array<string>): PrintLabel => {\n    const maxLength = strings.reduce(\n        (max, string) => (string.length > max ? string.length : max),\n        0\n    );\n    return (string: string): string =>\n        `${string}: ${' '.repeat(maxLength - string.length)}`;\n};\n\nexport const matcherErrorMessage = (\n    hint: string, // assertion returned from call to matcherHint\n    generic: string, // condition which correct value must fulfill\n    specific?: string // incorrect value returned from call to printWithType\n): string =>\n    `${hint}\\n\\n${chalk.bold('Matcher error')}: ${generic}${\n        typeof specific === 'string' ? '\\n\\n' + specific : ''\n    }`;\n\n// Display assertion for the report when a test fails.\n// New format: rejects/resolves, not, and matcher name have black color\n// Old format: matcher name has dim color\nexport const matcherHint = (\n    matcherName: string,\n    received: string = 'received',\n    expected: string = 'expected',\n    options: MatcherHintOptions = {}\n): string => {\n    const {\n        comment = '',\n        expectedColor = EXPECTED_COLOR,\n        isDirectExpectCall = false, // seems redundant with received === ''\n        isNot = false,\n        promise = '',\n        receivedColor = RECEIVED_COLOR,\n        secondArgument = '',\n        secondArgumentColor = EXPECTED_COLOR,\n    } = options;\n    let hint = '';\n    let dimString = 'expect'; // concatenate adjacent dim substrings\n\n    if (!isDirectExpectCall && received !== '') {\n        hint += DIM_COLOR(dimString + '(') + receivedColor(received);\n        dimString = ')';\n    }\n\n    if (promise !== '') {\n        hint += DIM_COLOR(dimString + '.') + promise;\n        dimString = '';\n    }\n\n    if (isNot) {\n        hint += DIM_COLOR(dimString + '.') + 'not';\n        dimString = '';\n    }\n\n    if (matcherName.includes('.')) {\n        // Old format: for backward compatibility,\n        // especially without promise or isNot options\n        dimString += matcherName;\n    } else {\n        // New format: omit period from matcherName arg\n        hint += DIM_COLOR(dimString + '.') + matcherName;\n        dimString = '';\n    }\n\n    if (expected === '') {\n        dimString += '()';\n    } else {\n        hint += DIM_COLOR(dimString + '(') + expectedColor(expected);\n        if (secondArgument) {\n            hint += DIM_COLOR(', ') + secondArgumentColor(secondArgument);\n        }\n        dimString = ')';\n    }\n\n    if (comment !== '') {\n        dimString += ' // ' + comment;\n    }\n\n    if (dimString !== '') {\n        hint += DIM_COLOR(dimString);\n    }\n\n    return hint;\n};\n","/*\nCopyright (c) 2008-2016 Pivotal Labs\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/\n\n/* eslint-disable */\n\nimport type { Tester } from './types';\n\n// Extracted out of jasmine 2.5.2\nexport function equals(\n    a: unknown,\n    b: unknown,\n    customTesters?: Array<Tester>,\n    strictCheck?: boolean\n): boolean {\n    customTesters = customTesters || [];\n    return eq(\n        a,\n        b,\n        [],\n        [],\n        customTesters,\n        strictCheck ? hasKey : hasDefinedKey\n    );\n}\n\nconst functionToString = Function.prototype.toString;\n\nfunction isAsymmetric(obj: any) {\n    return !!obj && isA('Function', obj.asymmetricMatch);\n}\n\nfunction asymmetricMatch(a: any, b: any) {\n    var asymmetricA = isAsymmetric(a),\n        asymmetricB = isAsymmetric(b);\n\n    if (asymmetricA && asymmetricB) {\n        return undefined;\n    }\n\n    if (asymmetricA) {\n        return a.asymmetricMatch(b);\n    }\n\n    if (asymmetricB) {\n        return b.asymmetricMatch(a);\n    }\n}\n\n// Equality function lovingly adapted from isEqual in\n//   [Underscore](http://underscorejs.org)\nfunction eq(\n    a: any,\n    b: any,\n    aStack: Array<unknown>,\n    bStack: Array<unknown>,\n    customTesters: Array<Tester>,\n    hasKey: any\n): boolean {\n    var result = true;\n\n    var asymmetricResult = asymmetricMatch(a, b);\n    if (asymmetricResult !== undefined) {\n        return asymmetricResult;\n    }\n\n    for (var i = 0; i < customTesters.length; i++) {\n        var customTesterResult = customTesters[i](a, b);\n        if (customTesterResult !== undefined) {\n            return customTesterResult;\n        }\n    }\n\n    if (a instanceof Error && b instanceof Error) {\n        return a.message == b.message;\n    }\n\n    if (Object.is(a, b)) {\n        return true;\n    }\n    // A strict comparison is necessary because `null == undefined`.\n    if (a === null || b === null) {\n        return a === b;\n    }\n    var className = Object.prototype.toString.call(a);\n    if (className != Object.prototype.toString.call(b)) {\n        return false;\n    }\n    switch (className) {\n        case '[object Boolean]':\n        case '[object String]':\n        case '[object Number]':\n            if (typeof a !== typeof b) {\n                // One is a primitive, one a `new Primitive()`\n                return false;\n            } else if (typeof a !== 'object' && typeof b !== 'object') {\n                // both are proper primitives\n                return Object.is(a, b);\n            } else {\n                // both are `new Primitive()`s\n                return Object.is(a.valueOf(), b.valueOf());\n            }\n        case '[object Date]':\n            // Coerce dates to numeric primitive values. Dates are compared by their\n            // millisecond representations. Note that invalid dates with millisecond representations\n            // of `NaN` are not equivalent.\n            return +a == +b;\n        // RegExps are compared by their source patterns and flags.\n        case '[object RegExp]':\n            return a.source === b.source && a.flags === b.flags;\n    }\n    if (typeof a !== 'object' || typeof b !== 'object') {\n        return false;\n    }\n\n    // Use DOM3 method isEqualNode (IE>=9)\n    if (isDomNode(a) && isDomNode(b)) {\n        return a.isEqualNode(b);\n    }\n\n    // Used to detect circular references.\n    var length = aStack.length;\n    while (length--) {\n        // Linear search. Performance is inversely proportional to the number of\n        // unique nested structures.\n        // circular references at same depth are equal\n        // circular reference is not equal to non-circular one\n        if (aStack[length] === a) {\n            return bStack[length] === b;\n        } else if (bStack[length] === b) {\n            return false;\n        }\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    // Recursively compare objects and arrays.\n    // Compare array lengths to determine if a deep comparison is necessary.\n    if (className == '[object Array]' && a.length !== b.length) {\n        return false;\n    }\n\n    // Deep compare objects.\n    var aKeys = keys(a, hasKey),\n        key;\n    var size = aKeys.length;\n\n    // Ensure that both objects contain the same number of properties before comparing deep equality.\n    if (keys(b, hasKey).length !== size) {\n        return false;\n    }\n\n    while (size--) {\n        key = aKeys[size];\n\n        // Deep compare each member\n        result =\n            hasKey(b, key) &&\n            eq(a[key], b[key], aStack, bStack, customTesters, hasKey);\n\n        if (!result) {\n            return false;\n        }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n\n    return result;\n}\n\nfunction keys(obj: object, hasKey: (obj: object, key: string) => boolean) {\n    var keys = [];\n    for (var key in obj) {\n        if (hasKey(obj, key)) {\n            keys.push(key);\n        }\n    }\n    return keys.concat(\n        (Object.getOwnPropertySymbols(obj) as Array<any>).filter(\n            (symbol) =>\n                (\n                    Object.getOwnPropertyDescriptor(\n                        obj,\n                        symbol\n                    ) as PropertyDescriptor\n                ).enumerable\n        )\n    );\n}\n\nfunction hasDefinedKey(obj: any, key: string) {\n    return hasKey(obj, key) && obj[key] !== undefined;\n}\n\nfunction hasKey(obj: any, key: string) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nexport function isA(typeName: string, value: unknown) {\n    return (\n        Object.prototype.toString.apply(value) === '[object ' + typeName + ']'\n    );\n}\n\nfunction isDomNode(obj: any): boolean {\n    return (\n        obj !== null &&\n        typeof obj === 'object' &&\n        typeof obj.nodeType === 'number' &&\n        typeof obj.nodeName === 'string' &&\n        typeof obj.isEqualNode === 'function'\n    );\n}\n\nexport function fnNameFor(func: Function) {\n    if (func.name) {\n        return func.name;\n    }\n\n    const matches = functionToString\n        .call(func)\n        .match(/^(?:async)?\\s*function\\s*\\*?\\s*([\\w$]+)\\s*\\(/);\n    return matches ? matches[1] : '<anonymous>';\n}\n\nexport function isUndefined(obj: any) {\n    return obj === void 0;\n}\n\nfunction getPrototype(obj: object) {\n    if (Object.getPrototypeOf) {\n        return Object.getPrototypeOf(obj);\n    }\n\n    if (obj.constructor.prototype == obj) {\n        return null;\n    }\n\n    return obj.constructor.prototype;\n}\n\nexport function hasProperty(obj: object | null, property: string): boolean {\n    if (!obj) {\n        return false;\n    }\n\n    if (Object.prototype.hasOwnProperty.call(obj, property)) {\n        return true;\n    }\n\n    return hasProperty(getPrototype(obj), property);\n}\n\n// SENTINEL constants are from https://github.com/facebook/immutable-js\nconst IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\nconst IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';\nconst IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\nexport function isImmutableUnorderedKeyed(maybeKeyed: any) {\n    return !!(\n        maybeKeyed &&\n        maybeKeyed[IS_KEYED_SENTINEL] &&\n        !maybeKeyed[IS_ORDERED_SENTINEL]\n    );\n}\n\nexport function isImmutableUnorderedSet(maybeSet: any) {\n    return !!(\n        maybeSet &&\n        maybeSet[IS_SET_SENTINEL] &&\n        !maybeSet[IS_ORDERED_SENTINEL]\n    );\n}\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { AsymmetricMatcher } from './asymmetricMatchers';\nimport type {\n    Expect,\n    MatcherState,\n    MatchersObject,\n    SyncExpectationResult,\n} from './types';\n\n// Global matchers object holds the list of available matchers and\n// the state, that can hold matcher specific values that change over time.\nconst JEST_MATCHERS_OBJECT = Symbol.for('$$jest-matchers-object');\n\n// Notes a built-in/internal Jest matcher.\n// Jest may override the stack trace of Errors thrown by internal matchers.\nexport const INTERNAL_MATCHER_FLAG = Symbol.for('$$jest-internal-matcher');\n\nif (!global.hasOwnProperty(JEST_MATCHERS_OBJECT)) {\n    const defaultState: Partial<MatcherState> = {\n        assertionCalls: 0,\n        expectedAssertionsNumber: null,\n        isExpectingAssertions: false,\n        suppressedErrors: [], // errors that are not thrown immediately.\n    };\n    Object.defineProperty(global, JEST_MATCHERS_OBJECT, {\n        value: {\n            matchers: Object.create(null),\n            state: defaultState,\n        },\n    });\n}\n\nexport const getState = <State extends MatcherState = MatcherState>(): State =>\n    (global as any)[JEST_MATCHERS_OBJECT].state;\n\nexport const setState = <State extends MatcherState = MatcherState>(\n    state: Partial<State>\n): void => {\n    Object.assign((global as any)[JEST_MATCHERS_OBJECT].state, state);\n};\n\nexport const getMatchers = <\n    State extends MatcherState = MatcherState\n>(): MatchersObject<State> => (global as any)[JEST_MATCHERS_OBJECT].matchers;\n\nexport const setMatchers = <State extends MatcherState = MatcherState>(\n    matchers: MatchersObject<State>,\n    isInternal: boolean,\n    expect: Expect\n): void => {\n    Object.keys(matchers).forEach((key) => {\n        const matcher = matchers[key];\n        Object.defineProperty(matcher, INTERNAL_MATCHER_FLAG, {\n            value: isInternal,\n        });\n\n        if (!isInternal) {\n            // expect is defined\n\n            class CustomMatcher extends AsymmetricMatcher<\n                [unknown, ...Array<unknown>],\n                State\n            > {\n                constructor(\n                    inverse: boolean = false,\n                    ...sample: [unknown, ...Array<unknown>]\n                ) {\n                    super(sample, inverse);\n                }\n\n                asymmetricMatch(other: unknown) {\n                    const { pass } = matcher.call(\n                        this.getMatcherContext(),\n                        other,\n                        ...this.sample\n                    ) as SyncExpectationResult;\n\n                    return this.inverse ? !pass : pass;\n                }\n\n                toString() {\n                    return `${this.inverse ? 'not.' : ''}${key}`;\n                }\n\n                getExpectedType() {\n                    return 'any';\n                }\n\n                toAsymmetricMatcher() {\n                    return `${this.toString()}<${this.sample\n                        .map(String)\n                        .join(', ')}>`;\n                }\n            }\n\n            Object.defineProperty(expect, key, {\n                configurable: true,\n                enumerable: true,\n                value: (...sample: [unknown, ...Array<unknown>]) =>\n                    new CustomMatcher(false, ...sample),\n                writable: true,\n            });\n            Object.defineProperty(expect.not, key, {\n                configurable: true,\n                enumerable: true,\n                value: (...sample: [unknown, ...Array<unknown>]) =>\n                    new CustomMatcher(true, ...sample),\n                writable: true,\n            });\n        }\n    });\n\n    Object.assign((global as any)[JEST_MATCHERS_OBJECT].matchers, matchers);\n};\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/* eslint-disable local/ban-types-eventually */\n\nimport { isPrimitive } from './get-type';\nimport {\n    equals,\n    isA,\n    isImmutableUnorderedKeyed,\n    isImmutableUnorderedSet,\n} from './jasmineUtils';\n\ntype GetPath = {\n    hasEndProp?: boolean;\n    lastTraversedObject: unknown;\n    traversedPath: Array<string>;\n    value?: unknown;\n};\n\n/**\n * Checks if `hasOwnProperty(object, key)` up the prototype chain, stopping at `Object.prototype`.\n */\nconst hasPropertyInObject = (object: object, key: string): boolean => {\n    const shouldTerminate =\n        !object || typeof object !== 'object' || object === Object.prototype;\n\n    if (shouldTerminate) {\n        return false;\n    }\n\n    return (\n        Object.prototype.hasOwnProperty.call(object, key) ||\n        hasPropertyInObject(Object.getPrototypeOf(object), key)\n    );\n};\n\nexport const getPath = (\n    object: Record<string, any>,\n    propertyPath: string | Array<string>\n): GetPath => {\n    if (!Array.isArray(propertyPath)) {\n        propertyPath = (propertyPath as string).split('.');\n    }\n\n    if (propertyPath.length) {\n        const lastProp = propertyPath.length === 1;\n        const prop = propertyPath[0];\n        const newObject = object[prop];\n\n        if (!lastProp && (newObject === null || newObject === undefined)) {\n            // This is not the last prop in the chain. If we keep recursing it will\n            // hit a `can't access property X of undefined | null`. At this point we\n            // know that the chain has broken and we can return right away.\n            return {\n                hasEndProp: false,\n                lastTraversedObject: object,\n                traversedPath: [],\n            };\n        }\n\n        const result = getPath(newObject, propertyPath.slice(1));\n\n        if (result.lastTraversedObject === null) {\n            result.lastTraversedObject = object;\n        }\n\n        result.traversedPath.unshift(prop);\n\n        if (lastProp) {\n            // Does object have the property with an undefined value?\n            // Although primitive values support bracket notation (above)\n            // they would throw TypeError for in operator (below).\n            result.hasEndProp =\n                newObject !== undefined ||\n                (!isPrimitive(object) && prop in object);\n\n            if (!result.hasEndProp) {\n                result.traversedPath.shift();\n            }\n        }\n\n        return result;\n    }\n\n    return {\n        lastTraversedObject: null,\n        traversedPath: [],\n        value: object,\n    };\n};\n\n// Strip properties from object that are not present in the subset. Useful for\n// printing the diff for toMatchObject() without adding unrelated noise.\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\nexport const getObjectSubset = (\n    object: any,\n    subset: any,\n    seenReferences: WeakMap<object, boolean> = new WeakMap()\n): any => {\n    /* eslint-enable @typescript-eslint/explicit-module-boundary-types */\n    if (Array.isArray(object)) {\n        if (Array.isArray(subset) && subset.length === object.length) {\n            // The map method returns correct subclass of subset.\n            return subset.map((sub: any, i: number) =>\n                getObjectSubset(object[i], sub)\n            );\n        }\n    } else if (object instanceof Date) {\n        return object;\n    } else if (isObject(object) && isObject(subset)) {\n        if (equals(object, subset, [iterableEquality, subsetEquality])) {\n            // Avoid unnecessary copy which might return Object instead of subclass.\n            return subset;\n        }\n\n        const trimmed: any = {};\n        seenReferences.set(object, trimmed);\n\n        Object.keys(object)\n            .filter((key) => hasPropertyInObject(subset, key))\n            .forEach((key) => {\n                trimmed[key] = seenReferences.has(object[key])\n                    ? seenReferences.get(object[key])\n                    : getObjectSubset(object[key], subset[key], seenReferences);\n            });\n\n        if (Object.keys(trimmed).length > 0) {\n            return trimmed;\n        }\n    }\n    return object;\n};\n\nconst IteratorSymbol = Symbol.iterator;\n\nconst hasIterator = (object: any) =>\n    !!(object != null && object[IteratorSymbol]);\n\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\nexport const iterableEquality = (\n    a: any,\n    b: any,\n    /* eslint-enable @typescript-eslint/explicit-module-boundary-types */\n    aStack: Array<any> = [],\n    bStack: Array<any> = []\n): boolean | undefined => {\n    if (\n        typeof a !== 'object' ||\n        typeof b !== 'object' ||\n        Array.isArray(a) ||\n        Array.isArray(b) ||\n        !hasIterator(a) ||\n        !hasIterator(b)\n    ) {\n        return undefined;\n    }\n    if (a.constructor !== b.constructor) {\n        return false;\n    }\n    let length = aStack.length;\n    while (length--) {\n        // Linear search. Performance is inversely proportional to the number of\n        // unique nested structures.\n        // circular references at same depth are equal\n        // circular reference is not equal to non-circular one\n        if (aStack[length] === a) {\n            return bStack[length] === b;\n        }\n    }\n    aStack.push(a);\n    bStack.push(b);\n\n    const iterableEqualityWithStack = (a: any, b: any) =>\n        iterableEquality(a, b, [...aStack], [...bStack]);\n\n    if (a.size !== undefined) {\n        if (a.size !== b.size) {\n            return false;\n        } else if (isA('Set', a) || isImmutableUnorderedSet(a)) {\n            let allFound = true;\n            for (const aValue of a) {\n                if (!b.has(aValue)) {\n                    let has = false;\n                    for (const bValue of b) {\n                        const isEqual = equals(aValue, bValue, [\n                            iterableEqualityWithStack,\n                        ]);\n                        if (isEqual === true) {\n                            has = true;\n                        }\n                    }\n\n                    if (has === false) {\n                        allFound = false;\n                        break;\n                    }\n                }\n            }\n            // Remove the first value from the stack of traversed values.\n            aStack.pop();\n            bStack.pop();\n            return allFound;\n        } else if (isA('Map', a) || isImmutableUnorderedKeyed(a)) {\n            let allFound = true;\n            for (const aEntry of a) {\n                if (\n                    !b.has(aEntry[0]) ||\n                    !equals(aEntry[1], b.get(aEntry[0]), [\n                        iterableEqualityWithStack,\n                    ])\n                ) {\n                    let has = false;\n                    for (const bEntry of b) {\n                        const matchedKey = equals(aEntry[0], bEntry[0], [\n                            iterableEqualityWithStack,\n                        ]);\n\n                        let matchedValue = false;\n                        if (matchedKey === true) {\n                            matchedValue = equals(aEntry[1], bEntry[1], [\n                                iterableEqualityWithStack,\n                            ]);\n                        }\n                        if (matchedValue === true) {\n                            has = true;\n                        }\n                    }\n\n                    if (has === false) {\n                        allFound = false;\n                        break;\n                    }\n                }\n            }\n            // Remove the first value from the stack of traversed values.\n            aStack.pop();\n            bStack.pop();\n            return allFound;\n        }\n    }\n\n    const bIterator = b[IteratorSymbol]();\n\n    for (const aValue of a) {\n        const nextB = bIterator.next();\n        if (\n            nextB.done ||\n            !equals(aValue, nextB.value, [iterableEqualityWithStack])\n        ) {\n            return false;\n        }\n    }\n    if (!bIterator.next().done) {\n        return false;\n    }\n\n    // Remove the first value from the stack of traversed values.\n    aStack.pop();\n    bStack.pop();\n    return true;\n};\n\nconst isObject = (a: any) => a !== null && typeof a === 'object';\n\nconst isObjectWithKeys = (a: any) =>\n    isObject(a) &&\n    !(a instanceof Error) &&\n    !(a instanceof Array) &&\n    !(a instanceof Date);\n\nexport const subsetEquality = (\n    object: unknown,\n    subset: unknown\n): boolean | undefined => {\n    // subsetEquality needs to keep track of the references\n    // it has already visited to avoid infinite loops in case\n    // there are circular references in the subset passed to it.\n    const subsetEqualityWithContext =\n        (seenReferences: WeakMap<object, boolean> = new WeakMap()) =>\n        (object: any, subset: any): boolean | undefined => {\n            if (!isObjectWithKeys(subset)) {\n                return undefined;\n            }\n\n            return Object.keys(subset).every((key) => {\n                if (isObjectWithKeys(subset[key])) {\n                    if (seenReferences.has(subset[key])) {\n                        return equals(object[key], subset[key], [\n                            iterableEquality,\n                        ]);\n                    }\n                    seenReferences.set(subset[key], true);\n                }\n                const result =\n                    object != null &&\n                    hasPropertyInObject(object, key) &&\n                    equals(object[key], subset[key], [\n                        iterableEquality,\n                        subsetEqualityWithContext(seenReferences),\n                    ]);\n                // The main goal of using seenReference is to avoid circular node on tree.\n                // It will only happen within a parent and its child, not a node and nodes next to it (same level)\n                // We should keep the reference for a parent and its child only\n                // Thus we should delete the reference immediately so that it doesn't interfere\n                // other nodes within the same level on tree.\n                seenReferences.delete(subset[key]);\n                return result;\n            });\n        };\n\n    return subsetEqualityWithContext()(object, subset);\n};\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport const typeEquality = (a: any, b: any): boolean | undefined => {\n    if (a == null || b == null || a.constructor === b.constructor) {\n        return undefined;\n    }\n\n    return false;\n};\n\nexport const arrayBufferEquality = (\n    a: unknown,\n    b: unknown\n): boolean | undefined => {\n    if (!(a instanceof ArrayBuffer) || !(b instanceof ArrayBuffer)) {\n        return undefined;\n    }\n\n    const dataViewA = new DataView(a);\n    const dataViewB = new DataView(b);\n\n    // Buffers are not equal when they do not have the same byte length\n    if (dataViewA.byteLength !== dataViewB.byteLength) {\n        return false;\n    }\n\n    // Check if every byte value is equal to each other\n    for (let i = 0; i < dataViewA.byteLength; i++) {\n        if (dataViewA.getUint8(i) !== dataViewB.getUint8(i)) {\n            return false;\n        }\n    }\n\n    return true;\n};\n\nexport const sparseArrayEquality = (\n    a: unknown,\n    b: unknown\n): boolean | undefined => {\n    if (!Array.isArray(a) || !Array.isArray(b)) {\n        return undefined;\n    }\n\n    // A sparse array [, , 1] will have keys [\"2\"] whereas [undefined, undefined, 1] will have keys [\"0\", \"1\", \"2\"]\n    const aKeys = Object.keys(a);\n    const bKeys = Object.keys(b);\n    return (\n        equals(a, b, [iterableEquality, typeEquality], true) &&\n        equals(aKeys, bKeys)\n    );\n};\n\nexport const partition = <T>(\n    items: Array<T>,\n    predicate: (arg: T) => boolean\n): [Array<T>, Array<T>] => {\n    const result: [Array<T>, Array<T>] = [[], []];\n\n    items.forEach((item) => result[predicate(item) ? 0 : 1].push(item));\n\n    return result;\n};\n\n// Copied from https://github.com/graingert/angular.js/blob/a43574052e9775cbc1d7dd8a086752c979b0f020/src/Angular.js#L685-L693\nexport const isError = (value: unknown): value is Error => {\n    switch (Object.prototype.toString.call(value)) {\n        case '[object Error]':\n        case '[object Exception]':\n        case '[object DOMException]':\n            return true;\n        default:\n            return value instanceof Error;\n    }\n};\n\nexport function emptyObject(obj: unknown): boolean {\n    return obj && typeof obj === 'object' ? !Object.keys(obj).length : false;\n}\n\nconst MULTILINE_REGEXP = /[\\r\\n]/;\n\nexport const isOneline = (expected: unknown, received: unknown): boolean =>\n    typeof expected === 'string' &&\n    typeof received === 'string' &&\n    (!MULTILINE_REGEXP.test(expected) || !MULTILINE_REGEXP.test(received));\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as matcherUtils from './matcher-utils';\nimport {\n    equals,\n    fnNameFor,\n    hasProperty,\n    isA,\n    isUndefined,\n} from './jasmineUtils';\nimport { getState } from './jestMatchersObject';\nimport type {\n    AsymmetricMatcher as AsymmetricMatcherInterface,\n    MatcherState,\n} from './types';\nimport { iterableEquality, subsetEquality } from './utils';\n\nconst utils = Object.freeze({\n    ...matcherUtils,\n    iterableEquality,\n    subsetEquality,\n});\n\nexport abstract class AsymmetricMatcher<\n    T,\n    State extends MatcherState = MatcherState\n> implements AsymmetricMatcherInterface\n{\n    $$typeof = Symbol.for('jest.asymmetricMatcher');\n\n    constructor(protected sample: T, protected inverse = false) {}\n\n    protected getMatcherContext(): State {\n        return {\n            ...getState(),\n            equals,\n            isNot: this.inverse,\n            utils,\n        } as State;\n    }\n\n    abstract asymmetricMatch(other: unknown): boolean;\n    abstract toString(): string;\n    getExpectedType?(): string;\n    toAsymmetricMatcher?(): string;\n}\n\nclass Any extends AsymmetricMatcher<any> {\n    constructor(sample: unknown) {\n        if (typeof sample === 'undefined') {\n            throw new TypeError(\n                'any() expects to be passed a constructor function. ' +\n                    'Please pass one or use anything() to match any object.'\n            );\n        }\n        super(sample);\n    }\n\n    asymmetricMatch(other: unknown) {\n        if (this.sample == String) {\n            return typeof other == 'string' || other instanceof String;\n        }\n\n        if (this.sample == Number) {\n            return typeof other == 'number' || other instanceof Number;\n        }\n\n        if (this.sample == Function) {\n            return typeof other == 'function' || other instanceof Function;\n        }\n\n        if (this.sample == Boolean) {\n            return typeof other == 'boolean' || other instanceof Boolean;\n        }\n\n        if (this.sample == BigInt) {\n            return typeof other == 'bigint' || other instanceof BigInt;\n        }\n\n        if (this.sample == Symbol) {\n            return typeof other == 'symbol' || other instanceof Symbol;\n        }\n\n        if (this.sample == Object) {\n            return typeof other == 'object';\n        }\n\n        return other instanceof this.sample;\n    }\n\n    toString() {\n        return 'Any';\n    }\n\n    getExpectedType() {\n        if (this.sample == String) {\n            return 'string';\n        }\n\n        if (this.sample == Number) {\n            return 'number';\n        }\n\n        if (this.sample == Function) {\n            return 'function';\n        }\n\n        if (this.sample == Object) {\n            return 'object';\n        }\n\n        if (this.sample == Boolean) {\n            return 'boolean';\n        }\n\n        return fnNameFor(this.sample);\n    }\n\n    toAsymmetricMatcher() {\n        return 'Any<' + fnNameFor(this.sample) + '>';\n    }\n}\n\nclass Anything extends AsymmetricMatcher<void> {\n    asymmetricMatch(other: unknown) {\n        return !isUndefined(other) && other !== null;\n    }\n\n    toString() {\n        return 'Anything';\n    }\n\n    // No getExpectedType method, because it matches either null or undefined.\n\n    toAsymmetricMatcher() {\n        return 'Anything';\n    }\n}\n\nclass ArrayContaining extends AsymmetricMatcher<Array<unknown>> {\n    constructor(sample: Array<unknown>, inverse: boolean = false) {\n        super(sample, inverse);\n    }\n\n    asymmetricMatch(other: Array<unknown>) {\n        if (!Array.isArray(this.sample)) {\n            throw new Error(\n                `You must provide an array to ${this.toString()}, not '` +\n                    typeof this.sample +\n                    \"'.\"\n            );\n        }\n\n        const result =\n            this.sample.length === 0 ||\n            (Array.isArray(other) &&\n                this.sample.every((item) =>\n                    other.some((another) => equals(item, another))\n                ));\n\n        return this.inverse ? !result : result;\n    }\n\n    toString() {\n        return `Array${this.inverse ? 'Not' : ''}Containing`;\n    }\n\n    getExpectedType() {\n        return 'array';\n    }\n}\n\nclass ObjectContaining extends AsymmetricMatcher<Record<string, unknown>> {\n    constructor(sample: Record<string, unknown>, inverse: boolean = false) {\n        super(sample, inverse);\n    }\n\n    asymmetricMatch(other?: any) {\n        if (typeof this.sample !== 'object') {\n            throw new Error(\n                `You must provide an object to ${this.toString()}, not '` +\n                    typeof this.sample +\n                    \"'.\"\n            );\n        }\n\n        let result = true;\n\n        for (const property in this.sample) {\n            if (\n                !hasProperty(other, property) ||\n                !equals(this.sample[property], other[property])\n            ) {\n                result = false;\n                break;\n            }\n        }\n\n        return this.inverse ? !result : result;\n    }\n\n    toString() {\n        return `Object${this.inverse ? 'Not' : ''}Containing`;\n    }\n\n    getExpectedType() {\n        return 'object';\n    }\n}\n\nclass StringContaining extends AsymmetricMatcher<string> {\n    constructor(sample: string, inverse: boolean = false) {\n        if (!isA('String', sample)) {\n            throw new Error('Expected is not a string');\n        }\n        super(sample, inverse);\n    }\n\n    asymmetricMatch(other: string) {\n        const result = isA('String', other) && other.includes(this.sample);\n\n        return this.inverse ? !result : result;\n    }\n\n    toString() {\n        return `String${this.inverse ? 'Not' : ''}Containing`;\n    }\n\n    getExpectedType() {\n        return 'string';\n    }\n}\n\nclass StringMatching extends AsymmetricMatcher<RegExp> {\n    constructor(sample: string | RegExp, inverse: boolean = false) {\n        if (!isA('String', sample) && !isA('RegExp', sample)) {\n            throw new Error('Expected is not a String or a RegExp');\n        }\n        super(new RegExp(sample), inverse);\n    }\n\n    asymmetricMatch(other: string) {\n        const result = isA('String', other) && this.sample.test(other);\n\n        return this.inverse ? !result : result;\n    }\n\n    toString() {\n        return `String${this.inverse ? 'Not' : ''}Matching`;\n    }\n\n    getExpectedType() {\n        return 'string';\n    }\n}\n\nexport const any = (expectedObject: unknown): Any => new Any(expectedObject);\nexport const anything = (): Anything => new Anything();\nexport const arrayContaining = (sample: Array<unknown>): ArrayContaining =>\n    new ArrayContaining(sample);\nexport const arrayNotContaining = (sample: Array<unknown>): ArrayContaining =>\n    new ArrayContaining(sample, true);\nexport const objectContaining = (\n    sample: Record<string, unknown>\n): ObjectContaining => new ObjectContaining(sample);\nexport const objectNotContaining = (\n    sample: Record<string, unknown>\n): ObjectContaining => new ObjectContaining(sample, true);\nexport const stringContaining = (expected: string): StringContaining =>\n    new StringContaining(expected);\nexport const stringNotContaining = (expected: string): StringContaining =>\n    new StringContaining(expected, true);\nexport const stringMatching = (expected: string | RegExp): StringMatching =>\n    new StringMatching(expected);\nexport const stringNotMatching = (expected: string | RegExp): StringMatching =>\n    new StringMatching(expected, true);\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {\n    EXPECTED_COLOR,\n    RECEIVED_COLOR,\n    matcherHint,\n    pluralize,\n} from './matcher-utils';\nimport { getState, setState } from './jestMatchersObject';\nimport type { Expect, ExpectedAssertionsErrors } from './types';\n\nconst resetAssertionsLocalState = () => {\n    setState({\n        assertionCalls: 0,\n        expectedAssertionsNumber: null,\n        isExpectingAssertions: false,\n    });\n};\n\n// Create and format all errors related to the mismatched number of `expect`\n// calls and reset the matcher's state.\nconst extractExpectedAssertionsErrors: Expect['extractExpectedAssertionsErrors'] =\n    () => {\n        const result: ExpectedAssertionsErrors = [];\n        const {\n            assertionCalls,\n            expectedAssertionsNumber,\n            expectedAssertionsNumberError,\n            isExpectingAssertions,\n            isExpectingAssertionsError,\n        } = getState();\n\n        resetAssertionsLocalState();\n\n        if (\n            typeof expectedAssertionsNumber === 'number' &&\n            assertionCalls !== expectedAssertionsNumber\n        ) {\n            const numOfAssertionsExpected = EXPECTED_COLOR(\n                pluralize('assertion', expectedAssertionsNumber)\n            );\n\n            expectedAssertionsNumberError!.message =\n                matcherHint(\n                    '.assertions',\n                    '',\n                    String(expectedAssertionsNumber),\n                    {\n                        isDirectExpectCall: true,\n                    }\n                ) +\n                '\\n\\n' +\n                `Expected ${numOfAssertionsExpected} to be called but received ` +\n                RECEIVED_COLOR(\n                    pluralize('assertion call', assertionCalls || 0)\n                ) +\n                '.';\n\n            result.push({\n                actual: assertionCalls.toString(),\n                error: expectedAssertionsNumberError!,\n                expected: expectedAssertionsNumber.toString(),\n            });\n        }\n        if (isExpectingAssertions && assertionCalls === 0) {\n            const expected = EXPECTED_COLOR('at least one assertion');\n            const received = RECEIVED_COLOR('received none');\n\n            isExpectingAssertionsError!.message =\n                matcherHint('.hasAssertions', '', '', {\n                    isDirectExpectCall: true,\n                }) +\n                '\\n\\n' +\n                `Expected ${expected} to be called but ${received}.`;\n\n            result.push({\n                actual: 'none',\n                error: isExpectingAssertionsError!,\n                expected: 'at least one',\n            });\n        }\n\n        return result;\n    };\n\nexport default extractExpectedAssertionsErrors;\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/* eslint-disable local/ban-types-eventually */\n\nimport {\n    EXPECTED_COLOR,\n    INVERTED_COLOR,\n    RECEIVED_COLOR,\n    printReceived,\n    stringify,\n} from './matcher-utils';\n\n// Format substring but do not enclose in double quote marks.\n// The replacement is compatible with pretty-format package.\nconst printSubstring = (val: string): string => val.replace(/\"|\\\\/g, '\\\\$&');\n\nexport const printReceivedStringContainExpectedSubstring = (\n    received: string,\n    start: number,\n    length: number // not end\n): string =>\n    RECEIVED_COLOR(\n        '\"' +\n            printSubstring(received.slice(0, start)) +\n            INVERTED_COLOR(\n                printSubstring(received.slice(start, start + length))\n            ) +\n            printSubstring(received.slice(start + length)) +\n            '\"'\n    );\n\nexport const printReceivedStringContainExpectedResult = (\n    received: string,\n    result: RegExpExecArray | null\n): string =>\n    result === null\n        ? printReceived(received)\n        : printReceivedStringContainExpectedSubstring(\n              received,\n              result.index,\n              result[0].length\n          );\n\n// The serialized array is compatible with pretty-format package min option.\n// However, items have default stringify depth (instead of depth - 1)\n// so expected item looks consistent by itself and enclosed in the array.\nexport const printReceivedArrayContainExpectedItem = (\n    received: Array<unknown>,\n    index: number\n): string =>\n    RECEIVED_COLOR(\n        '[' +\n            received\n                .map((item, i) => {\n                    const stringified = stringify(item);\n                    return i === index\n                        ? INVERTED_COLOR(stringified)\n                        : stringified;\n                })\n                .join(', ') +\n            ']'\n    );\n\nexport const printCloseTo = (\n    receivedDiff: number,\n    expectedDiff: number,\n    precision: number,\n    isNot: boolean\n): string => {\n    const receivedDiffString = stringify(receivedDiff);\n    const expectedDiffString = receivedDiffString.includes('e')\n        ? // toExponential arg is number of digits after the decimal point.\n          expectedDiff.toExponential(0)\n        : 0 <= precision && precision < 20\n        ? // toFixed arg is number of digits after the decimal point.\n          // It may be a value between 0 and 20 inclusive.\n          // Implementations may optionally support a larger range of values.\n          expectedDiff.toFixed(precision + 1)\n        : stringify(expectedDiff);\n\n    return (\n        `Expected precision:  ${isNot ? '    ' : ''}  ${stringify(\n            precision\n        )}\\n` +\n        `Expected difference: ${isNot ? 'not ' : ''}< ${EXPECTED_COLOR(\n            expectedDiffString\n        )}\\n` +\n        `Received difference: ${isNot ? '    ' : ''}  ${RECEIVED_COLOR(\n            receivedDiffString\n        )}`\n    );\n};\n\nexport const printExpectedConstructorName = (\n    label: string,\n    expected: Function\n): string => printConstructorName(label, expected, false, true) + '\\n';\n\nexport const printExpectedConstructorNameNot = (\n    label: string,\n    expected: Function\n): string => printConstructorName(label, expected, true, true) + '\\n';\n\nexport const printReceivedConstructorName = (\n    label: string,\n    received: Function\n): string => printConstructorName(label, received, false, false) + '\\n';\n\n// Do not call function if received is equal to expected.\nexport const printReceivedConstructorNameNot = (\n    label: string,\n    received: Function,\n    expected: Function\n): string =>\n    typeof expected.name === 'string' &&\n    expected.name.length !== 0 &&\n    typeof received.name === 'string' &&\n    received.name.length !== 0\n        ? printConstructorName(label, received, true, false) +\n          ` ${\n              Object.getPrototypeOf(received) === expected\n                  ? 'extends'\n                  : 'extends  extends'\n          } ${EXPECTED_COLOR(expected.name)}` +\n          '\\n'\n        : printConstructorName(label, received, false, false) + '\\n';\n\nconst printConstructorName = (\n    label: string,\n    constructor: Function,\n    isNot: boolean,\n    isExpected: boolean\n): string =>\n    typeof constructor.name !== 'string'\n        ? `${label} name is not a string`\n        : constructor.name.length === 0\n        ? `${label} name is an empty string`\n        : `${label}: ${!isNot ? '' : isExpected ? 'not ' : '    '}${\n              isExpected\n                  ? EXPECTED_COLOR(constructor.name)\n                  : RECEIVED_COLOR(constructor.name)\n          }`;\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/* eslint-disable local/ban-types-eventually */\n\nimport { getType, isPrimitive } from './get-type';\nimport {\n    DIM_COLOR,\n    EXPECTED_COLOR,\n    MatcherHintOptions,\n    RECEIVED_COLOR,\n    SUGGEST_TO_CONTAIN_EQUAL,\n    ensureExpectedIsNonNegativeInteger,\n    ensureNoExpected,\n    ensureNumbers,\n    getLabelPrinter,\n    matcherErrorMessage,\n    matcherHint,\n    printDiffOrStringify,\n    printExpected,\n    printReceived,\n    printWithType,\n    stringify,\n} from './matcher-utils';\nimport { equals } from './jasmineUtils';\nimport {\n    printCloseTo,\n    printExpectedConstructorName,\n    printExpectedConstructorNameNot,\n    printReceivedArrayContainExpectedItem,\n    printReceivedConstructorName,\n    printReceivedConstructorNameNot,\n    printReceivedStringContainExpectedResult,\n    printReceivedStringContainExpectedSubstring,\n} from './print';\nimport type { MatchersObject } from './types';\nimport {\n    arrayBufferEquality,\n    getObjectSubset,\n    getPath,\n    iterableEquality,\n    sparseArrayEquality,\n    subsetEquality,\n    typeEquality,\n} from './utils';\n\n// Omit colon and one or more spaces, so can call getLabelPrinter.\nconst EXPECTED_LABEL = 'Expected';\nconst RECEIVED_LABEL = 'Received';\nconst EXPECTED_VALUE_LABEL = 'Expected value';\nconst RECEIVED_VALUE_LABEL = 'Received value';\n\n// The optional property of matcher context is true if undefined.\nconst isExpand = (expand?: boolean): boolean => expand !== false;\n\nconst toStrictEqualTesters = [\n    iterableEquality,\n    typeEquality,\n    sparseArrayEquality,\n    arrayBufferEquality,\n];\n\ntype ContainIterable =\n    | Array<unknown>\n    | Set<unknown>\n    | NodeListOf<Node>\n    | DOMTokenList\n    | HTMLCollectionOf<any>;\n\nconst matchers: MatchersObject = {\n    toBe(received: unknown, expected: unknown) {\n        const matcherName = 'toBe';\n        const options: MatcherHintOptions = {\n            comment: 'Object.is equality',\n            isNot: this.isNot,\n            promise: this.promise,\n        };\n\n        const pass = Object.is(received, expected);\n\n        const message = pass\n            ? () =>\n                  matcherHint(matcherName, undefined, undefined, options) +\n                  '\\n\\n' +\n                  `Expected: not ${printExpected(expected)}`\n            : () => {\n                  const expectedType = getType(expected);\n\n                  let deepEqualityName = null;\n                  if (expectedType !== 'map' && expectedType !== 'set') {\n                      // If deep equality passes when referential identity fails,\n                      // but exclude map and set until review of their equality logic.\n                      if (\n                          equals(received, expected, toStrictEqualTesters, true)\n                      ) {\n                          deepEqualityName = 'toStrictEqual';\n                      } else if (\n                          equals(received, expected, [iterableEquality])\n                      ) {\n                          deepEqualityName = 'toEqual';\n                      }\n                  }\n\n                  return (\n                      matcherHint(matcherName, undefined, undefined, options) +\n                      '\\n\\n' +\n                      (deepEqualityName !== null\n                          ? DIM_COLOR(\n                                `If it should pass with deep equality, replace \"${matcherName}\" with \"${deepEqualityName}\"`\n                            ) + '\\n\\n'\n                          : '') +\n                      printDiffOrStringify(\n                          expected,\n                          received,\n                          EXPECTED_LABEL,\n                          RECEIVED_LABEL,\n                          isExpand(this.expand)\n                      )\n                  );\n              };\n\n        // Passing the actual and expected objects so that a custom reporter\n        // could access them, for example in order to display a custom visual diff,\n        // or create a different error message\n        return { actual: received, expected, message, name: matcherName, pass };\n    },\n\n    toBeCloseTo(received: number, expected: number, precision: number = 2) {\n        const matcherName = 'toBeCloseTo';\n        const secondArgument = arguments.length === 3 ? 'precision' : undefined;\n        const isNot = this.isNot;\n        const options: MatcherHintOptions = {\n            isNot,\n            promise: this.promise,\n            secondArgument,\n            secondArgumentColor: (arg: string) => arg,\n        };\n\n        if (typeof expected !== 'number') {\n            throw new Error(\n                matcherErrorMessage(\n                    matcherHint(matcherName, undefined, undefined, options),\n                    `${EXPECTED_COLOR('expected')} value must be a number`,\n                    printWithType('Expected', expected, printExpected)\n                )\n            );\n        }\n\n        if (typeof received !== 'number') {\n            throw new Error(\n                matcherErrorMessage(\n                    matcherHint(matcherName, undefined, undefined, options),\n                    `${RECEIVED_COLOR('received')} value must be a number`,\n                    printWithType('Received', received, printReceived)\n                )\n            );\n        }\n\n        let pass = false;\n        let expectedDiff = 0;\n        let receivedDiff = 0;\n\n        if (received === Infinity && expected === Infinity) {\n            pass = true; // Infinity - Infinity is NaN\n        } else if (received === -Infinity && expected === -Infinity) {\n            pass = true; // -Infinity - -Infinity is NaN\n        } else {\n            expectedDiff = Math.pow(10, -precision) / 2;\n            receivedDiff = Math.abs(expected - received);\n            pass = receivedDiff < expectedDiff;\n        }\n\n        const message = pass\n            ? () =>\n                  matcherHint(matcherName, undefined, undefined, options) +\n                  '\\n\\n' +\n                  `Expected: not ${printExpected(expected)}\\n` +\n                  (receivedDiff === 0\n                      ? ''\n                      : `Received:     ${printReceived(received)}\\n` +\n                        '\\n' +\n                        printCloseTo(\n                            receivedDiff,\n                            expectedDiff,\n                            precision,\n                            isNot\n                        ))\n            : () =>\n                  matcherHint(matcherName, undefined, undefined, options) +\n                  '\\n\\n' +\n                  `Expected: ${printExpected(expected)}\\n` +\n                  `Received: ${printReceived(received)}\\n` +\n                  '\\n' +\n                  printCloseTo(receivedDiff, expectedDiff, precision, isNot);\n\n        return { message, pass };\n    },\n\n    toBeDefined(received: unknown, expected: void) {\n        const matcherName = 'toBeDefined';\n        const options: MatcherHintOptions = {\n            isNot: this.isNot,\n            promise: this.promise,\n        };\n        ensureNoExpected(expected, matcherName, options);\n\n        const pass = received !== void 0;\n\n        const message = () =>\n            matcherHint(matcherName, undefined, '', options) +\n            '\\n\\n' +\n            `Received: ${printReceived(received)}`;\n\n        return { message, pass };\n    },\n\n    toBeFalsy(received: unknown, expected: void) {\n        const matcherName = 'toBeFalsy';\n        const options: MatcherHintOptions = {\n            isNot: this.isNot,\n            promise: this.promise,\n        };\n        ensureNoExpected(expected, matcherName, options);\n\n        const pass = !received;\n\n        const message = () =>\n            matcherHint(matcherName, undefined, '', options) +\n            '\\n\\n' +\n            `Received: ${printReceived(received)}`;\n\n        return { message, pass };\n    },\n\n    toBeGreaterThan(received: number | bigint, expected: number | bigint) {\n        const matcherName = 'toBeGreaterThan';\n        const isNot = this.isNot;\n        const options: MatcherHintOptions = {\n            isNot,\n            promise: this.promise,\n        };\n        ensureNumbers(received, expected, matcherName, options);\n\n        const pass = received > expected;\n\n        const message = () =>\n            matcherHint(matcherName, undefined, undefined, options) +\n            '\\n\\n' +\n            `Expected:${isNot ? ' not' : ''} > ${printExpected(expected)}\\n` +\n            `Received:${isNot ? '    ' : ''}   ${printReceived(received)}`;\n\n        return { message, pass };\n    },\n\n    toBeGreaterThanOrEqual(\n        received: number | bigint,\n        expected: number | bigint\n    ) {\n        const matcherName = 'toBeGreaterThanOrEqual';\n        const isNot = this.isNot;\n        const options: MatcherHintOptions = {\n            isNot,\n            promise: this.promise,\n        };\n        ensureNumbers(received, expected, matcherName, options);\n\n        const pass = received >= expected;\n\n        const message = () =>\n            matcherHint(matcherName, undefined, undefined, options) +\n            '\\n\\n' +\n            `Expected:${isNot ? ' not' : ''} >= ${printExpected(expected)}\\n` +\n            `Received:${isNot ? '    ' : ''}    ${printReceived(received)}`;\n\n        return { message, pass };\n    },\n\n    toBeInstanceOf(received: any, expected: Function) {\n        const matcherName = 'toBeInstanceOf';\n        const options: MatcherHintOptions = {\n            isNot: this.isNot,\n            promise: this.promise,\n        };\n\n        if (typeof expected !== 'function') {\n            throw new Error(\n                matcherErrorMessage(\n                    matcherHint(matcherName, undefined, undefined, options),\n                    `${EXPECTED_COLOR('expected')} value must be a function`,\n                    printWithType('Expected', expected, printExpected)\n                )\n            );\n        }\n\n        const pass = received instanceof expected;\n\n        const message = pass\n            ? () =>\n                  matcherHint(matcherName, undefined, undefined, options) +\n                  '\\n\\n' +\n                  printExpectedConstructorNameNot(\n                      'Expected constructor',\n                      expected\n                  ) +\n                  (typeof received.constructor === 'function' &&\n                  received.constructor !== expected\n                      ? printReceivedConstructorNameNot(\n                            'Received constructor',\n                            received.constructor,\n                            expected\n                        )\n                      : '')\n            : () =>\n                  matcherHint(matcherName, undefined, undefined, options) +\n                  '\\n\\n' +\n                  printExpectedConstructorName(\n                      'Expected constructor',\n                      expected\n                  ) +\n                  (isPrimitive(received) ||\n                  Object.getPrototypeOf(received) === null\n                      ? `\\nReceived value has no prototype\\nReceived value: ${printReceived(\n                            received\n                        )}`\n                      : typeof received.constructor !== 'function'\n                      ? `\\nReceived value: ${printReceived(received)}`\n                      : printReceivedConstructorName(\n                            'Received constructor',\n                            received.constructor\n                        ));\n\n        return { message, pass };\n    },\n\n    toBeLessThan(received: number | bigint, expected: number | bigint) {\n        const matcherName = 'toBeLessThan';\n        const isNot = this.isNot;\n        const options: MatcherHintOptions = {\n            isNot,\n            promise: this.promise,\n        };\n        ensureNumbers(received, expected, matcherName, options);\n\n        const pass = received < expected;\n\n        const message = () =>\n            matcherHint(matcherName, undefined, undefined, options) +\n            '\\n\\n' +\n            `Expected:${isNot ? ' not' : ''} < ${printExpected(expected)}\\n` +\n            `Received:${isNot ? '    ' : ''}   ${printReceived(received)}`;\n\n        return { message, pass };\n    },\n\n    toBeLessThanOrEqual(received: number | bigint, expected: number | bigint) {\n        const matcherName = 'toBeLessThanOrEqual';\n        const isNot = this.isNot;\n        const options: MatcherHintOptions = {\n            isNot,\n            promise: this.promise,\n        };\n        ensureNumbers(received, expected, matcherName, options);\n\n        const pass = received <= expected;\n\n        const message = () =>\n            matcherHint(matcherName, undefined, undefined, options) +\n            '\\n\\n' +\n            `Expected:${isNot ? ' not' : ''} <= ${printExpected(expected)}\\n` +\n            `Received:${isNot ? '    ' : ''}    ${printReceived(received)}`;\n\n        return { message, pass };\n    },\n\n    toBeNaN(received: any, expected: void) {\n        const matcherName = 'toBeNaN';\n        const options: MatcherHintOptions = {\n            isNot: this.isNot,\n            promise: this.promise,\n        };\n        ensureNoExpected(expected, matcherName, options);\n\n        const pass = Number.isNaN(received);\n\n        const message = () =>\n            matcherHint(matcherName, undefined, '', options) +\n            '\\n\\n' +\n            `Received: ${printReceived(received)}`;\n\n        return { message, pass };\n    },\n\n    toBeNull(received: unknown, expected: void) {\n        const matcherName = 'toBeNull';\n        const options: MatcherHintOptions = {\n            isNot: this.isNot,\n            promise: this.promise,\n        };\n        ensureNoExpected(expected, matcherName, options);\n\n        const pass = received === null;\n\n        const message = () =>\n            matcherHint(matcherName, undefined, '', options) +\n            '\\n\\n' +\n            `Received: ${printReceived(received)}`;\n\n        return { message, pass };\n    },\n\n    toBeTruthy(received: unknown, expected: void) {\n        const matcherName = 'toBeTruthy';\n        const options: MatcherHintOptions = {\n            isNot: this.isNot,\n            promise: this.promise,\n        };\n        ensureNoExpected(expected, matcherName, options);\n\n        const pass = !!received;\n\n        const message = () =>\n            matcherHint(matcherName, undefined, '', options) +\n            '\\n\\n' +\n            `Received: ${printReceived(received)}`;\n\n        return { message, pass };\n    },\n\n    toBeUndefined(received: unknown, expected: void) {\n        const matcherName = 'toBeUndefined';\n        const options: MatcherHintOptions = {\n            isNot: this.isNot,\n            promise: this.promise,\n        };\n        ensureNoExpected(expected, matcherName, options);\n\n        const pass = received === void 0;\n\n        const message = () =>\n            matcherHint(matcherName, undefined, '', options) +\n            '\\n\\n' +\n            `Received: ${printReceived(received)}`;\n\n        return { message, pass };\n    },\n\n    toContain(received: ContainIterable | string, expected: unknown) {\n        const matcherName = 'toContain';\n        const isNot = this.isNot;\n        const options: MatcherHintOptions = {\n            comment: 'indexOf',\n            isNot,\n            promise: this.promise,\n        };\n\n        if (received == null) {\n            throw new Error(\n                matcherErrorMessage(\n                    matcherHint(matcherName, undefined, undefined, options),\n                    `${RECEIVED_COLOR(\n                        'received'\n                    )} value must not be null nor undefined`,\n                    printWithType('Received', received, printReceived)\n                )\n            );\n        }\n\n        if (typeof received === 'string') {\n            const wrongTypeErrorMessage = `${EXPECTED_COLOR(\n                'expected'\n            )} value must be a string if ${RECEIVED_COLOR(\n                'received'\n            )} value is a string`;\n\n            if (typeof expected !== 'string') {\n                throw new Error(\n                    matcherErrorMessage(\n                        matcherHint(\n                            matcherName,\n                            received,\n                            String(expected),\n                            options\n                        ),\n                        wrongTypeErrorMessage,\n                        printWithType('Expected', expected, printExpected) +\n                            '\\n' +\n                            printWithType('Received', received, printReceived)\n                    )\n                );\n            }\n\n            const index = received.indexOf(String(expected));\n            const pass = index !== -1;\n\n            const message = () => {\n                const labelExpected = `Expected ${\n                    typeof expected === 'string' ? 'substring' : 'value'\n                }`;\n                const labelReceived = 'Received string';\n                const printLabel = getLabelPrinter(\n                    labelExpected,\n                    labelReceived\n                );\n\n                return (\n                    matcherHint(matcherName, undefined, undefined, options) +\n                    '\\n\\n' +\n                    `${printLabel(labelExpected)}${\n                        isNot ? 'not ' : ''\n                    }${printExpected(expected)}\\n` +\n                    `${printLabel(labelReceived)}${isNot ? '    ' : ''}${\n                        isNot\n                            ? printReceivedStringContainExpectedSubstring(\n                                  received,\n                                  index,\n                                  String(expected).length\n                              )\n                            : printReceived(received)\n                    }`\n                );\n            };\n\n            return { message, pass };\n        }\n\n        const indexable = Array.from(received);\n        const index = indexable.indexOf(expected);\n        const pass = index !== -1;\n\n        const message = () => {\n            const labelExpected = 'Expected value';\n            const labelReceived = `Received ${getType(received)}`;\n            const printLabel = getLabelPrinter(labelExpected, labelReceived);\n\n            return (\n                matcherHint(matcherName, undefined, undefined, options) +\n                '\\n\\n' +\n                `${printLabel(labelExpected)}${\n                    isNot ? 'not ' : ''\n                }${printExpected(expected)}\\n` +\n                `${printLabel(labelReceived)}${isNot ? '    ' : ''}${\n                    isNot && Array.isArray(received)\n                        ? printReceivedArrayContainExpectedItem(received, index)\n                        : printReceived(received)\n                }` +\n                (!isNot &&\n                indexable.findIndex((item) =>\n                    equals(item, expected, [iterableEquality])\n                ) !== -1\n                    ? `\\n\\n${SUGGEST_TO_CONTAIN_EQUAL}`\n                    : '')\n            );\n        };\n\n        return { message, pass };\n    },\n\n    toContainEqual(received: ContainIterable, expected: unknown) {\n        const matcherName = 'toContainEqual';\n        const isNot = this.isNot;\n        const options: MatcherHintOptions = {\n            comment: 'deep equality',\n            isNot,\n            promise: this.promise,\n        };\n\n        if (received == null) {\n            throw new Error(\n                matcherErrorMessage(\n                    matcherHint(matcherName, undefined, undefined, options),\n                    `${RECEIVED_COLOR(\n                        'received'\n                    )} value must not be null nor undefined`,\n                    printWithType('Received', received, printReceived)\n                )\n            );\n        }\n\n        const index = Array.from(received).findIndex((item) =>\n            equals(item, expected, [iterableEquality])\n        );\n        const pass = index !== -1;\n\n        const message = () => {\n            const labelExpected = 'Expected value';\n            const labelReceived = `Received ${getType(received)}`;\n            const printLabel = getLabelPrinter(labelExpected, labelReceived);\n\n            return (\n                matcherHint(matcherName, undefined, undefined, options) +\n                '\\n\\n' +\n                `${printLabel(labelExpected)}${\n                    isNot ? 'not ' : ''\n                }${printExpected(expected)}\\n` +\n                `${printLabel(labelReceived)}${isNot ? '    ' : ''}${\n                    isNot && Array.isArray(received)\n                        ? printReceivedArrayContainExpectedItem(received, index)\n                        : printReceived(received)\n                }`\n            );\n        };\n\n        return { message, pass };\n    },\n\n    toEqual(received: unknown, expected: unknown) {\n        const matcherName = 'toEqual';\n        const options: MatcherHintOptions = {\n            comment: 'deep equality',\n            isNot: this.isNot,\n            promise: this.promise,\n        };\n\n        const pass = equals(received, expected, [iterableEquality]);\n\n        const message = pass\n            ? () =>\n                  matcherHint(matcherName, undefined, undefined, options) +\n                  '\\n\\n' +\n                  `Expected: not ${printExpected(expected)}\\n` +\n                  (stringify(expected) !== stringify(received)\n                      ? `Received:     ${printReceived(received)}`\n                      : '')\n            : () =>\n                  matcherHint(matcherName, undefined, undefined, options) +\n                  '\\n\\n' +\n                  printDiffOrStringify(\n                      expected,\n                      received,\n                      EXPECTED_LABEL,\n                      RECEIVED_LABEL,\n                      isExpand(this.expand)\n                  );\n\n        // Passing the actual and expected objects so that a custom reporter\n        // could access them, for example in order to display a custom visual diff,\n        // or create a different error message\n        return { actual: received, expected, message, name: matcherName, pass };\n    },\n\n    toHaveLength(received: any, expected: number) {\n        const matcherName = 'toHaveLength';\n        const isNot = this.isNot;\n        const options: MatcherHintOptions = {\n            isNot,\n            promise: this.promise,\n        };\n\n        if (typeof received?.length !== 'number') {\n            throw new Error(\n                matcherErrorMessage(\n                    matcherHint(matcherName, undefined, undefined, options),\n                    `${RECEIVED_COLOR(\n                        'received'\n                    )} value must have a length property whose value must be a number`,\n                    printWithType('Received', received, printReceived)\n                )\n            );\n        }\n\n        ensureExpectedIsNonNegativeInteger(expected, matcherName, options);\n\n        const pass = received.length === expected;\n\n        const message = () => {\n            const labelExpected = 'Expected length';\n            const labelReceivedLength = 'Received length';\n            const labelReceivedValue = `Received ${getType(received)}`;\n            const printLabel = getLabelPrinter(\n                labelExpected,\n                labelReceivedLength,\n                labelReceivedValue\n            );\n\n            return (\n                matcherHint(matcherName, undefined, undefined, options) +\n                '\\n\\n' +\n                `${printLabel(labelExpected)}${\n                    isNot ? 'not ' : ''\n                }${printExpected(expected)}\\n` +\n                (isNot\n                    ? ''\n                    : `${printLabel(labelReceivedLength)}${printReceived(\n                          received.length\n                      )}\\n`) +\n                `${printLabel(labelReceivedValue)}${\n                    isNot ? '    ' : ''\n                }${printReceived(received)}`\n            );\n        };\n\n        return { message, pass };\n    },\n\n    toHaveProperty(\n        received: object,\n        expectedPath: string | Array<string>,\n        expectedValue?: unknown\n    ) {\n        const matcherName = 'toHaveProperty';\n        const expectedArgument = 'path';\n        const hasValue = arguments.length === 3;\n        const options: MatcherHintOptions = {\n            isNot: this.isNot,\n            promise: this.promise,\n            secondArgument: hasValue ? 'value' : '',\n        };\n\n        if (received === null || received === undefined) {\n            throw new Error(\n                matcherErrorMessage(\n                    matcherHint(\n                        matcherName,\n                        undefined,\n                        expectedArgument,\n                        options\n                    ),\n                    `${RECEIVED_COLOR(\n                        'received'\n                    )} value must not be null nor undefined`,\n                    printWithType('Received', received, printReceived)\n                )\n            );\n        }\n\n        const expectedPathType = getType(expectedPath);\n\n        if (expectedPathType !== 'string' && expectedPathType !== 'array') {\n            throw new Error(\n                matcherErrorMessage(\n                    matcherHint(\n                        matcherName,\n                        undefined,\n                        expectedArgument,\n                        options\n                    ),\n                    `${EXPECTED_COLOR(\n                        'expected'\n                    )} path must be a string or array`,\n                    printWithType('Expected', expectedPath, printExpected)\n                )\n            );\n        }\n\n        const expectedPathLength =\n            typeof expectedPath === 'string'\n                ? expectedPath.split('.').length\n                : expectedPath.length;\n\n        if (expectedPathType === 'array' && expectedPathLength === 0) {\n            throw new Error(\n                matcherErrorMessage(\n                    matcherHint(\n                        matcherName,\n                        undefined,\n                        expectedArgument,\n                        options\n                    ),\n                    `${EXPECTED_COLOR(\n                        'expected'\n                    )} path must not be an empty array`,\n                    printWithType('Expected', expectedPath, printExpected)\n                )\n            );\n        }\n\n        const result = getPath(received, expectedPath);\n        const { lastTraversedObject, hasEndProp } = result;\n        const receivedPath = result.traversedPath;\n        const hasCompletePath = receivedPath.length === expectedPathLength;\n        const receivedValue = hasCompletePath\n            ? result.value\n            : lastTraversedObject;\n\n        const pass = hasValue\n            ? equals(result.value, expectedValue, [iterableEquality])\n            : Boolean(hasEndProp); // theoretically undefined if empty path\n        // Remove type cast if we rewrite getPath as iterative algorithm.\n\n        // Delete this unique report if future breaking change\n        // removes the edge case that expected value undefined\n        // also matches absence of a property with the key path.\n        if (pass && !hasCompletePath) {\n            const message = () =>\n                matcherHint(matcherName, undefined, expectedArgument, options) +\n                '\\n\\n' +\n                `Expected path: ${printExpected(expectedPath)}\\n` +\n                `Received path: ${printReceived(\n                    expectedPathType === 'array' || receivedPath.length === 0\n                        ? receivedPath\n                        : receivedPath.join('.')\n                )}\\n\\n` +\n                `Expected value: not ${printExpected(expectedValue)}\\n` +\n                `Received value:     ${printReceived(receivedValue)}\\n\\n` +\n                DIM_COLOR(\n                    'Because a positive assertion passes for expected value undefined if the property does not exist, this negative assertion fails unless the property does exist and has a defined value'\n                );\n\n            return { message, pass };\n        }\n\n        const message = pass\n            ? () =>\n                  matcherHint(\n                      matcherName,\n                      undefined,\n                      expectedArgument,\n                      options\n                  ) +\n                  '\\n\\n' +\n                  (hasValue\n                      ? `Expected path: ${printExpected(expectedPath)}\\n\\n` +\n                        `Expected value: not ${printExpected(expectedValue)}` +\n                        (stringify(expectedValue) !== stringify(receivedValue)\n                            ? `\\nReceived value:     ${printReceived(\n                                  receivedValue\n                              )}`\n                            : '')\n                      : `Expected path: not ${printExpected(\n                            expectedPath\n                        )}\\n\\n` +\n                        `Received value: ${printReceived(receivedValue)}`)\n            : () =>\n                  matcherHint(\n                      matcherName,\n                      undefined,\n                      expectedArgument,\n                      options\n                  ) +\n                  '\\n\\n' +\n                  `Expected path: ${printExpected(expectedPath)}\\n` +\n                  (hasCompletePath\n                      ? '\\n' +\n                        printDiffOrStringify(\n                            expectedValue,\n                            receivedValue,\n                            EXPECTED_VALUE_LABEL,\n                            RECEIVED_VALUE_LABEL,\n                            isExpand(this.expand)\n                        )\n                      : `Received path: ${printReceived(\n                            expectedPathType === 'array' ||\n                                receivedPath.length === 0\n                                ? receivedPath\n                                : receivedPath.join('.')\n                        )}\\n\\n` +\n                        (hasValue\n                            ? `Expected value: ${printExpected(\n                                  expectedValue\n                              )}\\n`\n                            : '') +\n                        `Received value: ${printReceived(receivedValue)}`);\n\n        return { message, pass };\n    },\n\n    toMatch(received: string, expected: string | RegExp) {\n        const matcherName = 'toMatch';\n        const options: MatcherHintOptions = {\n            isNot: this.isNot,\n            promise: this.promise,\n        };\n\n        if (typeof received !== 'string') {\n            throw new Error(\n                matcherErrorMessage(\n                    matcherHint(matcherName, undefined, undefined, options),\n                    `${RECEIVED_COLOR('received')} value must be a string`,\n                    printWithType('Received', received, printReceived)\n                )\n            );\n        }\n\n        if (\n            !(typeof expected === 'string') &&\n            !(expected && typeof expected.test === 'function')\n        ) {\n            throw new Error(\n                matcherErrorMessage(\n                    matcherHint(matcherName, undefined, undefined, options),\n                    `${EXPECTED_COLOR(\n                        'expected'\n                    )} value must be a string or regular expression`,\n                    printWithType('Expected', expected, printExpected)\n                )\n            );\n        }\n\n        const pass =\n            typeof expected === 'string'\n                ? received.includes(expected)\n                : new RegExp(expected).test(received);\n\n        const message = pass\n            ? () =>\n                  typeof expected === 'string'\n                      ? matcherHint(\n                            matcherName,\n                            undefined,\n                            undefined,\n                            options\n                        ) +\n                        '\\n\\n' +\n                        `Expected substring: not ${printExpected(expected)}\\n` +\n                        `Received string:        ${printReceivedStringContainExpectedSubstring(\n                            received,\n                            received.indexOf(expected),\n                            expected.length\n                        )}`\n                      : matcherHint(\n                            matcherName,\n                            undefined,\n                            undefined,\n                            options\n                        ) +\n                        '\\n\\n' +\n                        `Expected pattern: not ${printExpected(expected)}\\n` +\n                        `Received string:      ${printReceivedStringContainExpectedResult(\n                            received,\n                            typeof expected.exec === 'function'\n                                ? expected.exec(received)\n                                : null\n                        )}`\n            : () => {\n                  const labelExpected = `Expected ${\n                      typeof expected === 'string' ? 'substring' : 'pattern'\n                  }`;\n                  const labelReceived = 'Received string';\n                  const printLabel = getLabelPrinter(\n                      labelExpected,\n                      labelReceived\n                  );\n\n                  return (\n                      matcherHint(matcherName, undefined, undefined, options) +\n                      '\\n\\n' +\n                      `${printLabel(labelExpected)}${printExpected(\n                          expected\n                      )}\\n` +\n                      `${printLabel(labelReceived)}${printReceived(received)}`\n                  );\n              };\n\n        return { message, pass };\n    },\n\n    toMatchObject(received: object, expected: object) {\n        const matcherName = 'toMatchObject';\n        const options: MatcherHintOptions = {\n            isNot: this.isNot,\n            promise: this.promise,\n        };\n\n        if (typeof received !== 'object' || received === null) {\n            throw new Error(\n                matcherErrorMessage(\n                    matcherHint(matcherName, undefined, undefined, options),\n                    `${RECEIVED_COLOR(\n                        'received'\n                    )} value must be a non-null object`,\n                    printWithType('Received', received, printReceived)\n                )\n            );\n        }\n\n        if (typeof expected !== 'object' || expected === null) {\n            throw new Error(\n                matcherErrorMessage(\n                    matcherHint(matcherName, undefined, undefined, options),\n                    `${EXPECTED_COLOR(\n                        'expected'\n                    )} value must be a non-null object`,\n                    printWithType('Expected', expected, printExpected)\n                )\n            );\n        }\n\n        const pass = equals(received, expected, [\n            iterableEquality,\n            subsetEquality,\n        ]);\n\n        const message = pass\n            ? () =>\n                  matcherHint(matcherName, undefined, undefined, options) +\n                  '\\n\\n' +\n                  `Expected: not ${printExpected(expected)}` +\n                  (stringify(expected) !== stringify(received)\n                      ? `\\nReceived:     ${printReceived(received)}`\n                      : '')\n            : () =>\n                  matcherHint(matcherName, undefined, undefined, options) +\n                  '\\n\\n' +\n                  printDiffOrStringify(\n                      expected,\n                      getObjectSubset(received, expected),\n                      EXPECTED_LABEL,\n                      RECEIVED_LABEL,\n                      isExpand(this.expand)\n                  );\n\n        return { message, pass };\n    },\n\n    toStrictEqual(received: unknown, expected: unknown) {\n        const matcherName = 'toStrictEqual';\n        const options: MatcherHintOptions = {\n            comment: 'deep equality',\n            isNot: this.isNot,\n            promise: this.promise,\n        };\n\n        const pass = equals(received, expected, toStrictEqualTesters, true);\n\n        const message = pass\n            ? () =>\n                  matcherHint(matcherName, undefined, undefined, options) +\n                  '\\n\\n' +\n                  `Expected: not ${printExpected(expected)}\\n` +\n                  (stringify(expected) !== stringify(received)\n                      ? `Received:     ${printReceived(received)}`\n                      : '')\n            : () =>\n                  matcherHint(matcherName, undefined, undefined, options) +\n                  '\\n\\n' +\n                  printDiffOrStringify(\n                      expected,\n                      received,\n                      EXPECTED_LABEL,\n                      RECEIVED_LABEL,\n                      isExpand(this.expand)\n                  );\n\n        // Passing the actual and expected objects so that a custom reporter\n        // could access them, for example in order to display a custom visual diff,\n        // or create a different error message\n        return { actual: received, expected, message, name: matcherName, pass };\n    },\n};\n\nexport default matchers;\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport { getType, isPrimitive } from './get-type';\nimport {\n    DIM_COLOR,\n    EXPECTED_COLOR,\n    MatcherHintOptions,\n    RECEIVED_COLOR,\n    diff,\n    ensureExpectedIsNonNegativeInteger,\n    ensureNoExpected,\n    matcherErrorMessage,\n    matcherHint,\n    printExpected,\n    printReceived,\n    printWithType,\n    stringify,\n} from './matcher-utils';\nimport { equals } from './jasmineUtils';\nimport type {\n    MatcherState,\n    MatchersObject,\n    SyncExpectationResult,\n} from './types';\nimport { iterableEquality } from './utils';\n\n// The optional property of matcher context is true if undefined.\nconst isExpand = (expand?: boolean): boolean => expand !== false;\n\nconst PRINT_LIMIT = 3;\n\nconst NO_ARGUMENTS = 'called with 0 arguments';\n\nconst printExpectedArgs = (expected: Array<unknown>): string =>\n    expected.length === 0\n        ? NO_ARGUMENTS\n        : expected.map((arg) => printExpected(arg)).join(', ');\n\nconst printReceivedArgs = (\n    received: Array<unknown>,\n    expected?: Array<unknown>\n): string =>\n    received.length === 0\n        ? NO_ARGUMENTS\n        : received\n              .map((arg, i) =>\n                  Array.isArray(expected) &&\n                  i < expected.length &&\n                  isEqualValue(expected[i], arg)\n                      ? printCommon(arg)\n                      : printReceived(arg)\n              )\n              .join(', ');\n\nconst printCommon = (val: unknown) => DIM_COLOR(stringify(val));\n\nconst isEqualValue = (expected: unknown, received: unknown): boolean =>\n    equals(expected, received, [iterableEquality]);\n\nconst isEqualCall = (\n    expected: Array<unknown>,\n    received: Array<unknown>\n): boolean => isEqualValue(expected, received);\n\nconst isEqualReturn = (expected: unknown, result: any): boolean =>\n    result.type === 'return' && isEqualValue(expected, result.value);\n\nconst countReturns = (results: Array<any>): number =>\n    results.reduce(\n        (n: number, result: any) => (result.type === 'return' ? n + 1 : n),\n        0\n    );\n\nconst printNumberOfReturns = (\n    countReturns: number,\n    countCalls: number\n): string =>\n    `\\nNumber of returns: ${printReceived(countReturns)}` +\n    (countCalls !== countReturns\n        ? `\\nNumber of calls:   ${printReceived(countCalls)}`\n        : '');\n\ntype PrintLabel = (string: string, isExpectedCall: boolean) => string;\n\n// Given a label, return a function which given a string,\n// right-aligns it preceding the colon in the label.\nconst getRightAlignedPrinter = (label: string): PrintLabel => {\n    // Assume that the label contains a colon.\n    const index = label.indexOf(':');\n    const suffix = label.slice(index);\n\n    return (string: string, isExpectedCall: boolean) =>\n        (isExpectedCall\n            ? '->' + ' '.repeat(Math.max(0, index - 2 - string.length))\n            : ' '.repeat(Math.max(index - string.length))) +\n        string +\n        suffix;\n};\n\ntype IndexedCall = [number, Array<unknown>];\n\nconst printReceivedCallsNegative = (\n    expected: Array<unknown>,\n    indexedCalls: Array<IndexedCall>,\n    isOnlyCall: boolean,\n    iExpectedCall?: number\n) => {\n    if (indexedCalls.length === 0) {\n        return '';\n    }\n\n    const label = 'Received:     ';\n    if (isOnlyCall) {\n        return label + printReceivedArgs(indexedCalls[0], expected) + '\\n';\n    }\n\n    const printAligned = getRightAlignedPrinter(label);\n\n    return (\n        'Received\\n' +\n        indexedCalls.reduce(\n            (printed: string, [i, args]: IndexedCall) =>\n                printed +\n                printAligned(String(i + 1), i === iExpectedCall) +\n                printReceivedArgs(args, expected) +\n                '\\n',\n            ''\n        )\n    );\n};\n\nconst printExpectedReceivedCallsPositive = (\n    expected: Array<unknown>,\n    indexedCalls: Array<IndexedCall>,\n    expand: boolean,\n    isOnlyCall: boolean,\n    iExpectedCall?: number\n) => {\n    const expectedLine = `Expected: ${printExpectedArgs(expected)}\\n`;\n    if (indexedCalls.length === 0) {\n        return expectedLine;\n    }\n\n    const label = 'Received: ';\n    if (isOnlyCall && (iExpectedCall === 0 || iExpectedCall === undefined)) {\n        const received = indexedCalls[0][1];\n\n        if (isLineDiffableCall(expected, received)) {\n            // Display diff without indentation.\n            const lines = [\n                EXPECTED_COLOR('- Expected'),\n                RECEIVED_COLOR('+ Received'),\n                '',\n            ];\n\n            const length = Math.max(expected.length, received.length);\n            for (let i = 0; i < length; i += 1) {\n                if (i < expected.length && i < received.length) {\n                    if (isEqualValue(expected[i], received[i])) {\n                        lines.push(`  ${printCommon(received[i])},`);\n                        continue;\n                    }\n\n                    if (isLineDiffableArg(expected[i], received[i])) {\n                        const difference = diff(expected[i], received[i], {\n                            expand,\n                        });\n                        if (\n                            typeof difference === 'string' &&\n                            difference.includes('- Expected') &&\n                            difference.includes('+ Received')\n                        ) {\n                            // Omit annotation in case multiple args have diff.\n                            lines.push(\n                                difference.split('\\n').slice(3).join('\\n') + ','\n                            );\n                            continue;\n                        }\n                    }\n                }\n\n                if (i < expected.length) {\n                    lines.push(\n                        EXPECTED_COLOR('- ' + stringify(expected[i])) + ','\n                    );\n                }\n                if (i < received.length) {\n                    lines.push(\n                        RECEIVED_COLOR('+ ' + stringify(received[i])) + ','\n                    );\n                }\n            }\n\n            return lines.join('\\n') + '\\n';\n        }\n\n        return (\n            expectedLine + label + printReceivedArgs(received, expected) + '\\n'\n        );\n    }\n\n    const printAligned = getRightAlignedPrinter(label);\n\n    return (\n        expectedLine +\n        'Received\\n' +\n        indexedCalls.reduce((printed: string, [i, received]: IndexedCall) => {\n            const aligned = printAligned(String(i + 1), i === iExpectedCall);\n            return (\n                printed +\n                ((i === iExpectedCall || iExpectedCall === undefined) &&\n                isLineDiffableCall(expected, received)\n                    ? aligned.replace(': ', '\\n') +\n                      printDiffCall(expected, received, expand)\n                    : aligned + printReceivedArgs(received, expected)) +\n                '\\n'\n            );\n        }, '')\n    );\n};\n\nconst indentation = 'Received'.replace(/\\w/g, ' ');\n\nconst printDiffCall = (\n    expected: Array<unknown>,\n    received: Array<unknown>,\n    expand: boolean\n) =>\n    received\n        .map((arg, i) => {\n            if (i < expected.length) {\n                if (isEqualValue(expected[i], arg)) {\n                    return indentation + '  ' + printCommon(arg) + ',';\n                }\n\n                if (isLineDiffableArg(expected[i], arg)) {\n                    const difference = diff(expected[i], arg, { expand });\n\n                    if (\n                        typeof difference === 'string' &&\n                        difference.includes('- Expected') &&\n                        difference.includes('+ Received')\n                    ) {\n                        // Display diff with indentation.\n                        // Omit annotation in case multiple args have diff.\n                        return (\n                            difference\n                                .split('\\n')\n                                .slice(3)\n                                .map((line) => indentation + line)\n                                .join('\\n') + ','\n                        );\n                    }\n                }\n            }\n\n            // Display + only if received arg has no corresponding expected arg.\n            return (\n                indentation +\n                (i < expected.length\n                    ? '  ' + printReceived(arg)\n                    : RECEIVED_COLOR('+ ' + stringify(arg))) +\n                ','\n            );\n        })\n        .join('\\n');\n\nconst isLineDiffableCall = (\n    expected: Array<unknown>,\n    received: Array<unknown>\n): boolean =>\n    expected.some(\n        (arg, i) => i < received.length && isLineDiffableArg(arg, received[i])\n    );\n\n// Almost redundant with function in jest-matcher-utils,\n// except no line diff for any strings.\nconst isLineDiffableArg = (expected: unknown, received: unknown): boolean => {\n    const expectedType = getType(expected);\n    const receivedType = getType(received);\n\n    if (expectedType !== receivedType) {\n        return false;\n    }\n\n    if (isPrimitive(expected)) {\n        return false;\n    }\n\n    if (\n        expectedType === 'date' ||\n        expectedType === 'function' ||\n        expectedType === 'regexp'\n    ) {\n        return false;\n    }\n\n    if (expected instanceof Error && received instanceof Error) {\n        return false;\n    }\n\n    if (\n        expectedType === 'object' &&\n        typeof (expected as any).asymmetricMatch === 'function'\n    ) {\n        return false;\n    }\n\n    if (\n        receivedType === 'object' &&\n        typeof (received as any).asymmetricMatch === 'function'\n    ) {\n        return false;\n    }\n\n    return true;\n};\n\nconst printResult = (result: any, expected: unknown) =>\n    result.type === 'throw'\n        ? 'function call threw an error'\n        : result.type === 'incomplete'\n        ? 'function call has not returned yet'\n        : isEqualValue(expected, result.value)\n        ? printCommon(result.value)\n        : printReceived(result.value);\n\ntype IndexedResult = [number, any];\n\n// Return either empty string or one line per indexed result,\n// so additional empty line can separate from `Number of returns` which follows.\nconst printReceivedResults = (\n    label: string,\n    expected: unknown,\n    indexedResults: Array<IndexedResult>,\n    isOnlyCall: boolean,\n    iExpectedCall?: number\n) => {\n    if (indexedResults.length === 0) {\n        return '';\n    }\n\n    if (isOnlyCall && (iExpectedCall === 0 || iExpectedCall === undefined)) {\n        return label + printResult(indexedResults[0][1], expected) + '\\n';\n    }\n\n    const printAligned = getRightAlignedPrinter(label);\n\n    return (\n        label.replace(':', '').trim() +\n        '\\n' +\n        indexedResults.reduce(\n            (printed: string, [i, result]: IndexedResult) =>\n                printed +\n                printAligned(String(i + 1), i === iExpectedCall) +\n                printResult(result, expected) +\n                '\\n',\n            ''\n        )\n    );\n};\n\nconst createToBeCalledMatcher = (matcherName: string) =>\n    function (\n        this: MatcherState,\n        received: any,\n        expected: unknown\n    ): SyncExpectationResult {\n        const expectedArgument = '';\n        const options: MatcherHintOptions = {\n            isNot: this.isNot,\n            promise: this.promise,\n        };\n        ensureNoExpected(expected, matcherName, options);\n        ensureMockOrSpy(received, matcherName, expectedArgument, options);\n\n        const receivedIsSpy = isSpy(received);\n        const receivedName = receivedIsSpy ? 'spy' : received.getMockName();\n        const count = receivedIsSpy\n            ? received.calls.count()\n            : received.mock.calls.length;\n        const calls = receivedIsSpy\n            ? received.calls.all().map((x: any) => x.args)\n            : received.mock.calls;\n        const pass = count > 0;\n        const message = pass\n            ? () =>\n                  matcherHint(\n                      matcherName,\n                      receivedName,\n                      expectedArgument,\n                      options\n                  ) +\n                  '\\n\\n' +\n                  `Expected number of calls: ${printExpected(0)}\\n` +\n                  `Received number of calls: ${printReceived(count)}\\n\\n` +\n                  calls\n                      .reduce((lines: Array<string>, args: any, i: number) => {\n                          if (lines.length < PRINT_LIMIT) {\n                              lines.push(\n                                  `${i + 1}: ${printReceivedArgs(args)}`\n                              );\n                          }\n\n                          return lines;\n                      }, [])\n                      .join('\\n')\n            : () =>\n                  matcherHint(\n                      matcherName,\n                      receivedName,\n                      expectedArgument,\n                      options\n                  ) +\n                  '\\n\\n' +\n                  `Expected number of calls: >= ${printExpected(1)}\\n` +\n                  `Received number of calls:    ${printReceived(count)}`;\n\n        return { message, pass };\n    };\n\nconst createToReturnMatcher = (matcherName: string) =>\n    function (\n        this: MatcherState,\n        received: any,\n        expected: unknown\n    ): SyncExpectationResult {\n        const expectedArgument = '';\n        const options: MatcherHintOptions = {\n            isNot: this.isNot,\n            promise: this.promise,\n        };\n        ensureNoExpected(expected, matcherName, options);\n        ensureMock(received, matcherName, expectedArgument, options);\n\n        const receivedName = received.getMockName();\n\n        // Count return values that correspond only to calls that returned\n        const count = received.mock.results.reduce(\n            (n: number, result: any) => (result.type === 'return' ? n + 1 : n),\n            0\n        );\n\n        const pass = count > 0;\n\n        const message = pass\n            ? () =>\n                  matcherHint(\n                      matcherName,\n                      receivedName,\n                      expectedArgument,\n                      options\n                  ) +\n                  '\\n\\n' +\n                  `Expected number of returns: ${printExpected(0)}\\n` +\n                  `Received number of returns: ${printReceived(count)}\\n\\n` +\n                  received.mock.results\n                      .reduce(\n                          (lines: Array<string>, result: any, i: number) => {\n                              if (\n                                  result.type === 'return' &&\n                                  lines.length < PRINT_LIMIT\n                              ) {\n                                  lines.push(\n                                      `${i + 1}: ${printReceived(result.value)}`\n                                  );\n                              }\n\n                              return lines;\n                          },\n                          []\n                      )\n                      .join('\\n') +\n                  (received.mock.calls.length !== count\n                      ? `\\n\\nReceived number of calls:   ${printReceived(\n                            received.mock.calls.length\n                        )}`\n                      : '')\n            : () =>\n                  matcherHint(\n                      matcherName,\n                      receivedName,\n                      expectedArgument,\n                      options\n                  ) +\n                  '\\n\\n' +\n                  `Expected number of returns: >= ${printExpected(1)}\\n` +\n                  `Received number of returns:    ${printReceived(count)}` +\n                  (received.mock.calls.length !== count\n                      ? `\\nReceived number of calls:      ${printReceived(\n                            received.mock.calls.length\n                        )}`\n                      : '');\n\n        return { message, pass };\n    };\n\nconst createToBeCalledTimesMatcher = (matcherName: string) =>\n    function (\n        this: MatcherState,\n        received: any,\n        expected: number\n    ): SyncExpectationResult {\n        const expectedArgument = 'expected';\n        const options: MatcherHintOptions = {\n            isNot: this.isNot,\n            promise: this.promise,\n        };\n        ensureExpectedIsNonNegativeInteger(expected, matcherName, options);\n        ensureMockOrSpy(received, matcherName, expectedArgument, options);\n\n        const receivedIsSpy = isSpy(received);\n        const receivedName = receivedIsSpy ? 'spy' : received.getMockName();\n        const count = receivedIsSpy\n            ? received.calls.count()\n            : received.mock.calls.length;\n\n        const pass = count === expected;\n\n        const message = pass\n            ? () =>\n                  matcherHint(\n                      matcherName,\n                      receivedName,\n                      expectedArgument,\n                      options\n                  ) +\n                  `\\n\\n` +\n                  `Expected number of calls: not ${printExpected(expected)}`\n            : () =>\n                  matcherHint(\n                      matcherName,\n                      receivedName,\n                      expectedArgument,\n                      options\n                  ) +\n                  '\\n\\n' +\n                  `Expected number of calls: ${printExpected(expected)}\\n` +\n                  `Received number of calls: ${printReceived(count)}`;\n\n        return { message, pass };\n    };\n\nconst createToReturnTimesMatcher = (matcherName: string) =>\n    function (\n        this: MatcherState,\n        received: any,\n        expected: number\n    ): SyncExpectationResult {\n        const expectedArgument = 'expected';\n        const options: MatcherHintOptions = {\n            isNot: this.isNot,\n            promise: this.promise,\n        };\n        ensureExpectedIsNonNegativeInteger(expected, matcherName, options);\n        ensureMock(received, matcherName, expectedArgument, options);\n\n        const receivedName = received.getMockName();\n\n        // Count return values that correspond only to calls that returned\n        const count = received.mock.results.reduce(\n            (n: number, result: any) => (result.type === 'return' ? n + 1 : n),\n            0\n        );\n\n        const pass = count === expected;\n\n        const message = pass\n            ? () =>\n                  matcherHint(\n                      matcherName,\n                      receivedName,\n                      expectedArgument,\n                      options\n                  ) +\n                  `\\n\\n` +\n                  `Expected number of returns: not ${printExpected(expected)}` +\n                  (received.mock.calls.length !== count\n                      ? `\\n\\nReceived number of calls:       ${printReceived(\n                            received.mock.calls.length\n                        )}`\n                      : '')\n            : () =>\n                  matcherHint(\n                      matcherName,\n                      receivedName,\n                      expectedArgument,\n                      options\n                  ) +\n                  '\\n\\n' +\n                  `Expected number of returns: ${printExpected(expected)}\\n` +\n                  `Received number of returns: ${printReceived(count)}` +\n                  (received.mock.calls.length !== count\n                      ? `\\nReceived number of calls:   ${printReceived(\n                            received.mock.calls.length\n                        )}`\n                      : '');\n\n        return { message, pass };\n    };\n\nconst createToBeCalledWithMatcher = (matcherName: string) =>\n    function (\n        this: MatcherState,\n        received: any,\n        ...expected: Array<unknown>\n    ): SyncExpectationResult {\n        const expectedArgument = '...expected';\n        const options: MatcherHintOptions = {\n            isNot: this.isNot,\n            promise: this.promise,\n        };\n        ensureMockOrSpy(received, matcherName, expectedArgument, options);\n\n        const receivedIsSpy = isSpy(received);\n        const receivedName = receivedIsSpy ? 'spy' : received.getMockName();\n\n        const calls = receivedIsSpy\n            ? received.calls.all().map((x: any) => x.args)\n            : received.mock.calls;\n\n        const pass = calls.some((call: any) => isEqualCall(expected, call));\n\n        const message = pass\n            ? () => {\n                  // Some examples of calls that are equal to expected value.\n                  const indexedCalls: Array<IndexedCall> = [];\n                  let i = 0;\n                  while (\n                      i < calls.length &&\n                      indexedCalls.length < PRINT_LIMIT\n                  ) {\n                      if (isEqualCall(expected, calls[i])) {\n                          indexedCalls.push([i, calls[i]]);\n                      }\n                      i += 1;\n                  }\n\n                  return (\n                      matcherHint(\n                          matcherName,\n                          receivedName,\n                          expectedArgument,\n                          options\n                      ) +\n                      '\\n\\n' +\n                      `Expected: not ${printExpectedArgs(expected)}\\n` +\n                      (calls.length === 1 &&\n                      stringify(calls[0]) === stringify(expected)\n                          ? ''\n                          : printReceivedCallsNegative(\n                                expected,\n                                indexedCalls,\n                                calls.length === 1\n                            )) +\n                      `\\nNumber of calls: ${printReceived(calls.length)}`\n                  );\n              }\n            : () => {\n                  // Some examples of calls that are not equal to expected value.\n                  const indexedCalls: Array<IndexedCall> = [];\n                  let i = 0;\n                  while (\n                      i < calls.length &&\n                      indexedCalls.length < PRINT_LIMIT\n                  ) {\n                      indexedCalls.push([i, calls[i]]);\n                      i += 1;\n                  }\n\n                  return (\n                      matcherHint(\n                          matcherName,\n                          receivedName,\n                          expectedArgument,\n                          options\n                      ) +\n                      '\\n\\n' +\n                      printExpectedReceivedCallsPositive(\n                          expected,\n                          indexedCalls,\n                          isExpand(this.expand),\n                          calls.length === 1\n                      ) +\n                      `\\nNumber of calls: ${printReceived(calls.length)}`\n                  );\n              };\n\n        return { message, pass };\n    };\n\nconst createToReturnWithMatcher = (matcherName: string) =>\n    function (\n        this: MatcherState,\n        received: any,\n        expected: unknown\n    ): SyncExpectationResult {\n        const expectedArgument = 'expected';\n        const options: MatcherHintOptions = {\n            isNot: this.isNot,\n            promise: this.promise,\n        };\n        ensureMock(received, matcherName, expectedArgument, options);\n\n        const receivedName = received.getMockName();\n        const { calls, results } = received.mock;\n\n        const pass = results.some((result: any) =>\n            isEqualReturn(expected, result)\n        );\n\n        const message = pass\n            ? () => {\n                  // Some examples of results that are equal to expected value.\n                  const indexedResults: Array<IndexedResult> = [];\n                  let i = 0;\n                  while (\n                      i < results.length &&\n                      indexedResults.length < PRINT_LIMIT\n                  ) {\n                      if (isEqualReturn(expected, results[i])) {\n                          indexedResults.push([i, results[i]]);\n                      }\n                      i += 1;\n                  }\n\n                  return (\n                      matcherHint(\n                          matcherName,\n                          receivedName,\n                          expectedArgument,\n                          options\n                      ) +\n                      '\\n\\n' +\n                      `Expected: not ${printExpected(expected)}\\n` +\n                      (results.length === 1 &&\n                      results[0].type === 'return' &&\n                      stringify(results[0].value) === stringify(expected)\n                          ? ''\n                          : printReceivedResults(\n                                'Received:     ',\n                                expected,\n                                indexedResults,\n                                results.length === 1\n                            )) +\n                      printNumberOfReturns(countReturns(results), calls.length)\n                  );\n              }\n            : () => {\n                  // Some examples of results that are not equal to expected value.\n                  const indexedResults: Array<IndexedResult> = [];\n                  let i = 0;\n                  while (\n                      i < results.length &&\n                      indexedResults.length < PRINT_LIMIT\n                  ) {\n                      indexedResults.push([i, results[i]]);\n                      i += 1;\n                  }\n\n                  return (\n                      matcherHint(\n                          matcherName,\n                          receivedName,\n                          expectedArgument,\n                          options\n                      ) +\n                      '\\n\\n' +\n                      `Expected: ${printExpected(expected)}\\n` +\n                      printReceivedResults(\n                          'Received: ',\n                          expected,\n                          indexedResults,\n                          results.length === 1\n                      ) +\n                      printNumberOfReturns(countReturns(results), calls.length)\n                  );\n              };\n\n        return { message, pass };\n    };\n\nconst createLastCalledWithMatcher = (matcherName: string) =>\n    function (\n        this: MatcherState,\n        received: any,\n        ...expected: Array<unknown>\n    ): SyncExpectationResult {\n        const expectedArgument = '...expected';\n        const options: MatcherHintOptions = {\n            isNot: this.isNot,\n            promise: this.promise,\n        };\n        ensureMockOrSpy(received, matcherName, expectedArgument, options);\n\n        const receivedIsSpy = isSpy(received);\n        const receivedName = receivedIsSpy ? 'spy' : received.getMockName();\n\n        const calls = receivedIsSpy\n            ? received.calls.all().map((x: any) => x.args)\n            : received.mock.calls;\n        const iLast = calls.length - 1;\n\n        const pass = iLast >= 0 && isEqualCall(expected, calls[iLast]);\n\n        const message = pass\n            ? () => {\n                  const indexedCalls: Array<IndexedCall> = [];\n                  if (iLast > 0) {\n                      // Display preceding call as context.\n                      indexedCalls.push([iLast - 1, calls[iLast - 1]]);\n                  }\n                  indexedCalls.push([iLast, calls[iLast]]);\n\n                  return (\n                      matcherHint(\n                          matcherName,\n                          receivedName,\n                          expectedArgument,\n                          options\n                      ) +\n                      '\\n\\n' +\n                      `Expected: not ${printExpectedArgs(expected)}\\n` +\n                      (calls.length === 1 &&\n                      stringify(calls[0]) === stringify(expected)\n                          ? ''\n                          : printReceivedCallsNegative(\n                                expected,\n                                indexedCalls,\n                                calls.length === 1,\n                                iLast\n                            )) +\n                      `\\nNumber of calls: ${printReceived(calls.length)}`\n                  );\n              }\n            : () => {\n                  const indexedCalls: Array<IndexedCall> = [];\n                  if (iLast >= 0) {\n                      if (iLast > 0) {\n                          let i = iLast - 1;\n                          // Is there a preceding call that is equal to expected args?\n                          while (i >= 0 && !isEqualCall(expected, calls[i])) {\n                              i -= 1;\n                          }\n                          if (i < 0) {\n                              i = iLast - 1; // otherwise, preceding call\n                          }\n\n                          indexedCalls.push([i, calls[i]]);\n                      }\n\n                      indexedCalls.push([iLast, calls[iLast]]);\n                  }\n\n                  return (\n                      matcherHint(\n                          matcherName,\n                          receivedName,\n                          expectedArgument,\n                          options\n                      ) +\n                      '\\n\\n' +\n                      printExpectedReceivedCallsPositive(\n                          expected,\n                          indexedCalls,\n                          isExpand(this.expand),\n                          calls.length === 1,\n                          iLast\n                      ) +\n                      `\\nNumber of calls: ${printReceived(calls.length)}`\n                  );\n              };\n\n        return { message, pass };\n    };\n\nconst createLastReturnedMatcher = (matcherName: string) =>\n    function (\n        this: MatcherState,\n        received: any,\n        expected: unknown\n    ): SyncExpectationResult {\n        const expectedArgument = 'expected';\n        const options: MatcherHintOptions = {\n            isNot: this.isNot,\n            promise: this.promise,\n        };\n        ensureMock(received, matcherName, expectedArgument, options);\n\n        const receivedName = received.getMockName();\n\n        const { calls, results } = received.mock;\n        const iLast = results.length - 1;\n\n        const pass = iLast >= 0 && isEqualReturn(expected, results[iLast]);\n\n        const message = pass\n            ? () => {\n                  const indexedResults: Array<IndexedResult> = [];\n                  if (iLast > 0) {\n                      // Display preceding result as context.\n                      indexedResults.push([iLast - 1, results[iLast - 1]]);\n                  }\n                  indexedResults.push([iLast, results[iLast]]);\n\n                  return (\n                      matcherHint(\n                          matcherName,\n                          receivedName,\n                          expectedArgument,\n                          options\n                      ) +\n                      '\\n\\n' +\n                      `Expected: not ${printExpected(expected)}\\n` +\n                      (results.length === 1 &&\n                      results[0].type === 'return' &&\n                      stringify(results[0].value) === stringify(expected)\n                          ? ''\n                          : printReceivedResults(\n                                'Received:     ',\n                                expected,\n                                indexedResults,\n                                results.length === 1,\n                                iLast\n                            )) +\n                      printNumberOfReturns(countReturns(results), calls.length)\n                  );\n              }\n            : () => {\n                  const indexedResults: Array<IndexedResult> = [];\n                  if (iLast >= 0) {\n                      if (iLast > 0) {\n                          let i = iLast - 1;\n                          // Is there a preceding result that is equal to expected value?\n                          while (\n                              i >= 0 &&\n                              !isEqualReturn(expected, results[i])\n                          ) {\n                              i -= 1;\n                          }\n                          if (i < 0) {\n                              i = iLast - 1; // otherwise, preceding result\n                          }\n\n                          indexedResults.push([i, results[i]]);\n                      }\n\n                      indexedResults.push([iLast, results[iLast]]);\n                  }\n\n                  return (\n                      matcherHint(\n                          matcherName,\n                          receivedName,\n                          expectedArgument,\n                          options\n                      ) +\n                      '\\n\\n' +\n                      `Expected: ${printExpected(expected)}\\n` +\n                      printReceivedResults(\n                          'Received: ',\n                          expected,\n                          indexedResults,\n                          results.length === 1,\n                          iLast\n                      ) +\n                      printNumberOfReturns(countReturns(results), calls.length)\n                  );\n              };\n\n        return { message, pass };\n    };\n\nconst createNthCalledWithMatcher = (matcherName: string) =>\n    function (\n        this: MatcherState,\n        received: any,\n        nth: number,\n        ...expected: Array<unknown>\n    ): SyncExpectationResult {\n        const expectedArgument = 'n';\n        const options: MatcherHintOptions = {\n            expectedColor: (arg: string) => arg,\n            isNot: this.isNot,\n            promise: this.promise,\n            secondArgument: '...expected',\n        };\n        ensureMockOrSpy(received, matcherName, expectedArgument, options);\n\n        if (!Number.isSafeInteger(nth) || nth < 1) {\n            throw new Error(\n                matcherErrorMessage(\n                    matcherHint(\n                        matcherName,\n                        undefined,\n                        expectedArgument,\n                        options\n                    ),\n                    `${expectedArgument} must be a positive integer`,\n                    printWithType(expectedArgument, nth, stringify)\n                )\n            );\n        }\n\n        const receivedIsSpy = isSpy(received);\n        const receivedName = receivedIsSpy ? 'spy' : received.getMockName();\n\n        const calls = receivedIsSpy\n            ? received.calls.all().map((x: any) => x.args)\n            : received.mock.calls;\n        const length = calls.length;\n        const iNth = nth - 1;\n\n        const pass = iNth < length && isEqualCall(expected, calls[iNth]);\n\n        const message = pass\n            ? () => {\n                  // Display preceding and following calls,\n                  // in case assertions fails because index is off by one.\n                  const indexedCalls: Array<IndexedCall> = [];\n                  if (iNth - 1 >= 0) {\n                      indexedCalls.push([iNth - 1, calls[iNth - 1]]);\n                  }\n                  indexedCalls.push([iNth, calls[iNth]]);\n                  if (iNth + 1 < length) {\n                      indexedCalls.push([iNth + 1, calls[iNth + 1]]);\n                  }\n\n                  return (\n                      matcherHint(\n                          matcherName,\n                          receivedName,\n                          expectedArgument,\n                          options\n                      ) +\n                      '\\n\\n' +\n                      `n: ${nth}\\n` +\n                      `Expected: not ${printExpectedArgs(expected)}\\n` +\n                      (calls.length === 1 &&\n                      stringify(calls[0]) === stringify(expected)\n                          ? ''\n                          : printReceivedCallsNegative(\n                                expected,\n                                indexedCalls,\n                                calls.length === 1,\n                                iNth\n                            )) +\n                      `\\nNumber of calls: ${printReceived(calls.length)}`\n                  );\n              }\n            : () => {\n                  // Display preceding and following calls:\n                  // * nearest call that is equal to expected args\n                  // * otherwise, adjacent call\n                  // in case assertions fails because of index, especially off by one.\n                  const indexedCalls: Array<IndexedCall> = [];\n                  if (iNth < length) {\n                      if (iNth - 1 >= 0) {\n                          let i = iNth - 1;\n                          // Is there a preceding call that is equal to expected args?\n                          while (i >= 0 && !isEqualCall(expected, calls[i])) {\n                              i -= 1;\n                          }\n                          if (i < 0) {\n                              i = iNth - 1; // otherwise, adjacent call\n                          }\n\n                          indexedCalls.push([i, calls[i]]);\n                      }\n                      indexedCalls.push([iNth, calls[iNth]]);\n                      if (iNth + 1 < length) {\n                          let i = iNth + 1;\n                          // Is there a following call that is equal to expected args?\n                          while (\n                              i < length &&\n                              !isEqualCall(expected, calls[i])\n                          ) {\n                              i += 1;\n                          }\n                          if (i >= length) {\n                              i = iNth + 1; // otherwise, adjacent call\n                          }\n\n                          indexedCalls.push([i, calls[i]]);\n                      }\n                  } else if (length > 0) {\n                      // The number of received calls is fewer than the expected number.\n                      let i = length - 1;\n                      // Is there a call that is equal to expected args?\n                      while (i >= 0 && !isEqualCall(expected, calls[i])) {\n                          i -= 1;\n                      }\n                      if (i < 0) {\n                          i = length - 1; // otherwise, last call\n                      }\n\n                      indexedCalls.push([i, calls[i]]);\n                  }\n\n                  return (\n                      matcherHint(\n                          matcherName,\n                          receivedName,\n                          expectedArgument,\n                          options\n                      ) +\n                      '\\n\\n' +\n                      `n: ${nth}\\n` +\n                      printExpectedReceivedCallsPositive(\n                          expected,\n                          indexedCalls,\n                          isExpand(this.expand),\n                          calls.length === 1,\n                          iNth\n                      ) +\n                      `\\nNumber of calls: ${printReceived(calls.length)}`\n                  );\n              };\n\n        return { message, pass };\n    };\n\nconst createNthReturnedWithMatcher = (matcherName: string) =>\n    function (\n        this: MatcherState,\n        received: any,\n        nth: number,\n        expected: unknown\n    ): SyncExpectationResult {\n        const expectedArgument = 'n';\n        const options: MatcherHintOptions = {\n            expectedColor: (arg: string) => arg,\n            isNot: this.isNot,\n            promise: this.promise,\n            secondArgument: 'expected',\n        };\n        ensureMock(received, matcherName, expectedArgument, options);\n\n        if (!Number.isSafeInteger(nth) || nth < 1) {\n            throw new Error(\n                matcherErrorMessage(\n                    matcherHint(\n                        matcherName,\n                        undefined,\n                        expectedArgument,\n                        options\n                    ),\n                    `${expectedArgument} must be a positive integer`,\n                    printWithType(expectedArgument, nth, stringify)\n                )\n            );\n        }\n\n        const receivedName = received.getMockName();\n        const { calls, results } = received.mock;\n        const length = results.length;\n        const iNth = nth - 1;\n\n        const pass = iNth < length && isEqualReturn(expected, results[iNth]);\n\n        const message = pass\n            ? () => {\n                  // Display preceding and following results,\n                  // in case assertions fails because index is off by one.\n                  const indexedResults: Array<IndexedResult> = [];\n                  if (iNth - 1 >= 0) {\n                      indexedResults.push([iNth - 1, results[iNth - 1]]);\n                  }\n                  indexedResults.push([iNth, results[iNth]]);\n                  if (iNth + 1 < length) {\n                      indexedResults.push([iNth + 1, results[iNth + 1]]);\n                  }\n\n                  return (\n                      matcherHint(\n                          matcherName,\n                          receivedName,\n                          expectedArgument,\n                          options\n                      ) +\n                      '\\n\\n' +\n                      `n: ${nth}\\n` +\n                      `Expected: not ${printExpected(expected)}\\n` +\n                      (results.length === 1 &&\n                      results[0].type === 'return' &&\n                      stringify(results[0].value) === stringify(expected)\n                          ? ''\n                          : printReceivedResults(\n                                'Received:     ',\n                                expected,\n                                indexedResults,\n                                results.length === 1,\n                                iNth\n                            )) +\n                      printNumberOfReturns(countReturns(results), calls.length)\n                  );\n              }\n            : () => {\n                  // Display preceding and following results:\n                  // * nearest result that is equal to expected value\n                  // * otherwise, adjacent result\n                  // in case assertions fails because of index, especially off by one.\n                  const indexedResults: Array<IndexedResult> = [];\n                  if (iNth < length) {\n                      if (iNth - 1 >= 0) {\n                          let i = iNth - 1;\n                          // Is there a preceding result that is equal to expected value?\n                          while (\n                              i >= 0 &&\n                              !isEqualReturn(expected, results[i])\n                          ) {\n                              i -= 1;\n                          }\n                          if (i < 0) {\n                              i = iNth - 1; // otherwise, adjacent result\n                          }\n\n                          indexedResults.push([i, results[i]]);\n                      }\n                      indexedResults.push([iNth, results[iNth]]);\n                      if (iNth + 1 < length) {\n                          let i = iNth + 1;\n                          // Is there a following result that is equal to expected value?\n                          while (\n                              i < length &&\n                              !isEqualReturn(expected, results[i])\n                          ) {\n                              i += 1;\n                          }\n                          if (i >= length) {\n                              i = iNth + 1; // otherwise, adjacent result\n                          }\n\n                          indexedResults.push([i, results[i]]);\n                      }\n                  } else if (length > 0) {\n                      // The number of received calls is fewer than the expected number.\n                      let i = length - 1;\n                      // Is there a result that is equal to expected value?\n                      while (i >= 0 && !isEqualReturn(expected, results[i])) {\n                          i -= 1;\n                      }\n                      if (i < 0) {\n                          i = length - 1; // otherwise, last result\n                      }\n\n                      indexedResults.push([i, results[i]]);\n                  }\n\n                  return (\n                      matcherHint(\n                          matcherName,\n                          receivedName,\n                          expectedArgument,\n                          options\n                      ) +\n                      '\\n\\n' +\n                      `n: ${nth}\\n` +\n                      `Expected: ${printExpected(expected)}\\n` +\n                      printReceivedResults(\n                          'Received: ',\n                          expected,\n                          indexedResults,\n                          results.length === 1,\n                          iNth\n                      ) +\n                      printNumberOfReturns(countReturns(results), calls.length)\n                  );\n              };\n\n        return { message, pass };\n    };\n\nconst spyMatchers: MatchersObject = {\n    lastCalledWith: createLastCalledWithMatcher('lastCalledWith'),\n    lastReturnedWith: createLastReturnedMatcher('lastReturnedWith'),\n    nthCalledWith: createNthCalledWithMatcher('nthCalledWith'),\n    nthReturnedWith: createNthReturnedWithMatcher('nthReturnedWith'),\n    toBeCalled: createToBeCalledMatcher('toBeCalled'),\n    toBeCalledTimes: createToBeCalledTimesMatcher('toBeCalledTimes'),\n    toBeCalledWith: createToBeCalledWithMatcher('toBeCalledWith'),\n    toHaveBeenCalled: createToBeCalledMatcher('toHaveBeenCalled'),\n    toHaveBeenCalledTimes: createToBeCalledTimesMatcher(\n        'toHaveBeenCalledTimes'\n    ),\n    toHaveBeenCalledWith: createToBeCalledWithMatcher('toHaveBeenCalledWith'),\n    toHaveBeenLastCalledWith: createLastCalledWithMatcher(\n        'toHaveBeenLastCalledWith'\n    ),\n    toHaveBeenNthCalledWith: createNthCalledWithMatcher(\n        'toHaveBeenNthCalledWith'\n    ),\n    toHaveLastReturnedWith: createLastReturnedMatcher('toHaveLastReturnedWith'),\n    toHaveNthReturnedWith: createNthReturnedWithMatcher(\n        'toHaveNthReturnedWith'\n    ),\n    toHaveReturned: createToReturnMatcher('toHaveReturned'),\n    toHaveReturnedTimes: createToReturnTimesMatcher('toHaveReturnedTimes'),\n    toHaveReturnedWith: createToReturnWithMatcher('toHaveReturnedWith'),\n    toReturn: createToReturnMatcher('toReturn'),\n    toReturnTimes: createToReturnTimesMatcher('toReturnTimes'),\n    toReturnWith: createToReturnWithMatcher('toReturnWith'),\n};\n\nconst isMock = (received: any) =>\n    received != null && received._isMockFunction === true;\n\nconst isSpy = (received: any) =>\n    received != null &&\n    received.calls != null &&\n    typeof received.calls.all === 'function' &&\n    typeof received.calls.count === 'function';\n\nconst ensureMockOrSpy = (\n    received: any,\n    matcherName: string,\n    expectedArgument: string,\n    options: MatcherHintOptions\n) => {\n    if (!isMock(received) && !isSpy(received)) {\n        throw new Error(\n            matcherErrorMessage(\n                matcherHint(matcherName, undefined, expectedArgument, options),\n                `${RECEIVED_COLOR(\n                    'received'\n                )} value must be a mock or spy function`,\n                printWithType('Received', received, printReceived)\n            )\n        );\n    }\n};\n\nconst ensureMock = (\n    received: any,\n    matcherName: string,\n    expectedArgument: string,\n    options: MatcherHintOptions\n) => {\n    if (!isMock(received)) {\n        throw new Error(\n            matcherErrorMessage(\n                matcherHint(matcherName, undefined, expectedArgument, options),\n                `${RECEIVED_COLOR('received')} value must be a mock function`,\n                printWithType('Received', received, printReceived)\n            )\n        );\n    }\n};\n\nexport default spyMatchers;\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst errorRegexp = /^Error:?\\s*$/;\n\nconst removeBlankErrorLine = (str: string) =>\n    str\n        .split('\\n')\n        // Lines saying just `Error:` are useless\n        .filter((line) => !errorRegexp.test(line))\n        .join('\\n')\n        .trimRight();\n\n// jasmine and worker farm sometimes don't give us access to the actual\n// Error object, so we have to regexp out the message from the stack string\n// to format it.\nexport const separateMessageFromStack = (\n    content: string\n): { message: string; stack: string } => {\n    if (!content) {\n        return { message: '', stack: '' };\n    }\n\n    // All lines up to what looks like a stack -- or if nothing looks like a stack\n    // (maybe it's a code frame instead), just the first non-empty line.\n    // If the error is a plain \"Error:\" instead of a SyntaxError or TypeError we\n    // remove the prefix from the message because it is generally not useful.\n    const messageMatch = content.match(\n        /^(?:Error: )?([\\s\\S]*?(?=\\n\\s*at\\s.*:\\d*:\\d*)|\\s*.*)([\\s\\S]*)$/\n    );\n    if (!messageMatch) {\n        // For typescript\n        throw new Error('If you hit this error, the regex above is buggy.');\n    }\n    const message = removeBlankErrorLine(messageMatch[1]);\n    const stack = removeBlankErrorLine(messageMatch[2]);\n    return { message, stack };\n};\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/* eslint-disable local/ban-types-eventually */\n\nimport {\n    EXPECTED_COLOR,\n    MatcherHintOptions,\n    RECEIVED_COLOR,\n    matcherErrorMessage,\n    matcherHint,\n    printDiffOrStringify,\n    printExpected,\n    printReceived,\n    printWithType,\n} from './matcher-utils';\nimport { separateMessageFromStack } from './message-util';\nimport {\n    printExpectedConstructorName,\n    printExpectedConstructorNameNot,\n    printReceivedConstructorName,\n    printReceivedConstructorNameNot,\n    printReceivedStringContainExpectedResult,\n    printReceivedStringContainExpectedSubstring,\n} from './print';\nimport type {\n    ExpectationResult,\n    MatcherState,\n    MatchersObject,\n    RawMatcherFn,\n    SyncExpectationResult,\n} from './types';\nimport { isError } from './utils';\n\nconst DID_NOT_THROW = 'Received function did not throw';\n\ntype Thrown =\n    | {\n          hasMessage: true;\n          isError: true;\n          message: string;\n          value: Error;\n      }\n    | {\n          hasMessage: boolean;\n          isError: false;\n          message: string;\n          value: any;\n      };\n\nconst getThrown = (e: any): Thrown => {\n    const hasMessage =\n        e !== null && e !== undefined && typeof e.message === 'string';\n\n    if (\n        hasMessage &&\n        typeof e.name === 'string' &&\n        typeof e.stack === 'string'\n    ) {\n        return {\n            hasMessage,\n            isError: true,\n            message: e.message,\n            value: e,\n        };\n    }\n\n    return {\n        hasMessage,\n        isError: false,\n        message: hasMessage ? e.message : String(e),\n        value: e,\n    };\n};\n\nexport const createMatcher = (\n    matcherName: string,\n    fromPromise?: boolean\n): RawMatcherFn =>\n    function (\n        this: MatcherState,\n        received: Function,\n        expected: any\n    ): ExpectationResult {\n        const options = {\n            isNot: this.isNot,\n            promise: this.promise,\n        };\n\n        let thrown = null;\n\n        if (fromPromise && isError(received)) {\n            thrown = getThrown(received);\n        } else {\n            if (typeof received !== 'function') {\n                if (!fromPromise) {\n                    const placeholder =\n                        expected === undefined ? '' : 'expected';\n                    throw new Error(\n                        matcherErrorMessage(\n                            matcherHint(\n                                matcherName,\n                                undefined,\n                                placeholder,\n                                options\n                            ),\n                            `${RECEIVED_COLOR(\n                                'received'\n                            )} value must be a function`,\n                            printWithType('Received', received, printReceived)\n                        )\n                    );\n                }\n            } else {\n                try {\n                    received();\n                } catch (e: unknown) {\n                    thrown = getThrown(e);\n                }\n            }\n        }\n\n        if (expected === undefined) {\n            return toThrow(matcherName, options, thrown);\n        } else if (typeof expected === 'function') {\n            return toThrowExpectedClass(matcherName, options, thrown, expected);\n        } else if (typeof expected === 'string') {\n            return toThrowExpectedString(\n                matcherName,\n                options,\n                thrown,\n                expected\n            );\n        } else if (expected !== null && typeof expected.test === 'function') {\n            return toThrowExpectedRegExp(\n                matcherName,\n                options,\n                thrown,\n                expected\n            );\n        } else if (\n            expected !== null &&\n            typeof expected.asymmetricMatch === 'function'\n        ) {\n            return toThrowExpectedAsymmetric(\n                matcherName,\n                options,\n                thrown,\n                expected\n            );\n        } else if (expected !== null && typeof expected === 'object') {\n            return toThrowExpectedObject(\n                matcherName,\n                options,\n                thrown,\n                expected\n            );\n        } else {\n            throw new Error(\n                matcherErrorMessage(\n                    matcherHint(matcherName, undefined, undefined, options),\n                    `${EXPECTED_COLOR(\n                        'expected'\n                    )} value must be a string or regular expression or class or error`,\n                    printWithType('Expected', expected, printExpected)\n                )\n            );\n        }\n    };\n\nconst matchers: MatchersObject = {\n    toThrow: createMatcher('toThrow'),\n    toThrowError: createMatcher('toThrowError'),\n};\n\nconst toThrowExpectedRegExp = (\n    matcherName: string,\n    options: MatcherHintOptions,\n    thrown: Thrown | null,\n    expected: RegExp\n): SyncExpectationResult => {\n    const pass = thrown !== null && expected.test(thrown.message);\n\n    const message = pass\n        ? () =>\n              matcherHint(matcherName, undefined, undefined, options) +\n              '\\n\\n' +\n              formatExpected('Expected pattern: not ', expected) +\n              (thrown !== null && thrown.hasMessage\n                  ? formatReceived(\n                        'Received message:     ',\n                        thrown,\n                        'message',\n                        expected\n                    ) + formatStack(thrown)\n                  : formatReceived('Received value:       ', thrown, 'value'))\n        : () =>\n              matcherHint(matcherName, undefined, undefined, options) +\n              '\\n\\n' +\n              formatExpected('Expected pattern: ', expected) +\n              (thrown === null\n                  ? '\\n' + DID_NOT_THROW\n                  : thrown.hasMessage\n                  ? formatReceived('Received message: ', thrown, 'message') +\n                    formatStack(thrown)\n                  : formatReceived('Received value:   ', thrown, 'value'));\n\n    return { message, pass };\n};\n\ntype AsymmetricMatcher = {\n    asymmetricMatch: (received: unknown) => boolean;\n};\n\nconst toThrowExpectedAsymmetric = (\n    matcherName: string,\n    options: MatcherHintOptions,\n    thrown: Thrown | null,\n    expected: AsymmetricMatcher\n): SyncExpectationResult => {\n    const pass = thrown !== null && expected.asymmetricMatch(thrown.value);\n\n    const message = pass\n        ? () =>\n              matcherHint(matcherName, undefined, undefined, options) +\n              '\\n\\n' +\n              formatExpected('Expected asymmetric matcher: not ', expected) +\n              '\\n' +\n              (thrown !== null && thrown.hasMessage\n                  ? formatReceived('Received name:    ', thrown, 'name') +\n                    formatReceived('Received message: ', thrown, 'message') +\n                    formatStack(thrown)\n                  : formatReceived('Thrown value: ', thrown, 'value'))\n        : () =>\n              matcherHint(matcherName, undefined, undefined, options) +\n              '\\n\\n' +\n              formatExpected('Expected asymmetric matcher: ', expected) +\n              '\\n' +\n              (thrown === null\n                  ? DID_NOT_THROW\n                  : thrown.hasMessage\n                  ? formatReceived('Received name:    ', thrown, 'name') +\n                    formatReceived('Received message: ', thrown, 'message') +\n                    formatStack(thrown)\n                  : formatReceived('Thrown value: ', thrown, 'value'));\n\n    return { message, pass };\n};\n\nconst toThrowExpectedObject = (\n    matcherName: string,\n    options: MatcherHintOptions,\n    thrown: Thrown | null,\n    expected: Error\n): SyncExpectationResult => {\n    const pass = thrown !== null && thrown.message === expected.message;\n\n    const message = pass\n        ? () =>\n              matcherHint(matcherName, undefined, undefined, options) +\n              '\\n\\n' +\n              formatExpected('Expected message: not ', expected.message) +\n              (thrown !== null && thrown.hasMessage\n                  ? formatStack(thrown)\n                  : formatReceived('Received value:       ', thrown, 'value'))\n        : () =>\n              matcherHint(matcherName, undefined, undefined, options) +\n              '\\n\\n' +\n              (thrown === null\n                  ? formatExpected('Expected message: ', expected.message) +\n                    '\\n' +\n                    DID_NOT_THROW\n                  : thrown.hasMessage\n                  ? printDiffOrStringify(\n                        expected.message,\n                        thrown.message,\n                        'Expected message',\n                        'Received message',\n                        true\n                    ) +\n                    '\\n' +\n                    formatStack(thrown)\n                  : formatExpected('Expected message: ', expected.message) +\n                    formatReceived('Received value:   ', thrown, 'value'));\n\n    return { message, pass };\n};\n\nconst toThrowExpectedClass = (\n    matcherName: string,\n    options: MatcherHintOptions,\n    thrown: Thrown | null,\n    expected: Function\n): SyncExpectationResult => {\n    const pass = thrown !== null && thrown.value instanceof expected;\n\n    const message = pass\n        ? () =>\n              matcherHint(matcherName, undefined, undefined, options) +\n              '\\n\\n' +\n              printExpectedConstructorNameNot(\n                  'Expected constructor',\n                  expected\n              ) +\n              (thrown !== null &&\n              thrown.value != null &&\n              typeof thrown.value.constructor === 'function' &&\n              thrown.value.constructor !== expected\n                  ? printReceivedConstructorNameNot(\n                        'Received constructor',\n                        thrown.value.constructor,\n                        expected\n                    )\n                  : '') +\n              '\\n' +\n              (thrown !== null && thrown.hasMessage\n                  ? formatReceived('Received message: ', thrown, 'message') +\n                    formatStack(thrown)\n                  : formatReceived('Received value: ', thrown, 'value'))\n        : () =>\n              matcherHint(matcherName, undefined, undefined, options) +\n              '\\n\\n' +\n              printExpectedConstructorName('Expected constructor', expected) +\n              (thrown === null\n                  ? '\\n' + DID_NOT_THROW\n                  : (thrown.value != null &&\n                    typeof thrown.value.constructor === 'function'\n                        ? printReceivedConstructorName(\n                              'Received constructor',\n                              thrown.value.constructor\n                          )\n                        : '') +\n                    '\\n' +\n                    (thrown.hasMessage\n                        ? formatReceived(\n                              'Received message: ',\n                              thrown,\n                              'message'\n                          ) + formatStack(thrown)\n                        : formatReceived('Received value: ', thrown, 'value')));\n\n    return { message, pass };\n};\n\nconst toThrowExpectedString = (\n    matcherName: string,\n    options: MatcherHintOptions,\n    thrown: Thrown | null,\n    expected: string\n): SyncExpectationResult => {\n    const pass = thrown !== null && thrown.message.includes(expected);\n\n    const message = pass\n        ? () =>\n              matcherHint(matcherName, undefined, undefined, options) +\n              '\\n\\n' +\n              formatExpected('Expected substring: not ', expected) +\n              (thrown !== null && thrown.hasMessage\n                  ? formatReceived(\n                        'Received message:       ',\n                        thrown,\n                        'message',\n                        expected\n                    ) + formatStack(thrown)\n                  : formatReceived('Received value:         ', thrown, 'value'))\n        : () =>\n              matcherHint(matcherName, undefined, undefined, options) +\n              '\\n\\n' +\n              formatExpected('Expected substring: ', expected) +\n              (thrown === null\n                  ? '\\n' + DID_NOT_THROW\n                  : thrown.hasMessage\n                  ? formatReceived('Received message:   ', thrown, 'message') +\n                    formatStack(thrown)\n                  : formatReceived('Received value:     ', thrown, 'value'));\n\n    return { message, pass };\n};\n\nconst toThrow = (\n    matcherName: string,\n    options: MatcherHintOptions,\n    thrown: Thrown | null\n): SyncExpectationResult => {\n    const pass = thrown !== null;\n\n    const message = pass\n        ? () =>\n              matcherHint(matcherName, undefined, '', options) +\n              '\\n\\n' +\n              (thrown !== null && thrown.hasMessage\n                  ? formatReceived('Error name:    ', thrown, 'name') +\n                    formatReceived('Error message: ', thrown, 'message') +\n                    formatStack(thrown)\n                  : formatReceived('Thrown value: ', thrown, 'value'))\n        : () =>\n              matcherHint(matcherName, undefined, '', options) +\n              '\\n\\n' +\n              DID_NOT_THROW;\n\n    return { message, pass };\n};\n\nconst formatExpected = (label: string, expected: unknown) =>\n    label + printExpected(expected) + '\\n';\n\nconst formatReceived = (\n    label: string,\n    thrown: Thrown | null,\n    key: string,\n    expected?: string | RegExp\n) => {\n    if (thrown === null) {\n        return '';\n    }\n\n    if (key === 'message') {\n        const message = thrown.message;\n\n        if (typeof expected === 'string') {\n            const index = message.indexOf(expected);\n            if (index !== -1) {\n                return (\n                    label +\n                    printReceivedStringContainExpectedSubstring(\n                        message,\n                        index,\n                        expected.length\n                    ) +\n                    '\\n'\n                );\n            }\n        } else if (expected instanceof RegExp) {\n            return (\n                label +\n                printReceivedStringContainExpectedResult(\n                    message,\n                    typeof expected.exec === 'function'\n                        ? expected.exec(message)\n                        : null\n                ) +\n                '\\n'\n            );\n        }\n\n        return label + printReceived(message) + '\\n';\n    }\n\n    if (key === 'name') {\n        return thrown.isError\n            ? label + printReceived(thrown.value.name) + '\\n'\n            : '';\n    }\n\n    if (key === 'value') {\n        return thrown.isError ? '' : label + printReceived(thrown.value) + '\\n';\n    }\n\n    return '';\n};\n\nconst formatStack = (thrown: Thrown | null) =>\n    thrown === null || !thrown.isError\n        ? ''\n        : separateMessageFromStack(thrown.value.stack!).stack;\n\nexport default matchers;\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/* eslint-disable local/prefer-spread-eventually */\n\nimport * as matcherUtils from './matcher-utils';\nimport {\n    any,\n    anything,\n    arrayContaining,\n    arrayNotContaining,\n    objectContaining,\n    objectNotContaining,\n    stringContaining,\n    stringMatching,\n    stringNotContaining,\n    stringNotMatching,\n} from './asymmetricMatchers';\nimport extractExpectedAssertionsErrors from './extractExpectedAssertionsErrors';\nimport { equals } from './jasmineUtils';\nimport {\n    INTERNAL_MATCHER_FLAG,\n    getMatchers,\n    getState,\n    setMatchers,\n    setState,\n} from './jestMatchersObject';\nimport matchers from './matchers';\nimport spyMatchers from './spyMatchers';\nimport toThrowMatchers, {\n    createMatcher as createThrowMatcher,\n} from './toThrowMatchers';\nimport type {\n    AsyncExpectationResult,\n    Expect,\n    ExpectationResult,\n    MatcherState as JestMatcherState,\n    Matchers as MatcherInterface,\n    MatchersObject,\n    PromiseMatcherFn,\n    RawMatcherFn,\n    SyncExpectationResult,\n    ThrowingMatcherFn,\n} from './types';\nimport { iterableEquality, subsetEquality } from './utils';\n\nclass JestAssertionError extends Error {\n    matcherResult?: Omit<SyncExpectationResult, 'message'> & {\n        message: string;\n    };\n}\n\nconst isPromise = <T extends any>(obj: any): obj is PromiseLike<T> =>\n    !!obj &&\n    (typeof obj === 'object' || typeof obj === 'function') &&\n    typeof obj.then === 'function';\n\nconst createToThrowErrorMatchingSnapshotMatcher = function (\n    matcher: RawMatcherFn\n) {\n    return function (\n        this: JestMatcherState,\n        received: any,\n        testNameOrInlineSnapshot?: string\n    ) {\n        return matcher.apply(this, [received, testNameOrInlineSnapshot, true]);\n    };\n};\n\nconst getPromiseMatcher = (name: string, matcher: any) => {\n    if (name === 'toThrow' || name === 'toThrowError') {\n        return createThrowMatcher(name, true);\n    } else if (\n        name === 'toThrowErrorMatchingSnapshot' ||\n        name === 'toThrowErrorMatchingInlineSnapshot'\n    ) {\n        return createToThrowErrorMatchingSnapshotMatcher(matcher);\n    }\n\n    return null;\n};\n\nconst expect: any = (actual: any, ...rest: Array<any>) => {\n    if (rest.length !== 0) {\n        throw new Error('Expect takes at most one argument.');\n    }\n\n    const allMatchers = getMatchers();\n    const expectation: any = {\n        not: {},\n        rejects: { not: {} },\n        resolves: { not: {} },\n    };\n\n    const err = new JestAssertionError();\n\n    Object.keys(allMatchers).forEach((name) => {\n        const matcher = allMatchers[name];\n        const promiseMatcher = getPromiseMatcher(name, matcher) || matcher;\n        expectation[name] = makeThrowingMatcher(matcher, false, '', actual);\n        expectation.not[name] = makeThrowingMatcher(matcher, true, '', actual);\n\n        expectation.resolves[name] = makeResolveMatcher(\n            name,\n            promiseMatcher,\n            false,\n            actual,\n            err\n        );\n        expectation.resolves.not[name] = makeResolveMatcher(\n            name,\n            promiseMatcher,\n            true,\n            actual,\n            err\n        );\n\n        expectation.rejects[name] = makeRejectMatcher(\n            name,\n            promiseMatcher,\n            false,\n            actual,\n            err\n        );\n        expectation.rejects.not[name] = makeRejectMatcher(\n            name,\n            promiseMatcher,\n            true,\n            actual,\n            err\n        );\n    });\n\n    return expectation;\n};\n\nconst getMessage = (message?: () => string) =>\n    (message && message()) ||\n    matcherUtils.RECEIVED_COLOR('No message was specified for this matcher.');\n\nconst makeResolveMatcher =\n    (\n        matcherName: string,\n        matcher: RawMatcherFn,\n        isNot: boolean,\n        actual: Promise<any>,\n        outerErr: JestAssertionError\n    ): PromiseMatcherFn =>\n    (...args) => {\n        const options = {\n            isNot,\n            promise: 'resolves',\n        };\n\n        if (!isPromise(actual)) {\n            throw new JestAssertionError(\n                matcherUtils.matcherErrorMessage(\n                    matcherUtils.matcherHint(\n                        matcherName,\n                        undefined,\n                        '',\n                        options\n                    ),\n                    `${matcherUtils.RECEIVED_COLOR(\n                        'received'\n                    )} value must be a promise`,\n                    matcherUtils.printWithType(\n                        'Received',\n                        actual,\n                        matcherUtils.printReceived\n                    )\n                )\n            );\n        }\n\n        const innerErr = new JestAssertionError();\n\n        return actual.then(\n            (result) =>\n                makeThrowingMatcher(\n                    matcher,\n                    isNot,\n                    'resolves',\n                    result,\n                    innerErr\n                ).apply(null, args),\n            (reason) => {\n                outerErr.message =\n                    matcherUtils.matcherHint(\n                        matcherName,\n                        undefined,\n                        '',\n                        options\n                    ) +\n                    '\\n\\n' +\n                    `Received promise rejected instead of resolved\\n` +\n                    `Rejected to value: ${matcherUtils.printReceived(reason)}`;\n                return Promise.reject(outerErr);\n            }\n        );\n    };\n\nconst makeRejectMatcher =\n    (\n        matcherName: string,\n        matcher: RawMatcherFn,\n        isNot: boolean,\n        actual: Promise<any> | (() => Promise<any>),\n        outerErr: JestAssertionError\n    ): PromiseMatcherFn =>\n    (...args) => {\n        const options = {\n            isNot,\n            promise: 'rejects',\n        };\n\n        const actualWrapper: Promise<any> =\n            typeof actual === 'function' ? actual() : actual;\n\n        if (!isPromise(actualWrapper)) {\n            throw new JestAssertionError(\n                matcherUtils.matcherErrorMessage(\n                    matcherUtils.matcherHint(\n                        matcherName,\n                        undefined,\n                        '',\n                        options\n                    ),\n                    `${matcherUtils.RECEIVED_COLOR(\n                        'received'\n                    )} value must be a promise or a function returning a promise`,\n                    matcherUtils.printWithType(\n                        'Received',\n                        actual,\n                        matcherUtils.printReceived\n                    )\n                )\n            );\n        }\n\n        const innerErr = new JestAssertionError();\n\n        return actualWrapper.then(\n            (result) => {\n                outerErr.message =\n                    matcherUtils.matcherHint(\n                        matcherName,\n                        undefined,\n                        '',\n                        options\n                    ) +\n                    '\\n\\n' +\n                    `Received promise resolved instead of rejected\\n` +\n                    `Resolved to value: ${matcherUtils.printReceived(result)}`;\n                return Promise.reject(outerErr);\n            },\n            (reason) =>\n                makeThrowingMatcher(\n                    matcher,\n                    isNot,\n                    'rejects',\n                    reason,\n                    innerErr\n                ).apply(null, args)\n        );\n    };\n\nconst makeThrowingMatcher = (\n    matcher: RawMatcherFn,\n    isNot: boolean,\n    promise: string,\n    actual: any,\n    err?: JestAssertionError\n): ThrowingMatcherFn =>\n    function throwingMatcher(...args): any {\n        let throws = true;\n        const utils = { ...matcherUtils, iterableEquality, subsetEquality };\n\n        const matcherContext: JestMatcherState = {\n            // When throws is disabled, the matcher will not throw errors during test\n            // execution but instead add them to the global matcher state. If a\n            // matcher throws, test execution is normally stopped immediately. The\n            // snapshot matcher uses it because we want to log all snapshot\n            // failures in a test.\n            dontThrow: () => (throws = false),\n            ...getState(),\n            equals,\n            error: err,\n            isNot,\n            promise,\n            utils,\n        };\n\n        const processResult = (\n            result: SyncExpectationResult,\n            asyncError?: JestAssertionError\n        ) => {\n            _validateResult(result);\n\n            getState().assertionCalls++;\n\n            if ((result.pass && isNot) || (!result.pass && !isNot)) {\n                // XOR\n                const message = getMessage(result.message);\n                let error;\n\n                if (err) {\n                    error = err;\n                    error.message = message;\n                } else if (asyncError) {\n                    error = asyncError;\n                    error.message = message;\n                } else {\n                    error = new JestAssertionError(message);\n\n                    // Try to remove this function from the stack trace frame.\n                    // Guard for some environments (browsers) that do not support this feature.\n                    if (Error.captureStackTrace) {\n                        Error.captureStackTrace(error, throwingMatcher);\n                    }\n                }\n                // Passing the result of the matcher with the error so that a custom\n                // reporter could access the actual and expected objects of the result\n                // for example in order to display a custom visual diff\n                error.matcherResult = { ...result, message };\n\n                if (throws) {\n                    throw error;\n                } else {\n                    getState().suppressedErrors.push(error);\n                }\n            }\n        };\n\n        const handleError = (error: Error) => {\n            if (\n                matcher[INTERNAL_MATCHER_FLAG] === true &&\n                !(error instanceof JestAssertionError) &&\n                error.name !== 'PrettyFormatPluginError' &&\n                // Guard for some environments (browsers) that do not support this feature.\n                Error.captureStackTrace\n            ) {\n                // Try to remove this and deeper functions from the stack trace frame.\n                Error.captureStackTrace(error, throwingMatcher);\n            }\n            throw error;\n        };\n\n        let potentialResult: ExpectationResult;\n\n        try {\n            potentialResult =\n                matcher[INTERNAL_MATCHER_FLAG] === true\n                    ? matcher.call(matcherContext, actual, ...args)\n                    : // It's a trap specifically for inline snapshot to capture this name\n                      // in the stack trace, so that it can correctly get the custom matcher\n                      // function call.\n                      (function __EXTERNAL_MATCHER_TRAP__() {\n                          return matcher.call(matcherContext, actual, ...args);\n                      })();\n\n            if (isPromise(potentialResult)) {\n                const asyncResult = potentialResult as AsyncExpectationResult;\n                const asyncError = new JestAssertionError();\n                if (Error.captureStackTrace) {\n                    Error.captureStackTrace(asyncError, throwingMatcher);\n                }\n\n                return asyncResult\n                    .then((aResult) => processResult(aResult, asyncError))\n                    .catch(handleError);\n            } else {\n                const syncResult = potentialResult as SyncExpectationResult;\n\n                return processResult(syncResult);\n            }\n        } catch (error: any) {\n            return handleError(error);\n        }\n    };\n\nexpect.extend = <T extends JestMatcherState = JestMatcherState>(\n    matchers: MatchersObject<T>\n): void => setMatchers(matchers, false, expect);\n\nexpect.anything = anything;\nexpect.any = any;\n\nexpect.not = {\n    arrayContaining: arrayNotContaining,\n    objectContaining: objectNotContaining,\n    stringContaining: stringNotContaining,\n    stringMatching: stringNotMatching,\n};\n\nexpect.objectContaining = objectContaining;\nexpect.arrayContaining = arrayContaining;\nexpect.stringContaining = stringContaining;\nexpect.stringMatching = stringMatching;\n\nconst _validateResult = (result: any) => {\n    if (\n        typeof result !== 'object' ||\n        typeof result.pass !== 'boolean' ||\n        (result.message &&\n            typeof result.message !== 'string' &&\n            typeof result.message !== 'function')\n    ) {\n        throw new Error(\n            'Unexpected return from a matcher function.\\n' +\n                'Matcher functions should ' +\n                'return an object in the following format:\\n' +\n                '  {message?: string | function, pass: boolean}\\n' +\n                `'${matcherUtils.stringify(result)}' was returned`\n        );\n    }\n};\n\nfunction assertions(expected: number) {\n    const error = new Error();\n    if (Error.captureStackTrace) {\n        Error.captureStackTrace(error, assertions);\n    }\n\n    setState({\n        expectedAssertionsNumber: expected,\n        expectedAssertionsNumberError: error,\n    });\n}\nfunction hasAssertions(...args: Array<any>) {\n    const error = new Error();\n    if (Error.captureStackTrace) {\n        Error.captureStackTrace(error, hasAssertions);\n    }\n\n    matcherUtils.ensureNoExpected(args[0], '.hasAssertions');\n    setState({\n        isExpectingAssertions: true,\n        isExpectingAssertionsError: error,\n    });\n}\n\n// add default jest matchers\nsetMatchers(matchers, true, expect as Expect);\nsetMatchers(spyMatchers, true, expect as Expect);\nsetMatchers(toThrowMatchers, true, expect as Expect);\n\nexpect.addSnapshotSerializer = (() => void 0) as () => any;\nexpect.assertions = assertions;\nexpect.hasAssertions = hasAssertions;\nexpect.getState = getState;\nexpect.setState = setState;\nexpect.extractExpectedAssertionsErrors = extractExpectedAssertionsErrors;\n\nconst expectExport = expect as Expect;\n\ndeclare namespace expectExport {\n    export type MatcherState = JestMatcherState;\n    export interface Matchers<R, T = unknown> extends MatcherInterface<R, T> {}\n}\n\nexport default expectExport;\n","import {\n    AuxGlobalContext,\n    AsyncTask,\n    BotTimer,\n    TimeoutOrIntervalTimer,\n    DEBUG_STRING,\n    debugStringifyFunction,\n} from './AuxGlobalContext';\nimport {\n    hasValue,\n    trimTag,\n    isBot,\n    BotTags,\n    Bot,\n    BOT_SPACE_TAG,\n    toast as toastMessage,\n    tip as tipMessage,\n    hideTips as hideTipMessages,\n    showJoinCode as calcShowJoinCode,\n    requestFullscreen,\n    exitFullscreen,\n    html as htmlMessage,\n    hideHtml as hideHtmlMessage,\n    setClipboard as calcSetClipboard,\n    tweenTo as calcTweenTo,\n    showChat as calcShowChat,\n    hideChat as calcHideChat,\n    ShowChatOptions,\n    runScript,\n    getMediaPermission as calcGetMediaPermission,\n    getAverageFrameRate as calcGetAverageFrameRate,\n    enableAR as calcEnableAR,\n    disableAR as calcDisableAR,\n    enableVR as calcEnableVR,\n    disableVR as calcDisableVR,\n    arSupported as calcARSupported,\n    vrSupported as calcVRSupported,\n    showUploadAuxFile as calcShowUploadAuxFile,\n    openQRCodeScanner as calcOpenQRCodeScanner,\n    showQRCode as calcShowQRCode,\n    openBarcodeScanner as calcOpenBarcodeScanner,\n    showBarcode as calcShowBarcode,\n    importAUX as calcImportAUX,\n    showInputForTag as calcShowInputForTag,\n    showInput as calcShowInput,\n    replaceDragBot as calcReplaceDragBot,\n    goToDimension as calcGoToDimension,\n    goToURL as calcGoToURL,\n    openURL as calcOpenURL,\n    checkout as calcCheckout,\n    playSound as calcPlaySound,\n    bufferSound as calcBufferSound,\n    cancelSound as calcCancelSound,\n    setupServer as calcSetupServer,\n    shell as calcShell,\n    backupToGithub as calcBackupToGithub,\n    backupAsDownload as calcBackupAsDownload,\n    finishCheckout as calcFinishCheckout,\n    markHistory as calcMarkHistory,\n    browseHistory as calcBrowseHistory,\n    restoreHistoryMark as calcRestoreHistoryMark,\n    loadFile as calcLoadFile,\n    saveFile as calcSaveFile,\n    reject as calcReject,\n    localFormAnimation as calcLocalFormAnimation,\n    webhook as calcWebhook,\n    superShout as calcSuperShout,\n    share as calcShare,\n    registerPrefix as calcRegisterPrefix,\n    createCertificate as calcCreateCertificate,\n    signTag as calcSignTag,\n    revokeCertificate as calcRevokeCertificate,\n    localPositionTween as calcLocalPositionTween,\n    localRotationTween as calcLocalRotationTween,\n    animateTag as calcAnimateTag,\n    showUploadFiles as calcShowUploadFiles,\n    BotAction,\n    download,\n    BotsState,\n    CameraType,\n    BarcodeFormat,\n    loadSimulation,\n    unloadSimulation,\n    getUploadState,\n    addState,\n    PortalType,\n    getPortalTag,\n    ShowInputOptions,\n    KNOWN_PORTALS,\n    openConsole,\n    StartCheckoutOptions,\n    tagsOnBot,\n    getOriginalObject,\n    getBotSpace,\n    trimEvent,\n    CREATE_ACTION_NAME,\n    CREATE_ANY_ACTION_NAME,\n    DESTROY_ACTION_NAME,\n    LocalFormAnimationAction,\n    ORIGINAL_OBJECT,\n    AsyncActions,\n    ShareOptions,\n    unlockSpace,\n    getRemoteCount,\n    getServers,\n    getRemotes,\n    listInstUpdates as calcListInstUpdates,\n    getInstStateFromUpdates as calcGetInstStateFromUpdates,\n    action,\n    getServerStatuses,\n    setSpacePassword,\n    rpioInitPin,\n    rpioExitPin,\n    rpioOpenPin,\n    rpioModePin,\n    rpioReadPin,\n    rpioReadSequencePin,\n    rpioWritePin,\n    rpioWriteSequencePin,\n    rpioReadpadPin,\n    rpioWritepadPin,\n    rpioPudPin,\n    rpioPollPin,\n    rpioClosePin,\n    rpioI2CBeginPin,\n    rpioI2CSetSlaveAddressPin,\n    rpioI2CSetBaudRatePin,\n    rpioI2CSetClockDividerPin,\n    rpioI2CReadPin,\n    rpioI2CWritePin,\n    // rpioI2CReadRegisterRestartPin,\n    // rpioI2CWriteReadRestartPin,\n    rpioI2CEndPin,\n    rpioPWMSetClockDividerPin,\n    rpioPWMSetRangePin,\n    rpioPWMSetDataPin,\n    rpioSPIBeginPin,\n    rpioSPIChipSelectPin,\n    rpioSPISetCSPolarityPin,\n    rpioSPISetClockDividerPin,\n    rpioSPISetDataModePin,\n    rpioSPITransferPin,\n    rpioSPIWritePin,\n    rpioSPIEndPin,\n    serialConnectPin,\n    serialOpenPin,\n    serialStreamPin,\n    serialUpdatePin,\n    serialWritePin,\n    serialReadPin,\n    serialClosePin,\n    serialFlushPin,\n    serialDrainPin,\n    serialPausePin,\n    serialResumePin,\n    Easing,\n    LocalPositionTweenAction,\n    LocalRotationTweenAction,\n    BotAnchorPoint,\n    calculateAnchorPoint,\n    calculateAnchorPointOffset,\n    getBotPosition as calcGetBotPosition,\n    getBotRotation as calcGetBotRotation,\n    RuntimeBot,\n    isRuntimeBot,\n    SET_TAG_MASK_SYMBOL,\n    CLEAR_TAG_MASKS_SYMBOL,\n    getBotScale,\n    EDIT_TAG_SYMBOL,\n    BotSpace,\n    EDIT_TAG_MASK_SYMBOL,\n    AnimateTagOptions,\n    EaseType,\n    RegisterPrefixOptions,\n    OpenCircleWipeOptions,\n    circleWipe,\n    addDropSnap as calcAddDropSnap,\n    addDropGrid as calcAddDropGrid,\n    SuperShoutAction,\n    ShowToastAction,\n    ShowJoinCodeAction,\n    RequestFullscreenAction,\n    ExitFullscreenAction,\n    ShowHtmlAction,\n    HideHtmlAction,\n    SetClipboardAction,\n    FocusOnBotAction,\n    ShowChatBarAction,\n    EnableARAction,\n    EnableVRAction,\n    DownloadAction,\n    ShowUploadAuxFileAction,\n    OpenQRCodeScannerAction,\n    ShowQRCodeAction,\n    OpenBarcodeScannerAction,\n    ShowBarcodeAction,\n    LoadServerAction,\n    UnloadServerAction,\n    ImportAUXAction,\n    ReplaceDragBotAction,\n    ShowInputForTagAction,\n    GoToDimensionAction,\n    GoToURLAction,\n    OpenURLAction,\n    OpenConsoleAction,\n    StartCheckoutAction,\n    FinishCheckoutAction,\n    ShowUploadFilesAction,\n    ApplyStateAction,\n    RejectAction,\n    FocusOnOptions,\n    animateToPosition,\n    AsyncAction,\n    beginAudioRecording as calcBeginAudioRecording,\n    endAudioRecording as calcEndAudioRecording,\n    beginRecording as calcBeginRecording,\n    endRecording as calcEndRecording,\n    speakText as calcSpeakText,\n    getVoices as calcGetVoices,\n    getGeolocation as calcGetGeolocation,\n    cancelAnimation,\n    SnapTarget,\n    AddDropSnapTargetsAction,\n    RecordingOptions,\n    Recording,\n    SyntheticVoice,\n    SpeakTextOptions,\n    EnablePOVAction,\n    disablePOV,\n    enablePOV,\n    EnableCustomDraggingAction,\n    enableCustomDragging as calcEnableCustomDragging,\n    MINI_PORTAL,\n    registerCustomApp,\n    setAppOutput,\n    SetAppOutputAction,\n    unregisterCustomApp,\n    requestAuthData as calcRequestAuthData,\n    AuthData,\n    createBot,\n    defineGlobalBot as calcDefineGlobalBot,\n    TEMPORARY_BOT_PARTITION_ID,\n    Record,\n    RecordReference,\n    convertToString,\n    GET_TAG_MASKS_SYMBOL,\n    PartialBotsState,\n    PartialBot,\n    isBotLink,\n    parseBotLink,\n    createBotLink,\n    ParsedBotLink,\n    convertGeolocationToWhat3Words as calcConvertGeolocationToWhat3Words,\n    ConvertGeolocationToWhat3WordsOptions,\n    getPublicRecordKey as calcGetPublicRecordKey,\n    recordData as calcRecordData,\n    getRecordData,\n    eraseRecordData,\n    recordFile as calcRecordFile,\n    BeginAudioRecordingAction,\n    eraseFile as calcEraseFile,\n    meetCommand as calcMeetCommand,\n    MeetCommandAction,\n    meetFunction as calcMeetFunction,\n    listDataRecord,\n    recordEvent as calcRecordEvent,\n    getEventCount as calcGetEventCount,\n    MediaPermssionOptions,\n    MediaPermissionAction,\n    openImageClassifier as calcOpenImageClassifier,\n    OpenImageClassifierAction,\n    ImageClassifierOptions,\n    isBotDate,\n    DATE_TAG_PREFIX,\n    parseBotDate,\n    SnapGrid,\n    AddDropGridTargetsAction,\n    DataRecordOptions,\n    RecordActionOptions,\n    realNumberOrDefault,\n    joinRoom as calcJoinRoom,\n    leaveRoom as calcLeaveRoom,\n    setRoomOptions as calcSetRoomOptions,\n    getRoomOptions as calcGetRoomOptions,\n    getRoomTrackOptions as calcGetRoomTrackOptions,\n    setRoomTrackOptions as calcSetRoomTrackOptions,\n    getRoomRemoteOptions as calcGetRoomRemoteOptions,\n    JoinRoomActionOptions,\n    RoomOptions,\n    RoomTrackOptions,\n    SetRoomTrackOptions,\n    RoomRemoteOptions,\n    InstUpdate,\n    raycastFromCamera as calcRaycastFromCamera,\n    raycastInPortal as calcRaycastInPortal,\n    calculateRayFromCamera as calcCalculateRayFromCamera,\n    bufferFormAddressGltf,\n    StartFormAnimationOptions,\n    startFormAnimation as calcStartFormAnimation,\n    stopFormAnimation as calcStopFormAnimation,\n    listFormAnimations as calcListFormAnimations,\n    StopFormAnimationOptions,\n    FormAnimationData,\n    calculateStringTagValue,\n} from '../bots';\nimport { sortBy, every, cloneDeep, union, isEqual, flatMap } from 'lodash';\nimport {\n    remote as calcRemote,\n    DeviceSelector,\n    RemoteAction,\n} from '@casual-simulation/causal-trees';\nimport { RanOutOfEnergyError } from './AuxResults';\nimport '../polyfill/Array.first.polyfill';\nimport '../polyfill/Array.last.polyfill';\nimport {\n    convertToCopiableValue,\n    embedBase64InPdf,\n    formatAuthToken,\n    getEasing,\n    getEmbeddedBase64FromPdf,\n    toHexString as utilToHexString,\n    fromHexString as utilFromHexString,\n} from './Utils';\nimport {\n    sha256 as hashSha256,\n    sha512 as hashSha512,\n    hmac as calcHmac,\n    sha1 as hashSha1,\n} from 'hash.js';\nimport stableStringify from '@casual-simulation/fast-json-stable-stringify';\nimport {\n    encrypt as realEncrypt,\n    decrypt as realDecrypt,\n    keypair as realKeypair,\n    sign as realSign,\n    verify as realVerify,\n    asymmetricKeypair as realAsymmetricKeypair,\n    asymmetricEncrypt as realAsymmetricEncrypt,\n    asymmetricDecrypt as realAsymmetricDecrypt,\n    isAsymmetricKeypair,\n    isAsymmetricEncrypted,\n    isEncrypted,\n} from '@casual-simulation/crypto';\nimport { tagValueHash } from '../aux-format-2/AuxOpTypes';\nimport { apply, del, insert, isTagEdit, preserve } from '../aux-format-2';\nimport {\n    Euler,\n    Vector3 as ThreeVector3,\n    Plane,\n    Ray,\n    RGBA_ASTC_10x10_Format,\n} from '@casual-simulation/three';\nimport mime from 'mime';\nimport TWEEN from '@tweenjs/tween.js';\nimport './PerformanceNowPolyfill';\nimport './BlobPolyfill';\nimport { AuxDevice } from './AuxDevice';\nimport { AuxVersion } from './AuxVersion';\nimport { Vector3, Vector2, Quaternion, Rotation } from '../math';\nimport { Fragment, h } from 'preact';\nimport htm from 'htm';\nimport { fromByteArray, toByteArray } from 'base64-js';\nimport expect, { iterableEquality, Tester } from '@casual-simulation/expect';\nimport {\n    CreatePublicRecordKeyResult,\n    GetDataResult,\n    parseRecordKey,\n    RecordDataResult,\n    RecordFileFailure,\n    RecordFileResult,\n    isRecordKey as calcIsRecordKey,\n    EraseDataResult,\n    EraseFileResult,\n    ListDataResult,\n    AddCountResult,\n    GetCountResult,\n} from '@casual-simulation/aux-records';\nimport SeedRandom from 'seedrandom';\nimport { DateTime } from 'luxon';\nimport * as hooks from 'preact/hooks';\nimport { render } from 'preact';\n\nconst _html: HtmlFunction = htm.bind(h) as any;\n\nconst html: HtmlFunction = ((...args: any[]) => {\n    return _html(...args);\n}) as any;\n(<any>html).h = h;\n(<any>html).f = Fragment;\n\n/**\n * Defines an interface for a function that provides HTML VDOM capabilities to bots.\n */\nexport interface HtmlFunction {\n    (...args: any[]): any;\n    h: (name: string | Function, props: any, ...children: any[]) => any;\n    f: any;\n}\n\n/**\n * Defines an interface for a library of functions and values that can be used by formulas and listeners.\n */\nexport interface AuxLibrary {\n    /**\n     * The functions that are part of the general API.\n     */\n    api: {\n        whisper(\n            bot: (Bot | string)[] | Bot | string,\n            eventName: string,\n            arg?: any\n        ): any[];\n        shout(name: string, arg?: any): any[];\n        __energyCheck(): void;\n        [key: string]: any;\n    };\n\n    /**\n     * The functions that are part of the bot-specific API.\n     */\n    tagSpecificApi: {\n        [key: string]: (options: TagSpecificApiOptions) => any;\n    };\n    typeDefinitions?: string;\n}\n\ntype TagFilter =\n    | ((value: any) => boolean)\n    | string\n    | number\n    | boolean\n    | null\n    | undefined;\n\n/**\n * Defines a type that represents a mod.\n * That is, a set of tags that can be applied to another bot.\n */\ntype Mod = BotTags | Bot;\n\n/**\n * An interface that is used to say which user/device/session an event should be sent to.\n */\nexport interface SessionSelector {\n    username?: string;\n    device?: string;\n    session?: string;\n    broadcast?: boolean;\n}\n\n/**\n * Defines an interface for options that complete payment for a product.\n */\ninterface FinishCheckoutOptions {\n    /**\n     * The secret API key that should be used to checkout with stripe.\n     */\n    secretKey: string;\n\n    /**\n     * The token that authorized payment from the user.\n     */\n    token: string;\n\n    /**\n     * The amount that should be charged in the currency's smallest unit. (cents, etc.)\n     */\n    amount: number;\n\n    /**\n     * The three character currency code.\n     */\n    currency: string;\n\n    /**\n     * The description for the charge.\n     */\n    description: string;\n\n    /**\n     * Any extra info that should be included in the onPaymentSuccessful() or onPaymentFailed() events for this checkout.\n     */\n    extra?: any;\n}\n\n/**\n * Defines an interface for options that mark a specific time in history.\n */\ninterface MarkHistoryOptions {\n    /**\n     * The message that the mark should contain.\n     */\n    message: string;\n}\n\n/**\n * Options for loading a file.\n */\ninterface LoadFileOptions {\n    /**\n     * The shout that should be made when the request finishes.\n     */\n    callbackShout?: string;\n}\n\n/**\n * Options for saving a file.\n */\ninterface SaveFileOptions {\n    /**\n     * The shout that should be made when the request finishes.\n     */\n    callbackShout?: string;\n\n    /**\n     * Whether to overwrite an existing file.\n     */\n    overwriteExistingFile?: boolean;\n}\n\n/**\n * The status codes that should be used to retry web requests.\n */\nconst DEFUALT_RETRY_STATUS_CODES: number[] = [\n    408, // Request Timeout\n    429, // Too Many Requests\n    500, // Internal Server Error\n    502, // Bad Gateway\n    503, // Service Unavailable\n    504, // Gateway Timeout\n    0, // Network Failure / CORS\n];\n\n/**\n * The time to wait until another web request retry unless specified by the webhook options.\n * Defaults to 3 seconds.\n */\nconst DEFAULT_RETRY_AFTER_MS = 3 * 1000;\n\n/**\n * The maximum amount of time to wait before giving up on a set of requests.\n * Defaults to 1 minute.\n */\nconst MAX_RETRY_AFTER_MS = 60 * 60 * 1000;\n\n/**\n * The maximum number of times that a web request should be retried for.\n */\nconst MAX_RETRY_COUNT = 10;\n\n/**\n * Defines a set of options for a webhook.\n */\nexport interface WebhookOptions {\n    /**\n     * The HTTP Method that the request should use.\n     */\n    method?: string;\n\n    /**\n     * The URL that the request should be made to.\n     */\n    url?: string;\n\n    /**\n     * The headers to include in the request.\n     */\n    headers?: {\n        [key: string]: string;\n    };\n\n    /**\n     * The data to send with the request.\n     */\n    data?: any;\n\n    /**\n     * The shout that should be made when the request finishes.\n     */\n    responseShout?: string;\n\n    /**\n     * The number of retries that should be attempted for the webhook.\n     */\n    retryCount?: number;\n\n    /**\n     * The HTTP response status codes that should allow the web request to be retried.\n     */\n    retryStatusCodes?: number[];\n\n    /**\n     * The number of miliseconds to wait between retry requests.\n     */\n    retryAfterMs?: number;\n}\n\n/**\n * Defines a set of options for animateTag().\n */\nexport interface AnimateTagFunctionOptions {\n    /**\n     * The value that should be animated from.\n     * If not specified then the current tag value will be used.\n     */\n    fromValue?: any;\n\n    /**\n     * The value that should be animated to.\n     */\n    toValue: any;\n\n    /**\n     * The duration of the animation in seconds.\n     */\n    duration: number;\n\n    /**\n     * The time that the animation should start.\n     * Should be the number of miliseconds since January 1st 1970 UTC-0. (e.g. os.localTime or os.agreedUponTime).\n     */\n    startTime?: number;\n\n    /**\n     * The type of easing to use.\n     * If not specified then \"linear\" \"inout\" will be used.\n     *\n     * Can also be a custom function that takes a single parameter and returns a number.\n     * The paramater will be a number between 0 and 1 indicating the progress through the tween.\n     */\n    easing?: EaseType | Easing | ((progress: number) => number);\n\n    /**\n     * The space that the tag should be animated in.\n     * If not specified then \"tempLocal\" will be used.\n     * If false, then the bot will be edited instead of using tag masks.\n     */\n    tagMaskSpace?: BotSpace | false;\n}\n\nexport interface BotFilterFunction {\n    (bot: Bot): boolean;\n    sort?: (bot: Bot) => any;\n    [DEBUG_STRING]?: string;\n}\n\nexport interface RecordFilter {\n    recordFilter: true;\n    [DEBUG_STRING]?: string;\n}\n\nexport interface AuthIdRecordFilter extends RecordFilter {\n    authID: string;\n}\n\nexport interface SpaceFilter extends BotFilterFunction, RecordFilter {\n    space: string;\n    toJSON: () => RecordFilter;\n}\n\nexport interface AddressRecordFilter extends RecordFilter {\n    address: string;\n}\n\nexport interface IDRecordFilter extends BotFilterFunction, RecordFilter {\n    id: string;\n    toJSON: () => RecordFilter;\n}\n\nexport type RecordFilters =\n    | AuthIdRecordFilter\n    | SpaceFilter\n    | AddressRecordFilter\n    | IDRecordFilter\n    | RecordReference;\n\n/**\n * Defines a set of options for a tween.\n */\nexport interface TweenOptions {\n    /**\n     * The easing for the tween.\n     */\n    easing?: Easing;\n\n    /**\n     * The duration of the tween in seconds.\n     */\n    duration?: number;\n}\n\n/**\n * Defines an interface that contains performance statistics about a inst.\n */\nexport interface PerformanceStats {\n    /**\n     * The number of bots in the inst.\n     */\n    numberOfBots: number;\n\n    /**\n     * A list of listen tags and the amount of time spent executing them (in miliseconds).\n     * Useful to guage if a listen tag is causing the inst to slow down.\n     */\n    shoutTimes: {\n        tag: string;\n        timeMs: number;\n    }[];\n\n    /**\n     * The total number of active setTimeout() and setInterval() timers that are active.\n     */\n    numberOfActiveTimers: number;\n\n    loadTimes: {\n        [key: string]: number;\n    };\n}\n\n/**\n * Options needed for the Bot-specific API.\n */\nexport interface TagSpecificApiOptions {\n    /**\n     * The Bot that the API is for.\n     */\n    bot: Bot;\n    /**\n     * The tag that the API is for.\n     */\n    tag: string;\n\n    /**\n     * The bot that is set as the creator of the current bot.\n     */\n    creator: RuntimeBot;\n\n    /**\n     * The bot that is set as the config of the current bot.\n     */\n    config: RuntimeBot;\n}\n\n/**\n * Defines an interface that represents a set of records that were retrieved.\n */\nexport interface GetRecordsResult {\n    /**\n     * The set of records that were retrieved.\n     */\n    records: Record[];\n\n    /**\n     * The total number of records that the query would have returned.\n     */\n    totalCount: number;\n\n    /**\n     * Whether there are more records available to retrieve for the query.\n     */\n    hasMoreRecords: boolean;\n\n    /**\n     * Gets the set page of records.\n     */\n    getMoreRecords(): Promise<GetRecordsResult>;\n}\n\n/**\n * Defines an interface that contains options for an aux debugger.\n */\nexport interface AuxDebuggerOptions {\n    /**\n     * Whether to use \"real\" UUIDs instead of predictable ones.\n     */\n    useRealUUIDs: boolean;\n\n    /**\n     * Whether to allow scripts to be asynchronous.\n     * If false, then all scripts will be forced to be synchronous.\n     * Defaults to false.\n     */\n    allowAsynchronousScripts: boolean;\n\n    /**\n     * The data that the configBot should be created from.\n     * Can be a mod or another bot.\n     */\n    configBot: Bot | BotTags;\n}\n\n/**\n * Defines an interface for a random number generator.\n */\nexport interface PseudoRandomNumberGenerator {\n    /**\n     * The seed used for this random number generator.\n     * If null then an unpredictable seed was used.\n     */\n    seed: number | string | null;\n\n    /**\n     * Generates a random number between 0 and 1.\n     */\n    random(): number;\n\n    /**\n     * Generates a random decimal number between the given min and max values.\n     * @param min The minimum output number.\n     * @param max The maximum output number.\n     */\n    random(min?: number, max?: number): number;\n\n    /**\n     * Generates a random integer between the given min and max values.\n     * @param min The minimum output number.\n     * @param max The maximum output number.\n     */\n    randomInt(min: number, max: number): number;\n}\n\nexport interface MaskableFunction {\n    mask(...args: any[]): MaskedFunction;\n}\n\nexport interface MaskedFunction {\n    returns(value: any): void;\n}\n\nexport interface WebhookInterface extends MaskableFunction {\n    (options: WebhookOptions): void;\n    post: ((\n        url: string,\n        data?: any,\n        options?: WebhookOptions\n    ) => Promise<any>) &\n        MaskableFunction;\n}\n\n/**\n * Defines an interface that represents the result of a webhook.\n */\nexport interface WebhookResult {\n    /**\n     * The data that was returned from the webhook.\n     */\n    data: any;\n\n    /**\n     * The HTTP Status Code that was returned from the webhook.\n     * See https://developer.mozilla.org/en-US/docs/Web/HTTP/Status for more information.\n     */\n    status: number;\n\n    /**\n     * The HTTP Headers that were included in the response.\n     * See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers for more information.\n     */\n    headers: {\n        [name: string]: string;\n    };\n}\n\nexport type RecordFileApiResult = RecordFileApiSuccess | RecordFileApiFailure;\n\nexport interface RecordFileApiSuccess {\n    success: true;\n\n    /**\n     * The URL that the file can be accessed at.\n     */\n    url: string;\n\n    /**\n     * The SHA-256 hash of the file.\n     * When downloading the URL, the resulting data is guaranteed to have a SHA-256 hash that matches this value.\n     */\n    sha256Hash: string;\n}\n\nexport interface RecordFileApiFailure {\n    success: false;\n    errorCode:\n        | RecordFileFailure['errorCode']\n        | 'file_already_exists'\n        | 'invalid_file_data';\n    errorMessage: string;\n}\n\nexport interface SnapGridTarget {\n    /**\n     * The 3D position that the grid should appear at.\n     */\n    position?: { x: number; y: number; z: number };\n\n    /**\n     * The 3D rotation that the grid should appear at.\n     */\n    rotation?: { x: number; y: number; z: number; w?: number };\n\n    /**\n     * The bot that defines the portal that the grid should exist in.\n     * If null, then this defaults to the configBot.\n     */\n    portalBot?: Bot | string;\n\n    /**\n     * The tag that the portal uses to determine which dimension to show. Defaults to formAddress.\n     */\n    portalTag?: string;\n\n    /**\n     * The bounds of the grid.\n     * Defaults to 10 x 10.\n     */\n    bounds?: { x: number; y: number };\n\n    /**\n     * The priority that this grid should be evaluated in over other grids.\n     * Higher priorities will be evaluated before lower priorities.\n     */\n    priority?: number;\n\n    /**\n     * Whether to visualize the grid while a bot is being dragged.\n     * Defaults to false.\n     */\n    showGrid?: boolean;\n}\n\nexport type JoinRoomResult = JoinRoomSuccess | JoinRoomFailure;\n\nexport interface JoinRoomSuccess {\n    success: true;\n    roomName: string;\n}\n\nexport interface JoinRoomFailure {\n    success: false;\n    roomName: string;\n    errorCode: string;\n    errorMessage: string;\n}\n\nexport type LeaveRoomResult = LeaveRoomSuccess | LeaveRoomFailure;\n\nexport interface LeaveRoomSuccess {\n    success: true;\n    roomName: string;\n}\n\nexport interface LeaveRoomFailure {\n    success: false;\n    roomName: string;\n    errorCode: string;\n    errorMessage: string;\n}\n\nexport type SetRoomOptionsResult =\n    | SetRoomOptionsSuccess\n    | SetRoomOptionsFailure;\n\nexport interface SetRoomOptionsSuccess {\n    success: true;\n    roomName: true;\n}\n\nexport interface SetRoomOptionsFailure {\n    success: false;\n    roomName: string;\n    errorCode: string;\n    errorMessage: string;\n}\n\nexport type GetRoomOptionsResult =\n    | GetRoomOptionsSuccess\n    | GetRoomOptionsFailure;\n\nexport interface GetRoomOptionsSuccess {\n    success: true;\n    roomName: string;\n    options: RoomOptions;\n}\n\nexport interface GetRoomOptionsFailure {\n    success: false;\n    errorCode: string;\n    errorMessage: string;\n}\n\nexport type GetRoomTrackOptionsResult =\n    | GetRoomTrackOptionsSuccess\n    | GetRoomTrackOptionsFailure;\n\nexport interface GetRoomTrackOptionsSuccess {\n    success: true;\n    roomName: string;\n    address: string;\n    options: RoomTrackOptions;\n}\n\nexport interface GetRoomTrackOptionsFailure {\n    success: false;\n    errorCode: string;\n    errorMessage: string;\n    roomName: string;\n    address: string;\n}\n\nexport type SetRoomTrackOptionsResult =\n    | SetRoomTrackOptionsSuccess\n    | SetRoomTrackOptionsFailure;\n\nexport interface SetRoomTrackOptionsSuccess {\n    success: true;\n    roomName: string;\n    address: string;\n    options: RoomTrackOptions;\n}\n\nexport interface SetRoomTrackOptionsFailure {\n    success: false;\n    errorCode: string;\n    errorMessage: string;\n    roomName: string;\n    address: string;\n}\n\nexport type GetRoomRemoteOptionsResult =\n    | GetRoomRemoteOptionsSuccess\n    | GetRoomRemoteOptionsFailure;\n\nexport interface GetRoomRemoteOptionsSuccess {\n    success: true;\n    roomName: string;\n    remoteId: string;\n    options: RoomRemoteOptions;\n}\n\nexport interface GetRoomRemoteOptionsFailure {\n    success: false;\n    errorCode: string;\n    errorMessage: string;\n    roomName: string;\n    remoteId: string;\n}\n\nconst botsEquality: Tester = function (first: unknown, second: unknown) {\n    if (isRuntimeBot(first) && isRuntimeBot(second)) {\n        expect(getBotSnapshot(first)).toEqual(getBotSnapshot(second));\n        return true;\n    }\n    return undefined;\n};\n\nexpect.extend({\n    toEqual(received: unknown, expected: unknown) {\n        // Copied from https://github.com/facebook/jest/blob/7bb400c373a6f90ba956dd25fe24ee4d4788f41e/packages/expect/src/matchers.ts#L580\n        // Added the testBots matcher to make testing against bots easier.\n        const matcherName = 'toEqual';\n        const options = {\n            comment: 'deep equality',\n            isNot: this.isNot,\n            promise: this.promise,\n        };\n\n        const pass = this.equals(received, expected, [\n            botsEquality,\n            iterableEquality,\n        ]);\n\n        const message = pass\n            ? () =>\n                  this.utils.matcherHint(\n                      matcherName,\n                      undefined,\n                      undefined,\n                      options\n                  ) +\n                  '\\n\\n' +\n                  `Expected: not ${this.utils.printExpected(expected)}\\n` +\n                  (this.utils.stringify(expected) !==\n                  this.utils.stringify(received)\n                      ? `Received:     ${this.utils.printReceived(received)}`\n                      : '')\n            : () =>\n                  this.utils.matcherHint(\n                      matcherName,\n                      undefined,\n                      undefined,\n                      options\n                  ) +\n                  '\\n\\n' +\n                  this.utils.printDiffOrStringify(\n                      expected,\n                      received,\n                      'Expected',\n                      'Received',\n                      this.expand !== false\n                  );\n\n        // Passing the actual and expected objects so that a custom reporter\n        // could access them, for example in order to display a custom visual diff,\n        // or create a different error message\n        return { actual: received, expected, message, name: matcherName, pass };\n    },\n});\n\nfunction getBotSnapshot(bot: Bot) {\n    let b = {\n        id: bot.id,\n        space: bot.space,\n        tags:\n            typeof bot.tags.toJSON === 'function'\n                ? bot.tags.toJSON()\n                : bot.tags,\n    } as Bot;\n\n    let masks = isRuntimeBot(bot)\n        ? bot[GET_TAG_MASKS_SYMBOL]()\n        : cloneDeep(bot.masks ?? {});\n    if (Object.keys(masks).length > 0) {\n        b.masks = masks;\n    }\n    return b;\n}\n\n/**\n * Defines an interface that represents the set of additional options that can be provided when recording a file.\n */\nexport interface RecordFileOptions {\n    /**\n     * The description of the file.\n     */\n    description?: string;\n\n    /**\n     * The MIME type of the file.\n     * See https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types for more information.\n     */\n    mimeType?: string;\n}\n\n/**\n * Defines an interface that represents the result of a raycast operation.\n */\nexport interface RaycastResult {\n    /**\n     * The list of intersections.\n     */\n    botIntersections: BotIntersection[];\n\n    /**\n     * The ray that the operation sent.\n     */\n    ray: RaycastRay;\n}\n\n/**\n * Defines an interface that represents the intersection of a bot and ray.\n */\nexport interface BotIntersection {\n    /**\n     * The bot that was intersected.\n     */\n    bot: Bot;\n\n    /**\n     * The distance from the origin of the ray that the intersection ocurred at.\n     */\n    distance: number;\n\n    /**\n     * The point that the intersection ocurred at.\n     */\n    point: Vector3;\n\n    /**\n     * The normal that the intersection ocurred at.\n     */\n    normal: Vector3;\n\n    /**\n     * The face that the intersection hit.\n     */\n    face: string;\n\n    /**\n     * The UV coordinates that the intersection ocurred at.\n     */\n    uv: Vector2;\n\n    /**\n     * The portal that the bot is in.\n     */\n    portal: string;\n\n    /**\n     * The dimension that the bot is in.\n     */\n    dimension: string;\n}\n\n/**\n * Defines an interface that represents a ray.\n */\nexport interface RaycastRay {\n    /**\n     * The origin of the ray.\n     */\n    origin: Vector3;\n\n    /**\n     * The direction that the ray travels in.\n     */\n    direction: Vector3;\n}\n\nconst DEAD_RECKONING_OFFSET = 50;\n\nconst DEG_TO_RAD = Math.PI / 180;\nconst RAD_TO_DEG = 180 / Math.PI;\n\n/**\n * Creates a library that includes the default functions and APIs.\n * @param context The global context that should be used.\n */\nexport function createDefaultLibrary(context: AuxGlobalContext) {\n    // TODO: Remove deprecated functions\n    webhook.post = function (\n        url: string,\n        data?: any,\n        options?: WebhookOptions\n    ) {\n        return webhook({\n            ...options,\n            method: 'POST',\n            url: url,\n            data: data,\n        });\n    };\n\n    const webhookFunc = makeMockableFunction(webhook, 'webhook');\n    webhookFunc.post = makeMockableFunction(webhook.post, 'webhook.post');\n\n    const shoutImpl: {\n        (name: string, arg?: any): any[];\n        [name: string]: (arg?: any) => any[];\n    } = shout as any;\n\n    const shoutProxy = new Proxy(shoutImpl, {\n        get(target, name: string, reciever) {\n            return (arg?: any) => {\n                return shout(name, arg);\n            };\n        },\n    });\n\n    return {\n        api: {\n            getBots,\n            getBot,\n            getBotTagValues,\n            getMod,\n            getBotPosition,\n            getBotRotation,\n            getID,\n            getJSON,\n            getFormattedJSON,\n            getSnapshot,\n            diffSnapshots,\n            applyDiffToSnapshot,\n\n            getTag,\n            setTag,\n            setTagMask,\n            clearTagMasks,\n            insertTagText,\n            insertTagMaskText,\n            deleteTagText,\n            deleteTagMaskText,\n            removeTags,\n            renameTag,\n            applyMod,\n            subtractMods,\n\n            destroy,\n            changeState,\n            getLink: createBotLinkApi,\n            getBotLinks,\n            updateBotLinks,\n\n            getDateTime,\n            DateTime,\n\n            Vector2,\n            Vector3,\n            Quaternion,\n            Rotation,\n\n            superShout,\n            priorityShout,\n            shout: shoutProxy,\n            whisper,\n\n            byTag,\n            byID,\n            byMod,\n            inDimension,\n            atPosition,\n            inStack,\n            neighboring,\n            bySpace,\n            byCreator,\n            either,\n            not,\n\n            remote,\n            sendRemoteData: remoteWhisper,\n            remoteWhisper,\n            remoteShout,\n            uuid,\n            animateTag,\n            clearAnimations,\n\n            // TODO: Remove deprecated functions\n            webhook: <WebhookInterface>(<any>webhookFunc),\n            sleep,\n\n            __energyCheck,\n            clearTimeout,\n            clearInterval,\n            clearWatchBot,\n            clearWatchPortal,\n            assert,\n            assertEqual,\n            expect,\n\n            html,\n\n            os: {\n                sleep,\n                toast,\n                tip,\n                hideTips,\n                showJoinCode,\n                requestFullscreenMode,\n                exitFullscreenMode,\n                showHtml,\n                hideHtml,\n                setClipboard,\n                tweenTo,\n                moveTo,\n                focusOn,\n                showChat,\n                hideChat,\n                run,\n                version,\n                device,\n                isCollaborative,\n                getAB1BootstrapURL,\n                enableAR,\n                disableAR,\n                enableVR,\n                disableVR,\n                arSupported,\n                vrSupported,\n                enablePointOfView,\n                disablePointOfView,\n                download: downloadData,\n                downloadBots,\n\n                downloadServer,\n                downloadInst: downloadServer,\n\n                showUploadAuxFile,\n                showUploadFiles,\n                openQRCodeScanner,\n                closeQRCodeScanner,\n                showQRCode,\n                hideQRCode,\n                openBarcodeScanner,\n                closeBarcodeScanner,\n                showBarcode,\n                hideBarcode,\n\n                openImageClassifier,\n                closeImageClassifier,\n\n                /**\n                 * Gets the local device time in Miliseconds since January 1st 1970 UTC-0.\n                 */\n                get localTime() {\n                    return Date.now();\n                },\n\n                /**\n                 * Gets the current agreed upon inst time in miliseconds since January 1st 1970 UTC-0.\n                 */\n                get agreedUponTime() {\n                    return Date.now() + context.instTimeOffset;\n                },\n\n                /**\n                 * Gets the calculated latency (in miliseconds) between this device and the inst server.\n                 */\n                get instLatency() {\n                    return context.instLatency;\n                },\n\n                /**\n                 * Gets the calculated time offset between this device and the inst server in miliseconds.\n                 */\n                get instTimeOffset() {\n                    return context.instTimeOffset;\n                },\n\n                /**\n                 * Gets the maximum spread between time offset samples in miliseconds.\n                 * Useful for determining how closely the agreedUponTime matches the server time.\n                 */\n                get instTimeOffsetSpread() {\n                    return context.instTimeOffsetSpread;\n                },\n\n                /**\n                 * Gets the current agreed upon time plus an offset that attempts to ensure that\n                 * changes/events will have been synchronized between all connected devices by the moment that this time occurrs.\n                 */\n                get deadReckoningTime() {\n                    return (\n                        Date.now() +\n                        context.instTimeOffset +\n                        DEAD_RECKONING_OFFSET\n                    );\n                },\n\n                loadServer,\n                unloadServer,\n                loadInst: loadServer,\n                unloadInst: unloadServer,\n\n                importAUX,\n                parseBotsFromData,\n                replaceDragBot,\n                isInDimension,\n                getCurrentDimension,\n                getCurrentServer,\n                getCurrentInst: getCurrentServer,\n                getMenuDimension,\n                getMiniPortalDimension,\n                getPortalDimension,\n                getDimensionalDepth,\n                showInputForTag,\n                showInput: makeMockableFunction(showInput, 'os.showInput'),\n                goToDimension,\n                goToURL,\n                openURL,\n                openDevConsole,\n                checkout,\n                playSound,\n                bufferSound,\n                cancelSound,\n                hasBotInMiniPortal,\n                share,\n                closeCircleWipe,\n                openCircleWipe,\n                addDropSnap,\n                addBotDropSnap,\n                addDropGrid,\n                addBotDropGrid,\n                enableCustomDragging,\n                log,\n                getGeolocation,\n                inSheet,\n\n                getCameraPosition,\n                getCameraRotation,\n                getFocusPoint,\n                getPointerPosition,\n                getPointerRotation,\n                getPointerDirection,\n                getInputState,\n                getInputList,\n                getMediaPermission,\n                getAverageFrameRate,\n\n                joinRoom,\n                leaveRoom,\n                setRoomOptions,\n                getRoomOptions,\n                getRoomTrackOptions,\n                setRoomTrackOptions,\n                getRoomRemoteOptions,\n\n                registerTagPrefix: registerPrefix,\n\n                registerApp: registerApp,\n                unregisterApp,\n                compileApp: setAppContent,\n                appHooks: { ...hooks, render },\n                requestAuthBot,\n\n                getPublicRecordKey,\n                getSubjectlessPublicRecordKey,\n                isRecordKey,\n                recordData,\n                recordManualApprovalData,\n                getData,\n                getManualApprovalData,\n                listData,\n                eraseData,\n                eraseManualApprovalData,\n\n                recordFile,\n                getFile,\n                eraseFile,\n\n                recordEvent,\n                countEvents,\n\n                convertGeolocationToWhat3Words,\n\n                raycastFromCamera,\n                raycast,\n                calculateRayFromCamera,\n                bufferFormAddressGLTF,\n                startFormAnimation,\n                stopFormAnimation,\n                listFormAnimations,\n\n                setupInst: setupServer,\n                remotes,\n                listInstUpdates,\n                getInstStateFromUpdates,\n                instances: servers,\n                remoteCount: serverRemoteCount,\n                totalRemoteCount: totalRemoteCount,\n                instStatuses: serverStatuses,\n\n                beginAudioRecording,\n                endAudioRecording,\n\n                meetCommand,\n                meetFunction,\n\n                get vars() {\n                    return context.global;\n                },\n            },\n\n            portal: {\n                registerPrefix,\n            },\n\n            server: {\n                setupServer,\n                rpioInit,\n                rpioExit,\n                rpioOpen,\n                rpioMode,\n                rpioRead,\n                rpioReadSequence,\n                rpioWrite,\n                rpioWriteSequence,\n                rpioReadpad,\n                rpioWritepad,\n                rpioPud,\n                rpioPoll,\n                rpioClose,\n                rpioI2CBegin,\n                rpioI2CSetSlaveAddress,\n                rpioI2CSetBaudRate,\n                rpioI2CSetClockDivider,\n                rpioI2CRead,\n                rpioI2CWrite,\n                // rpioI2CReadRegisterRestart,\n                // rpioI2CWriteReadRestart,\n                rpioI2CEnd,\n                rpioPWMSetClockDivider,\n                rpioPWMSetRange,\n                rpioPWMSetData,\n                rpioSPIBegin,\n                rpioSPIChipSelect,\n                rpioSPISetCSPolarity,\n                rpioSPISetClockDivider,\n                rpioSPISetDataMode,\n                rpioSPITransfer,\n                rpioSPIWrite,\n                rpioSPIEnd,\n                serialConnect,\n                serialStream,\n                serialOpen,\n                serialUpdate,\n                serialWrite,\n                serialRead,\n                serialClose,\n                serialFlush,\n                serialDrain,\n                serialPause,\n                serialResume,\n                shell,\n                backupToGithub,\n                backupAsDownload,\n                finishCheckout,\n                markHistory,\n                browseHistory,\n                restoreHistoryMark,\n                restoreHistoryMarkToServer,\n                restoreHistoryMarkToInst: restoreHistoryMarkToServer,\n                loadFile,\n                saveFile,\n                serverRemoteCount,\n                totalRemoteCount,\n                serverStatuses,\n                remotes,\n                servers,\n\n                // TODO: Remove deprecated function names\n                stories: servers,\n                players: remotes,\n                serverPlayerCount: serverRemoteCount,\n                totalPlayerCount: totalRemoteCount,\n            },\n\n            action: {\n                perform,\n                reject,\n            },\n\n            adminSpace: {\n                unlock: unlockAdminSpace,\n                setPassword: setAdminSpacePassword,\n            },\n\n            experiment: {\n                localFormAnimation,\n                localPositionTween,\n                localRotationTween,\n                getAnchorPointPosition,\n                beginAudioRecording,\n                endAudioRecording,\n                beginRecording,\n                endRecording,\n                speakText,\n                getVoices,\n            },\n\n            math: {\n                sum,\n                avg,\n                sqrt,\n                abs,\n                stdDev,\n                getSeededRandomNumberGenerator,\n                setRandomSeed,\n                randomInt,\n                random,\n                degreesToRadians,\n                radiansToDegrees,\n                getForwardDirection,\n                intersectPlane,\n                getAnchorPointOffset,\n                addVectors,\n                subtractVectors,\n                negateVector,\n                normalizeVector,\n                vectorLength,\n                scaleVector,\n                areClose,\n            },\n\n            mod: {\n                cameraPositionOffset,\n                cameraRotationOffset,\n            },\n\n            bytes: {\n                toBase64String,\n                fromBase64String,\n                toHexString,\n                fromHexString,\n            },\n\n            crypto: {\n                hash,\n                sha256,\n                sha512,\n                hmac,\n                hmacSha256,\n                hmacSha512,\n                encrypt,\n                decrypt,\n                isEncrypted,\n                asymmetric: {\n                    keypair: asymmetricKeypair,\n                    isKeypair: isAsymmetricKeypair,\n                    encrypt: asymmetricEncrypt,\n                    decrypt: asymmetricDecrypt,\n                    isEncrypted: isAsymmetricEncrypted,\n                },\n                keypair,\n                sign,\n                verify,\n                createCertificate,\n                signTag,\n                verifyTag,\n                revokeCertificate,\n            },\n\n            perf: {\n                getStats,\n            },\n\n            web: {\n                get: makeMockableFunction(webGet, 'web.get'),\n                post: makeMockableFunction(webPost, 'web.post'),\n                hook: makeMockableFunction(webhook, 'web.hook'),\n            },\n        },\n\n        tagSpecificApi: {\n            create:\n                (options: TagSpecificApiOptions) =>\n                (...args: any[]) =>\n                    create(options.bot?.id, ...args),\n            setTimeout: botTimer('timeout', setTimeout, true),\n            setInterval: botTimer('interval', setInterval, false),\n            watchPortal: watchPortalBots(),\n            watchBot: watchBot(),\n        },\n    };\n\n    function botTimer(\n        type: TimeoutOrIntervalTimer['type'],\n        func: (handler: Function, timeout: number, ...args: any[]) => number,\n        clearAfterHandlerIsRun: boolean\n    ) {\n        return (options: TagSpecificApiOptions) =>\n            function (handler: Function, timeout?: number, ...args: any[]) {\n                if (!options.bot) {\n                    throw new Error(\n                        `Timers are not supported when there is no current bot.`\n                    );\n                }\n\n                let timer: number;\n                if (clearAfterHandlerIsRun) {\n                    timer = func(\n                        function () {\n                            try {\n                                handler(...arguments);\n                            } finally {\n                                context.removeBotTimer(\n                                    options.bot.id,\n                                    type,\n                                    timer\n                                );\n                            }\n                        },\n                        timeout,\n                        ...args\n                    );\n                } else {\n                    timer = func(handler, timeout, ...args);\n                }\n                context.recordBotTimer(options.bot.id, {\n                    timerId: timer,\n                    type: type,\n                });\n\n                return timer;\n            };\n    }\n\n    function clearTimeout(id: number) {\n        context.cancelAndRemoveTimers(id);\n    }\n\n    function clearInterval(id: number) {\n        context.cancelAndRemoveTimers(id);\n    }\n\n    function watchPortalBots() {\n        let timerId = 0;\n        return (options: TagSpecificApiOptions) =>\n            function (portalId: string, handler: () => void) {\n                let id = timerId++;\n                context.recordBotTimer(options.bot.id, {\n                    type: 'watch_portal',\n                    timerId: id,\n                    portalId,\n                    tag: options.tag,\n                    handler,\n                });\n\n                return id;\n            };\n    }\n\n    function watchBot() {\n        let timerId = 0;\n        return (options: TagSpecificApiOptions) =>\n            function (\n                bot: (Bot | string)[] | Bot | string,\n                handler: () => void\n            ) {\n                let id = timerId++;\n                let botIds = Array.isArray(bot)\n                    ? bot.map((b) => getID(b))\n                    : [getID(bot)];\n                const finalHandler = () => {\n                    try {\n                        return handler();\n                    } catch (err) {\n                        context.enqueueError(err);\n                    }\n                };\n\n                for (let botId of botIds) {\n                    context.recordBotTimer(options.bot.id, {\n                        type: 'watch_bot',\n                        timerId: id,\n                        botId: botId,\n                        tag: options.tag,\n                        handler: finalHandler,\n                    });\n                }\n                return id;\n            };\n    }\n\n    function clearWatchBot(id: number) {\n        context.cancelAndRemoveTimers(id, 'watch_bot');\n    }\n\n    function clearWatchPortal(id: number) {\n        context.cancelAndRemoveTimers(id, 'watch_portal');\n    }\n\n    /**\n     * Asserts that the given condition is true.\n     * Throws an error if the condition is not true.\n     * @param condition The condition to check.\n     * @param message The message to use in the error if the condition is not true.\n     */\n    function assert(condition: boolean, message?: string) {\n        if (!condition) {\n            if (hasValue(message)) {\n                throw new Error('Assertion failed. ' + message);\n            } else {\n                throw new Error('Assertion failed.');\n            }\n        }\n    }\n\n    function getAssertionValue(value: any) {\n        if (value instanceof Error) {\n            return value.toString();\n        }\n        return value;\n    }\n\n    /**\n     * Asserts that the given values contain the same data.\n     * Throws an error if they are not equal.\n     * @param first The first value to test.\n     * @param second The second value to test.\n     */\n    function assertEqual(first: any, second: any) {\n        expect(first).toEqual(second);\n        // const json = getFormattedJSON(getAssertionValue(first));\n        // const json2 = getFormattedJSON(getAssertionValue(second));\n\n        // if (json !== json2) {\n        //     throw new Error(\n        //         `Assertion failed.\\n\\nExpected: ${json2}\\nReceived: ${json}`\n        //     );\n        // }\n    }\n\n    /**\n     * Gets a list of all the bots.\n     *\n     * @example\n     * // Gets all the bots in the inst.\n     * let bots = getBots();\n     */\n    function getBots(...args: any[]): RuntimeBot[] {\n        if (args.length > 0 && typeof args[0] === 'function') {\n            const filtered = context.bots.filter((b) =>\n                args.every((f) => f(b))\n            );\n\n            const sortFuncs = args\n                .filter((f) => typeof f.sort === 'function')\n                .map((f) => f.sort);\n            const sorted =\n                sortFuncs.length > 0\n                    ? sortBy(filtered, ...sortFuncs)\n                    : filtered;\n\n            return sorted;\n        }\n\n        let tag: string = args[0];\n        if (typeof tag === 'undefined') {\n            return context.bots.slice();\n        } else if (!tag) {\n            return [];\n        }\n        tag = trimTag(tag);\n        const filter = arguments[1];\n\n        if (hasValue(filter)) {\n            if (typeof filter === 'function') {\n                return context.bots.filter((b) => filter(b.tags[tag]));\n            } else if (tag === 'id' && typeof filter === 'string') {\n                const bot = context.state[filter];\n                return bot ? [bot] : [];\n            } else {\n                return context.bots.filter((b) => b.tags[tag] === filter);\n            }\n        } else {\n            return context.bots.filter((b) => hasValue(b.tags[tag]));\n        }\n    }\n\n    /**\n     * Gets the first bot ordered by ID.\n     * @returns The bot with the first ID when sorted alphebetically.\n     *\n     * @example\n     * let firstBot = getBot();\n     */\n    function getBot(...args: any[]): RuntimeBot {\n        const bots = getBots(...args);\n        return bots.first();\n    }\n\n    /**\n     * Gets the list of tag values from bots that have the given tag.\n     * @param tag The tag.\n     * @param filter THe optional filter to use for the values.\n     */\n    function getBotTagValues(tag: string, filter?: TagFilter): any[] {\n        const values = context.bots\n            .map((b) => getTag(b, tag))\n            .filter((t) => hasValue(t));\n        if (hasValue(filter)) {\n            if (typeof filter === 'function') {\n                return values.filter((val) => filter(val));\n            } else {\n                return values.filter((val) => val === filter);\n            }\n        } else {\n            return values;\n        }\n    }\n\n    /**\n     * Creates a mod from exported mod data.\n     * @param bot The mod data that should be loaded.\n     * @param tags The tags that should be included in the output mod.\n     * @returns The mod that was loaded from the data.\n     */\n    function getMod(bot: any, ...tags: (string | RegExp)[]): Mod {\n        if (typeof bot === 'string') {\n            bot = JSON.parse(bot);\n        }\n\n        let diff: BotTags = {};\n\n        let tagsObj: BotTags;\n        let botTags: string[];\n        if (isBot(bot)) {\n            tagsObj = bot.tags;\n            botTags = tagsOnBot(bot);\n        } else if (hasValue(bot[ORIGINAL_OBJECT])) {\n            tagsObj = bot[ORIGINAL_OBJECT];\n            botTags = Object.keys(tagsObj);\n        } else {\n            tagsObj = bot;\n            botTags = Object.keys(tagsObj);\n        }\n\n        for (let botTag of botTags) {\n            let add = false;\n            if (tags.length > 0) {\n                for (let tag of tags) {\n                    if (tag instanceof RegExp) {\n                        if (tag.test(botTag)) {\n                            add = true;\n                            break;\n                        }\n                    } else {\n                        if (tag === botTag) {\n                            add = true;\n                            break;\n                        }\n                    }\n                }\n            } else {\n                add = true;\n            }\n\n            if (add) {\n                diff[botTag] = tagsObj[botTag];\n            }\n        }\n\n        return diff;\n    }\n\n    /**\n     * Gets the position that the given bot is at in the given dimension.\n     * @param bot The bot or bot ID.\n     * @param dimension The dimension that the bot's position should be retrieved for.\n     */\n    function getBotPosition(\n        bot: RuntimeBot | string,\n        dimension: string\n    ): Vector3 {\n        if (!bot) {\n            throw new Error('The given bot must not be null.');\n        }\n        const finalBot = typeof bot === 'string' ? context.state[bot] : bot;\n        if (!finalBot) {\n            throw new Error(\n                `Could not find the bot with the given ID (${bot}).`\n            );\n        }\n        const position = calcGetBotPosition(null, finalBot, dimension);\n        return new Vector3(position.x, position.y, position.z);\n    }\n\n    /**\n     * Gets the rotation that the given bot is at in the given dimension.\n     * @param bot The bot or bot ID.\n     * @param dimension The dimension that the bot's rotation should be retrieved for.\n     */\n    function getBotRotation(\n        bot: RuntimeBot | string,\n        dimension: string\n    ): Rotation {\n        if (!bot) {\n            throw new Error('The given bot must not be null.');\n        }\n        const finalBot = typeof bot === 'string' ? context.state[bot] : bot;\n        if (!finalBot) {\n            throw new Error(\n                `Could not find the bot with the given ID (${bot}).`\n            );\n        }\n        return calcGetBotRotation(null, finalBot, dimension);\n    }\n\n    /**\n     * Creates a filter function that checks whether bots have the given tag and value.\n     * @param tag The tag to check.\n     * @param filter The value or filter that the tag should match.\n     *\n     * @example\n     * // Find all the bots with a \"name\" of \"bob\".\n     * let bobs = getBots(byTag(\"name\", \"bob\"));\n     *\n     * @example\n     * // Find all bots with a height larger than 2.\n     * let bots = getBots(byTag(\"height\", height => height > 2));\n     *\n     * @example\n     * // Find all the bots with the \"test\" tag.\n     * let bots = getBots(byTag(\"test\"));\n     */\n    function byTag(tag: string, filter?: TagFilter): BotFilterFunction {\n        tag = trimTag(tag);\n        if (filter && typeof filter === 'function') {\n            return (bot) => {\n                let val = bot.tags[tag];\n                return hasValue(val) && filter(val);\n            };\n        } else if (hasValue(filter)) {\n            if (isBotLink(filter)) {\n                const ids = parseBotLink(filter);\n                if (ids.length === 0) {\n                    return (bot) => {\n                        let val = bot.tags[tag];\n                        return val === filter;\n                    };\n                } else if (ids.length === 1) {\n                    return (bot) => {\n                        let val = bot.tags[tag];\n                        return (\n                            ids[0] === val ||\n                            (isBotLink(val) &&\n                                parseBotLink(val).some((id) => id === ids[0]))\n                        );\n                    };\n                } else {\n                    return (bot) => {\n                        let val = bot.tags[tag];\n                        const valIds = parseBotLink(val);\n                        return (\n                            !!valIds &&\n                            ids.every((id1) =>\n                                valIds.some((id2) => id1 === id2)\n                            )\n                        );\n                    };\n                }\n            } else {\n                return (bot) => {\n                    let val = bot.tags[tag];\n                    return hasValue(val) && filter === val;\n                };\n            }\n        } else if (filter === null) {\n            return (bot) => {\n                let val = bot.tags[tag];\n                return !hasValue(val);\n            };\n        } else {\n            return (bot) => {\n                let val = bot.tags[tag];\n                return hasValue(val);\n            };\n        }\n    }\n\n    /**\n     * Creates a filter function that checks whether bots have the given ID.\n     * @param id The ID to check for.\n     *\n     * @example\n     * // Find all the bots with the ID \"bob\".\n     * let bobs = getBots(byId(\"bob\"));\n     */\n    function byID(id: string): IDRecordFilter {\n        let filter: IDRecordFilter = ((bot: Bot) => {\n            return bot.id === id;\n        }) as any;\n\n        filter.recordFilter = true;\n        filter.id = id;\n        filter.toJSON = () => {\n            return {\n                recordFilter: true,\n                id: id,\n            };\n        };\n        filter[DEBUG_STRING] = debugStringifyFunction('byID', [id]);\n\n        return filter;\n    }\n\n    /**\n     * Creates a filter function that checks whether bots match the given mod.\n     * @param mod The mod that bots should be checked against.\n     *\n     * @example\n     * // Find all the bots with a height set to 1 and color set to \"red\".\n     * let bots = getBots(byMod({\n     *      \"color\": \"red\",\n     *      height: 1\n     * }));\n     */\n    function byMod(mod: Mod): BotFilterFunction {\n        let tags = isBot(mod) ? mod.tags : mod;\n        let filters = Object.keys(tags).map((k) => byTag(k, tags[k]));\n        return (bot) => filters.every((f) => f(bot));\n    }\n\n    /**\n     * Creates a filter function that checks whether bots are in the given dimension.\n     * @param dimension The dimension to check.\n     * @returns A function that returns true if the given bot is in the dimension and false if it is not.\n     *\n     * @example\n     * // Find all the bots in the \"test\" dimension.\n     * let bots = getBots(inDimension(\"test\"));\n     */\n    function inDimension(dimension: string): BotFilterFunction {\n        return byTag(dimension, true);\n    }\n\n    /**\n     * Creates a filter function that checks whether bots are at the given position in the given dimension.\n     * @param dimension The dimension that the bots should be in.\n     * @param x The X position in the dimension that the bots should be at.\n     * @param y The Y position in the dimension that the bots should be at.\n     * @returns A function that returns true if the given bot is at the given position and false if it is not.\n     *\n     * @example\n     * // Find all the bots at (1, 2) in the \"test\" dimension.\n     * let bots = getBots(atPosition(\"test\", 1, 2));\n     */\n    function atPosition(\n        dimension: string,\n        x: number,\n        y: number\n    ): BotFilterFunction {\n        const inCtx = inDimension(dimension);\n        const atX = byTag(`${dimension}X`, (bx) => areClose(bx, x));\n        const atY = byTag(`${dimension}Y`, (by) => areClose(by, y));\n        const filter: BotFilterFunction = (b) => inCtx(b) && atX(b) && atY(b);\n        filter.sort = (b) => getTag(b, `${dimension}SortOrder`) || 0;\n        return filter;\n    }\n\n    /**\n     * Creates a filter function that checks whether bots are in the same stack as the given bot.\n     * @param bot The bot that other bots should be checked against.\n     * @param dimension The dimension that other bots should be checked in.\n     * @returns A function that returns true if the given bot is in the same stack as the original bot.\n     *\n     * @example\n     * // Find all bots in the same stack as `this` in the \"test\" dimension.\n     * let bots = getBots(inStack(this, \"test\"));\n     *\n     */\n    function inStack(bot: Bot, dimension: string): BotFilterFunction {\n        return atPosition(\n            dimension,\n            getTag(bot, `${dimension}X`),\n            getTag(bot, `${dimension}Y`)\n        );\n    }\n\n    /**\n     * Creates a function that filters bots by whether they are neighboring the given bot.\n     * @param bot The bot that other bots should be checked against.\n     * @param dimension The dimension that other bots should be checked in.\n     * @param direction The neighboring direction to check. If not specified, then bots from all directions will be included.\n     * @returns A function that returns true if the given bot is next to the original bot.\n     *\n     * @example\n     * // Find all bots in front of `this` bot in the \"test\" dimension.\n     * let bots = getBots(neighboring(this, \"test\", \"front\"));\n     */\n    function neighboring(\n        bot: Bot,\n        dimension: string,\n        direction?: 'front' | 'left' | 'right' | 'back'\n    ): BotFilterFunction {\n        if (!hasValue(direction)) {\n            return either(\n                neighboring(bot, dimension, 'front'),\n                neighboring(bot, dimension, 'right'),\n                neighboring(bot, dimension, 'back'),\n                neighboring(bot, dimension, 'left')\n            );\n        } else if (\n            direction !== 'left' &&\n            direction !== 'right' &&\n            direction !== 'front' &&\n            direction !== 'back'\n        ) {\n            return () => false;\n        }\n\n        const offsetX =\n            direction === 'left' ? 1 : direction === 'right' ? -1 : 0;\n        const offsetY =\n            direction === 'back' ? 1 : direction === 'front' ? -1 : 0;\n\n        const x = getTag(bot, `${dimension}X`);\n        const y = getTag(bot, `${dimension}Y`);\n\n        return atPosition(dimension, x + offsetX, y + offsetY);\n    }\n\n    /**\n     * Creates a function that filters bots by whether they are in the given space.\n     * @param space The space that the bots should be in.\n     */\n    function bySpace(space: string): SpaceFilter {\n        let func = byTag(BOT_SPACE_TAG, space) as SpaceFilter;\n        func.recordFilter = true;\n        func.space = space;\n        func.toJSON = () => {\n            return {\n                recordFilter: true,\n                space: space,\n            };\n        };\n        func[DEBUG_STRING] = debugStringifyFunction('bySpace', [space]);\n        return func;\n    }\n\n    /**\n     * Creates a filter function that checks whether bots were created by the given bot.\n     * @param bot The bot to determine weather the bots have been created by it or not.\n     * @returns A function that returns true if the bot was created by the given bot.\n     *\n     * @example\n     * // Find all the bots created by the yellow bot.\n     * let bots = getBots(byCreator(getBot('color','yellow')));\n     */\n    function byCreator(bot: Bot | string): BotFilterFunction {\n        const id = getID(bot);\n        return byTag('creator', id);\n    }\n\n    /**\n     * Creates a function that filters bots by whether they match any of the given filters.\n     * @param filters The filter functions that a bot should be tested against.\n     *\n     * @example\n     * // Find all bots with the name \"bob\" or height 2.\n     * let bots = getBots(\n     *   either(\n     *     byTag(\"name\", \"bob\"),\n     *     byTag(\"height\", height => height === 2)\n     *   )\n     * );\n     */\n    function either(...filters: BotFilterFunction[]): BotFilterFunction {\n        return (bot) => filters.some((f) => f(bot));\n    }\n\n    /**\n     * Creates a function that negates the result of the given function.\n     * @param filter The function whose results should be negated.\n     *\n     * @example\n     * // Find all bots that are not in the \"test\" dimension.\n     * let bots = getBots(not(inDimension(\"test\")));\n     */\n    function not(filter: BotFilterFunction): BotFilterFunction {\n        return (bot) => !filter(bot);\n    }\n\n    /**\n     * Gets the value of the given tag stored in the given bot.\n     * @param bot The bot.\n     * @param tag The tag.\n     *\n     * @example\n     * // Get the \"color\" tag from the `this` bot.\n     * let color = getTag(this, \"color\");\n     */\n    function getTag(bot: Bot, ...tags: string[]): any {\n        let current: any = bot;\n        for (let i = 0; i < tags.length; i++) {\n            const tag = trimTag(tags[i].toString());\n            if (isBot(current)) {\n                current = current.tags[tag];\n            } else {\n                return current;\n            }\n        }\n\n        return current;\n    }\n\n    /**\n     * Gets the ID from the given bot.\n     * @param bot The bot or string.\n     */\n    function getID(bot: Bot | string): string {\n        if (typeof bot === 'string') {\n            return bot || null;\n        } else if (bot) {\n            return bot.id || null;\n        }\n\n        return null;\n    }\n\n    /**\n     * Gets JSON for the given data.\n     * @param data The data.\n     */\n    function getJSON(data: any): string {\n        if (hasValue(data?.[ORIGINAL_OBJECT])) {\n            return stableStringify(data[ORIGINAL_OBJECT]);\n        }\n        return stableStringify(data);\n    }\n\n    /**\n     * Gets formatted JSON for the given data.\n     * @param data The data.\n     */\n    function getFormattedJSON(data: any): string {\n        if (hasValue(data?.[ORIGINAL_OBJECT])) {\n            return stableStringify(data[ORIGINAL_OBJECT], { space: 2 });\n        }\n        return stableStringify(data, { space: 2 });\n    }\n\n    /**\n     * Gets a snapshot of the data that the bots contain.\n     * This is useful for getting all the tags and masks that are attached to the given bots.\n     * @param bots The array of bots to get the snapshot for.\n     */\n    function getSnapshot(bots: Bot[] | Bot): BotsState {\n        if (!Array.isArray(bots)) {\n            return getSnapshot([bots]);\n        }\n        let state = {} as BotsState;\n        for (let bot of bots) {\n            let b = (state[bot.id] = {\n                id: bot.id,\n                tags: {\n                    ...(typeof bot.tags.toJSON === 'function'\n                        ? bot.tags.toJSON()\n                        : bot.tags),\n                },\n            } as Bot);\n\n            if (bot.space) {\n                b.space = bot.space;\n            }\n\n            let masks = isRuntimeBot(bot)\n                ? bot[GET_TAG_MASKS_SYMBOL]()\n                : cloneDeep(bot.masks ?? {});\n            if (Object.keys(masks).length > 0) {\n                b.masks = masks;\n            }\n        }\n        return state;\n    }\n\n    /**\n     * Calculates the difference between the two given snapshots.\n     * @param first The first snapshot.\n     * @param second The second snapshot.\n     */\n    function diffSnapshots(\n        first: BotsState,\n        second: BotsState\n    ): PartialBotsState {\n        const allIds = union(Object.keys(first), Object.keys(second));\n        let diff: PartialBotsState = {};\n        for (let id of allIds) {\n            const inFirst = id in first;\n            const inSecond = id in second;\n            if (inFirst && inSecond) {\n                // possibly updated\n                const firstBot = first[id];\n                const secondBot = second[id];\n                if (firstBot && secondBot) {\n                    let botDiff = {} as PartialBot;\n                    let tagsDiff = diffTags(firstBot.tags, secondBot.tags);\n                    if (!!tagsDiff) {\n                        botDiff.tags = tagsDiff;\n                    }\n\n                    const firstBotMasks = firstBot.masks || {};\n                    const secondBotMasks = secondBot.masks || {};\n                    let masksDiff = {} as PartialBot['masks'];\n                    let hasMasksDiff = false;\n                    const allMaskSpaces = union(\n                        Object.keys(firstBotMasks),\n                        Object.keys(secondBotMasks)\n                    );\n                    for (let space of allMaskSpaces) {\n                        const firstMasks = firstBotMasks[space] || {};\n                        const secondMasks = secondBotMasks[space] || {};\n\n                        let tagsDiff = diffTags(firstMasks, secondMasks);\n                        if (!!tagsDiff) {\n                            hasMasksDiff = true;\n                            masksDiff[space] = tagsDiff;\n                        }\n                    }\n\n                    if (hasMasksDiff) {\n                        botDiff.masks = masksDiff;\n                    }\n\n                    if (!!tagsDiff || hasMasksDiff) {\n                        diff[id] = botDiff;\n                    }\n                }\n            } else if (inFirst) {\n                // deleted\n                diff[id] = null;\n            } else if (inSecond) {\n                // added\n                diff[id] = second[id];\n            }\n        }\n        return diff;\n\n        function diffTags(firstTags: BotTags, secondTags: BotTags): BotTags {\n            let tagsDiff = {} as BotTags;\n            let hasTagsDiff = false;\n            const allTags = union(\n                Object.keys(firstTags),\n                Object.keys(secondTags)\n            );\n            for (let tag of allTags) {\n                const firstValue = firstTags[tag];\n                const secondValue = secondTags[tag];\n                if (!isEqual(firstValue, secondValue)) {\n                    // updated, deleted, or added\n                    hasTagsDiff = true;\n                    tagsDiff[tag] = hasValue(secondValue) ? secondValue : null;\n                }\n            }\n            return hasTagsDiff ? tagsDiff : null;\n        }\n    }\n\n    /**\n     * Applies the given delta to the given snapshot and returns the result.\n     * This is essentially the opposite of diffSnapshots().\n     * @param snapshot The snapshot that the diff should be applied to.\n     * @param diff The delta that should be applied to the snapshot.\n     */\n    function applyDiffToSnapshot(\n        snapshot: BotsState,\n        diff: PartialBotsState\n    ): BotsState {\n        return apply(snapshot, diff);\n    }\n\n    /**\n     * Converts the given array of bytes into a base64 string.\n     * @param bytes The bytes that should be converted into base64.\n     */\n    function toBase64String(bytes: Uint8Array): string {\n        return fromByteArray(bytes);\n    }\n\n    /**\n     * Converts the given base64 formatted string into an array of bytes.\n     * @param base64 The base64 that should be converted to bytes.\n     */\n    function fromBase64String(base64: string): Uint8Array {\n        return toByteArray(base64);\n    }\n\n    /**\n     * Converts the given array of bytes into a hexadecimal string.\n     * @param bytes The bytes that should be converted into hex.\n     */\n    function toHexString(bytes: Uint8Array): string {\n        return utilToHexString(bytes);\n    }\n\n    /**\n     * Converts the given hexadecimal string into an array of bytes.\n     * @param hex The hexadecimal string.\n     */\n    function fromHexString(hex: string): Uint8Array {\n        return utilFromHexString(hex);\n    }\n\n    // Actions\n\n    /**\n     * Shows a toast message to the user.\n     * @param message The message to show.\n     * @param duration The number of seconds the message should be on the screen. (Defaults to 2)\n     */\n    function toast(\n        message: string | number | boolean | object | Array<any> | null,\n        duration: number = 2\n    ): ShowToastAction {\n        return addAction(\n            toastMessage(convertToCopiableValue(message), duration)\n        );\n    }\n\n    /**\n     * Shows a tooltip message to the user.\n     * @param message The message to show.\n     * @param pixelX The X coordinate that the tooltip should be shown at. If null, then the current pointer position will be used.\n     * @param pixelY The Y coordinate that the tooltip should be shown at. If null, then the current pointer position will be used.\n     * @param duration The duration that the tooltip should be shown in seconds.\n     */\n    function tip(\n        message: string | number | boolean | object | Array<any> | null,\n        pixelX?: number,\n        pixelY?: number,\n        duration?: number\n    ): Promise<number> {\n        const task = context.createTask();\n        const action = tipMessage(\n            convertToCopiableValue(message),\n            pixelX ?? null,\n            pixelY ?? null,\n            (duration ?? 2) * 1000,\n            task.taskId\n        );\n        return addAsyncAction(task, action);\n    }\n\n    /**\n     * Hides the given list of tips.\n     * If no tip IDs are provided, then all tips will be hidden.\n     * @param tipIds\n     * @returns\n     */\n    function hideTips(tipIds?: number | number[]): Promise<void> {\n        const ids =\n            arguments.length <= 0\n                ? null\n                : typeof tipIds === 'number'\n                ? [tipIds]\n                : tipIds;\n        const task = context.createTask();\n        const action = hideTipMessages(ids, task.taskId);\n        return addAsyncAction(task, action);\n    }\n\n    /**\n     * Shows a QR Code that contains a link to a inst and dimension.\n     * @param inst The inst that should be joined. Defaults to the current inst.\n     * @param dimension The dimension that should be joined. Defaults to the current dimension.\n     */\n    function showJoinCode(\n        inst?: string,\n        dimension?: string\n    ): ShowJoinCodeAction {\n        return addAction(calcShowJoinCode(inst, dimension));\n    }\n\n    /**\n     * Requests that AUX enters fullscreen mode.\n     * Depending on the web browser, this may ask the player for permission.\n     */\n    function requestFullscreenMode(): RequestFullscreenAction {\n        return addAction(requestFullscreen());\n    }\n\n    /**\n     * Exits fullscreen mode.\n     */\n    function exitFullscreenMode(): ExitFullscreenAction {\n        return addAction(exitFullscreen());\n    }\n\n    /**\n     * Shows some HTML to the user.\n     * @param html The HTML to show.\n     */\n    function showHtml(html: string): ShowHtmlAction {\n        return addAction(htmlMessage(html));\n    }\n\n    /**\n     * Hides the HTML from the user.\n     */\n    function hideHtml(): HideHtmlAction {\n        return addAction(hideHtmlMessage());\n    }\n\n    /**\n     * Sets the text stored in the player's clipboard.\n     * @param text The text to set to the clipboard.\n     */\n    function setClipboard(text: string): SetClipboardAction {\n        return addAction(calcSetClipboard(text));\n    }\n\n    /**\n     * Tweens the user's camera to view the given bot.\n     * @param bot The bot to view.\n     * @param zoomValue The zoom value to use.\n     * @param rotX The value to use for the X rotation. Units in degrees.\n     * @param rotY The value to use for the Y rotation. Units in degrees.\n     */\n    function tweenTo(\n        bot: Bot | string,\n        zoomValue?: number,\n        rotX?: number,\n        rotY?: number,\n        duration?: number\n    ): FocusOnBotAction {\n        return addAction(\n            calcTweenTo(getID(bot), {\n                zoom: zoomValue,\n                rotation:\n                    hasValue(rotX) || hasValue(rotY)\n                        ? {\n                              x: hasValue(rotX) ? rotX * (Math.PI / 180) : null,\n                              y: hasValue(rotY) ? rotY * (Math.PI / 180) : null,\n                          }\n                        : undefined,\n                duration,\n            })\n        );\n    }\n\n    /**\n     * Instantly moves the user's camera to view the given bot.\n     * @param bot The bot to view.\n     * @param zoomValue The zoom value to use.\n     * @param rotX The X rotation.\n     * @param rotY The Y rotation.\n     */\n    function moveTo(\n        bot: Bot | string,\n        zoomValue?: number,\n        rotX?: number,\n        rotY?: number\n    ): FocusOnBotAction {\n        return tweenTo(bot, zoomValue, rotX, rotY, 0);\n    }\n\n    /**\n     * Moves the camera to view the given bot.\n     * Returns a promise that resolves when the bot is focused.\n     * @param botOrPosition The bot, bot ID, or position to view. If null, then any active camera animation will be canceled.\n     * @param options The options to use for moving the camera.\n     */\n    function focusOn(\n        botOrPosition: Bot | string | { x: number; y: number; z?: number },\n        options: FocusOnOptions = {}\n    ): Promise<void> {\n        const task = context.createTask();\n        const finalOptions: FocusOnOptions = {\n            duration: 1,\n            easing: 'quadratic',\n            ...(options ?? {}),\n        };\n        let action: AsyncActions;\n        if (botOrPosition === null) {\n            action = cancelAnimation(task.taskId);\n        } else if (botOrPosition === undefined) {\n            throw new Error(\n                'Cannot focus on an undefined bot. Maybe a getBot() is returning undefined?'\n            );\n        } else if (typeof botOrPosition === 'string' || isBot(botOrPosition)) {\n            action = calcTweenTo(\n                getID(botOrPosition),\n                finalOptions,\n                task.taskId\n            );\n        } else {\n            action = animateToPosition(\n                botOrPosition,\n                finalOptions,\n                task.taskId\n            );\n        }\n\n        return addAsyncAction(task, action);\n    }\n\n    /**\n     * Shows the chat bar.\n     * @param placeholderOrOptions The placeholder text or options. (optional)\n     */\n    function showChat(\n        placeholderOrOptions?: string | ShowChatOptions\n    ): ShowChatBarAction {\n        const action =\n            typeof placeholderOrOptions === 'string'\n                ? calcShowChat({\n                      placeholder: placeholderOrOptions,\n                  })\n                : calcShowChat(placeholderOrOptions);\n        return addAction(action);\n    }\n\n    /**\n     * Hides the run bar.\n     */\n    function hideChat(): ShowChatBarAction {\n        return addAction(calcHideChat());\n    }\n\n    /**\n     * Enqueues the given script to execute after this script is done running.\n     * @param script The script that should be executed.\n     */\n    function run(script: string) {\n        const task = context.createTask();\n        const event = runScript(script, task.taskId);\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Gets information about the version of AUX that is running.\n     */\n    function version(): AuxVersion {\n        return context.version;\n    }\n\n    /**\n     * Gets information about the device that the player is using.\n     */\n    function device(): AuxDevice {\n        if (context.device) {\n            return context.device;\n        }\n        return {\n            supportsAR: null as boolean,\n            supportsVR: null as boolean,\n            isCollaborative: null as boolean,\n            ab1BootstrapUrl: null as string,\n        };\n    }\n\n    /**\n     * Gets whether this device has enabled collaborative features.\n     */\n    function isCollaborative(): boolean {\n        if (context.device) {\n            return context.device.isCollaborative;\n        }\n\n        return true;\n    }\n\n    /**\n     * Gets the URL that AB1 should be bootstrapped from.\n     */\n    function getAB1BootstrapURL(): string {\n        if (context.device) {\n            return context.device.ab1BootstrapUrl;\n        }\n\n        return 'https://bootstrap.casualos.com/ab1.aux';\n    }\n\n    /**\n     * Enables Augmented Reality features.\n     */\n    function enableAR(): EnableARAction {\n        return addAction(calcEnableAR());\n    }\n\n    /**\n     * Disables Augmented Reality features.\n     */\n    function disableAR(): EnableARAction {\n        return addAction(calcDisableAR());\n    }\n\n    /**\n     * Gets wether this device supported AR or not.\n     */\n    function arSupported() {\n        const task = context.createTask();\n        const event = calcARSupported(task.taskId);\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Enables Virtual Reality features.\n     */\n    function enableVR(): EnableVRAction {\n        return addAction(calcEnableVR());\n    }\n\n    /**\n     * Disables Virtual Reality features.\n     */\n    function disableVR(): EnableVRAction {\n        return addAction(calcDisableVR());\n    }\n\n    /**\n     * Gets wether this device supported VR or not.\n     */\n    function vrSupported() {\n        const task = context.createTask();\n        const event = calcVRSupported(task.taskId);\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Enables Point-of-View mode.\n     */\n    function enablePointOfView(\n        center: { x: number; y: number; z: number } = { x: 0, y: 0, z: 0 },\n        imu?: boolean\n    ): EnablePOVAction {\n        return addAction(enablePOV(center, imu));\n    }\n\n    /**\n     * Disables Point-of-View mode.\n     */\n    function disablePointOfView(): EnablePOVAction {\n        return addAction(disablePOV());\n    }\n\n    /**\n     * Downloads the given data.\n     * @param data The data to download. Objects will be formatted as JSON before downloading.\n     * @param filename The name of the file that the data should be downloaded as.\n     * @param mimeType The MIME type that should be used. If not specified then it will be inferred from the filename.\n     */\n    function downloadData(\n        data: string | object | ArrayBuffer | Blob,\n        filename: string,\n        mimeType: string = mime.getType(filename) || 'text/plain'\n    ): DownloadAction {\n        if (typeof filename !== 'string') {\n            throw new Error('The filename must be a string.');\n        }\n        if (typeof mimeType !== 'string') {\n            throw new Error('The mimeType must be a string.');\n        }\n\n        if (data instanceof Blob) {\n            mimeType = data.type;\n        }\n\n        if (!hasExtension(filename)) {\n            const extension = mime.getExtension(mimeType);\n            if (hasValue(extension)) {\n                filename = `${filename}.${extension}`;\n            }\n        }\n\n        if (typeof data === 'string') {\n            return addAction(download(data, filename, mimeType));\n        } else if (data instanceof ArrayBuffer) {\n            return addAction(download(data, filename, mimeType));\n        } else if (data instanceof Blob) {\n            return addAction(download(data, filename, mimeType));\n        } else if (typeof data === 'object') {\n            return addAction(\n                download(JSON.stringify(data), filename, mimeType)\n            );\n        }\n\n        throw new Error(\n            'The data must be either a string, object, or ArrayBuffer.'\n        );\n    }\n\n    /**\n     * Determines if the given filename has an extension.\n     * Returns null if the file has no extension.\n     * @param filename The name of the file.\n     */\n    function hasExtension(filename: string) {\n        const dot = filename.lastIndexOf('.');\n        return dot >= 0;\n    }\n\n    /**\n     * Downloads the given list of bots.\n     * @param bots The bots that should be downloaded.\n     * @param filename The name of the file that the bots should be downloaded as.\n     */\n    function downloadBots(bots: Bot[], filename: string): DownloadAction {\n        let state: BotsState = {};\n        for (let bot of bots) {\n            state[bot.id] = bot;\n        }\n\n        let data = JSON.stringify(getDownloadState(state));\n        if (isPdf(filename)) {\n            const encoder = new TextEncoder();\n            const bytes = encoder.encode(data);\n            const base64 = fromByteArray(bytes);\n            data = embedBase64InPdf(base64);\n        }\n\n        const downloadedFilename = formatAuxFilename(filename);\n\n        return addAction(\n            download(\n                data,\n                downloadedFilename,\n                mime.getType(downloadedFilename) || 'application/json'\n            )\n        );\n    }\n\n    /**\n     * Downloads all the shared bots in the inst.\n     */\n    function downloadServer(): DownloadAction {\n        return downloadBots(\n            getBots(bySpace('shared')),\n            `${getCurrentServer()}.aux`\n        );\n    }\n\n    /**\n     * Shows the \"Upload AUX File\" dialog.\n     */\n    function showUploadAuxFile(): ShowUploadAuxFileAction {\n        return addAction(calcShowUploadAuxFile());\n    }\n\n    /**\n     * Shows the \"Upload File\" dialog.\n     */\n    function showUploadFiles() {\n        const task = context.createTask();\n        const action = calcShowUploadFiles(task.taskId);\n        return addAsyncAction(task, action);\n    }\n\n    /**\n     * Opens the QR Code Scanner.\n     * @param camera The camera that should be used.\n     */\n    function openQRCodeScanner(camera?: CameraType): OpenQRCodeScannerAction {\n        const event = calcOpenQRCodeScanner(true, camera);\n        return addAction(event);\n    }\n\n    /**\n     * Closes the QR Code Scanner.\n     */\n    function closeQRCodeScanner(): OpenQRCodeScannerAction {\n        const event = calcOpenQRCodeScanner(false);\n        return addAction(event);\n    }\n\n    /**\n     * Shows the given QR Code.\n     * @param code The code to show.\n     */\n    function showQRCode(code: string): ShowQRCodeAction {\n        const event = calcShowQRCode(true, code);\n        return addAction(event);\n    }\n\n    /**\n     * Hides the QR Code.\n     */\n    function hideQRCode(): ShowQRCodeAction {\n        const event = calcShowQRCode(false);\n        return addAction(event);\n    }\n\n    /**\n     * Opens the barcode scanner.\n     * @param camera The camera that should be used.\n     */\n    function openBarcodeScanner(camera?: CameraType): OpenBarcodeScannerAction {\n        const event = calcOpenBarcodeScanner(true, camera);\n        return addAction(event);\n    }\n\n    /**\n     * Closes the barcode scanner.\n     */\n    function closeBarcodeScanner(): OpenBarcodeScannerAction {\n        const event = calcOpenBarcodeScanner(false);\n        return addAction(event);\n    }\n\n    /**\n     * Shows the given barcode.\n     * @param code The code that should be shown.\n     * @param format The format that the barcode should be shown in.\n     */\n    function showBarcode(\n        code: string,\n        format?: BarcodeFormat\n    ): ShowBarcodeAction {\n        const event = calcShowBarcode(true, code, format);\n        return addAction(event);\n    }\n\n    /**\n     * Hides the barcode.\n     */\n    function hideBarcode(): ShowBarcodeAction {\n        const event = calcShowBarcode(false);\n        return addAction(event);\n    }\n\n    /**\n     * Shows an image classifier for the given ML Model.\n     * Returns a promise that resolves when the image classifier has been opened.\n     * @param options The options for the classifier.\n     */\n    function openImageClassifier(\n        options: ImageClassifierOptions\n    ): Promise<void> {\n        const task = context.createTask();\n        const action = calcOpenImageClassifier(true, options, task.taskId);\n        return addAsyncAction(task, action);\n    }\n\n    /**\n     * Hides the image classifier.\n     * Returns a promise that resolves when the image classifier has been hidden.\n     */\n    function closeImageClassifier(): Promise<void> {\n        const task = context.createTask();\n        const action = calcOpenImageClassifier(false, {}, task.taskId);\n        return addAsyncAction(task, action);\n    }\n\n    /**\n     * Loads the instance with the given ID.\n     * @param id The ID of the inst to load.\n     */\n    function loadServer(id: string): LoadServerAction {\n        const event = loadSimulation(id);\n        return addAction(event);\n    }\n\n    /**\n     * Unloads the instance with the given ID.\n     * @param id The ID of the instance to unload.\n     */\n    function unloadServer(id: string): UnloadServerAction {\n        const event = unloadSimulation(id);\n        return addAction(event);\n    }\n\n    /**\n     * Imports the AUX from the given URL or JSON\n     * @param urlOrJSON The URL or JSON to load.\n     *                  If given JSON, then it will be imported as if it was a .aux file.\n     *                  If given a URL, then it will be downloaded and then imported.\n     */\n    function importAUX(urlOrJSON: string): ImportAUXAction | ApplyStateAction {\n        try {\n            const bots = parseBotsFromData(urlOrJSON);\n            if (bots) {\n                let state: BotsState = {};\n                for (let bot of bots) {\n                    state[bot.id] = bot;\n                }\n                const uploaded = getUploadState(state);\n                const event = addState(uploaded);\n                return addAction(event);\n            }\n        } catch {}\n        const event = calcImportAUX(urlOrJSON);\n        return addAction(event);\n    }\n\n    /**\n     * Parses the given JSON or PDF data and returns the list of bots that were contained in it.\n     * @param jsonOrPdf The JSON or PDF data to parse.\n     */\n    function parseBotsFromData(jsonOrPdf: string | ArrayBuffer): Bot[] {\n        let data: any;\n\n        if (typeof jsonOrPdf === 'string') {\n            try {\n                data = JSON.parse(jsonOrPdf);\n            } catch (e) {\n                try {\n                    data = getEmbeddedBase64FromPdf(jsonOrPdf);\n                    const bytes = toByteArray(data);\n                    const decoder = new TextDecoder();\n                    const text = decoder.decode(bytes);\n                    data = JSON.parse(text);\n                } catch (err) {\n                    data = null;\n                }\n            }\n        } else {\n            try {\n                const str = new TextDecoder().decode(jsonOrPdf);\n                data = getEmbeddedBase64FromPdf(str);\n                const bytes = toByteArray(data);\n                const decoder = new TextDecoder();\n                const text = decoder.decode(bytes);\n                data = JSON.parse(text);\n            } catch (err) {\n                data = null;\n            }\n        }\n\n        if (!hasValue(data)) {\n            return null;\n        }\n\n        const state = getUploadState(data);\n        let bots = [] as Bot[];\n\n        for (let bot in state) {\n            const b = state[bot];\n            if (hasValue(b)) {\n                bots.push(b);\n            }\n        }\n\n        return bots;\n    }\n\n    /**\n     * Replaces the bot that the user is beginning to drag.\n     * Only works from inside a onDrag() or onAnyBotDrag() listen tag.\n     * @param bot The bot or mod that should be dragged instead of the original.\n     */\n    function replaceDragBot(bot: Mod): ReplaceDragBotAction {\n        const event = calcReplaceDragBot(context.unwrapBot(bot));\n        return addAction(event);\n    }\n\n    /**\n     * Derermines whether the player is in the given dimension.\n     * @param dimension The dimension.\n     */\n    function isInDimension(dimension: string): boolean {\n        return (\n            getCurrentDimension() === dimension &&\n            getCurrentDimension() != undefined\n        );\n    }\n\n    /**\n     * Gets the dimension that the player is currently viewing.\n     */\n    function getCurrentDimension(): string {\n        const user = context.playerBot;\n        if (user) {\n            const dimension = getTag(user, 'gridPortal');\n            if (hasValue(dimension)) {\n                return dimension.toString();\n            }\n            return undefined;\n        }\n        return undefined;\n    }\n\n    /**\n     * Gets the instance that the player is currently in.\n     */\n    function getCurrentServer(): string {\n        const user = context.playerBot;\n        if (user) {\n            let inst = getTag(user, 'inst');\n            if (hasValue(inst)) {\n                return inst.toString();\n            }\n            return undefined;\n        }\n        return undefined;\n    }\n\n    /**\n     * Gets the name of the dimension that is used for the current user's miniGridPortal.\n     */\n    function getMiniPortalDimension(): string {\n        const user = context.playerBot;\n        if (user) {\n            const miniGridPortal = getTag(user, MINI_PORTAL);\n            if (hasValue(miniGridPortal)) {\n                return miniGridPortal.toString();\n            }\n            return null;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Gets the name of the dimension that is used for the current user's menu.\n     */\n    function getMenuDimension(): string {\n        const user = context.playerBot;\n        if (user) {\n            const menu = getTag(user, 'menuPortal');\n            if (hasValue(menu)) {\n                return menu.toString();\n            }\n            return null;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Gets the dimension that is loaded into the given portal for the player.\n     * If no dimension is loaded, then null is returned.\n     * @param portal The portal type.\n     */\n    function getPortalDimension(portal: PortalType): string {\n        const user = context.playerBot;\n        if (!user) {\n            return null;\n        }\n\n        const portalTag = getPortalTag(portal);\n        const dimension = getTag(user, portalTag);\n\n        if (!hasValue(dimension)) {\n            return null;\n        }\n\n        return dimension.toString();\n    }\n\n    /**\n     * Gets the distance that the player bot is from the given dimension.\n     *\n     * Returns 0 if the player bot is in the dimension, 1 if the dimension is in a portal, and -1 if neither are true.\n     *\n     * @param dimension The dimension to check for.\n     */\n    function getDimensionalDepth(dimension: string): number {\n        const bot = context.playerBot;\n\n        if (getTag(bot, dimension) === true) {\n            return 0;\n        } else if (\n            KNOWN_PORTALS.some((portal) => getTag(bot, portal) === dimension)\n        ) {\n            return 1;\n        }\n        return -1;\n    }\n\n    /**\n     * Shows an input box to edit the given bot and tag.\n     *\n     * @param bot The bot or bot ID that should be edited.\n     * @param tag The tag which should be edited on the bot.\n     * @param options The options that indicate how the input box should be customized.\n     *\n     * @example\n     * // Show an input box for `this` bot's label.\n     * os.showInputForTag(this, \"label\", {\n     *            title: \"Change the label\",\n     *            type: \"text\"\n     * });\n     *\n     * @example\n     * // Show a color picker for the bot's color.\n     * os.showInputForTag(this, \"color\", {\n     *            title: \"Change the color\",\n     *            type: \"color\",\n     *            subtype: \"advanced\"\n     * });\n     */\n    function showInputForTag(\n        bot: Bot | string,\n        tag: string,\n        options?: Partial<ShowInputOptions>\n    ): ShowInputForTagAction {\n        const id = typeof bot === 'string' ? bot : bot.id;\n        const event = calcShowInputForTag(id, trimTag(tag), options);\n        return addAction(event);\n    }\n\n    /**\n     * Shows an input box. Returns a promise that resolves with the new value.\n     *\n     * @param currentValue The value that the input box should be prefilled with.\n     * @param options The options that indicate how the input box should be customized.\n     *\n     * @example\n     * // Show an input box.\n     * const result = await os.showInput({\n     *    title: \"Change the label\",\n     *    type: \"text\"\n     * });\n     */\n    function showInput(\n        currentValue?: any,\n        options?: Partial<ShowInputOptions>\n    ) {\n        const task = context.createTask();\n        const event = calcShowInput(currentValue, options, task.taskId);\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Redirects the user to the given dimension.\n     * @param dimension The dimension to go to.\n     *\n     * @example\n     * // Send the player to the \"welcome\" dimension.\n     * os.goToDimension(\"welcome\");\n     */\n    function goToDimension(dimension: string): GoToDimensionAction {\n        const event = calcGoToDimension(dimension);\n        return addAction(event);\n    }\n\n    /**\n     * Redirects the user to the given URL.\n     * @param url The URL to go to.\n     *\n     * @example\n     * // Send the player to wikipedia.\n     * os.goToURL(\"https://wikipedia.org\");\n     */\n    function goToURL(url: string): GoToURLAction {\n        const event = calcGoToURL(url);\n        return addAction(event);\n    }\n\n    /**\n     * Redirects the user to the given URL.\n     * @param url The URL to go to.\n     *\n     * @example\n     * // Open wikipedia in a new tab.\n     * os.openURL(\"https://wikipedia.org\");\n     */\n    function openURL(url: string): OpenURLAction {\n        const event = calcOpenURL(url);\n        return addAction(event);\n    }\n\n    /**\n     * Instructs CasualOS to open the built-in developer console.\n     * The dev console provides easy access to error messages and debug logs for formulas and actions.\n     */\n    function openDevConsole(): OpenConsoleAction {\n        const event = openConsole();\n        return addAction(event);\n    }\n\n    /**\n     * Shows a checkout screen that lets the user purchase something.\n     *\n     * @param options The options for the payment box.\n     *\n     * @example\n     * // Show a checkout box for 10 cookies\n     * os.checkout({\n     *   productId: '10_cookies',\n     *   title: '10 Cookies',\n     *   description: '$5.00',\n     *   processingServer: 'cookies_checkout'\n     * });\n     *\n     */\n    function checkout(options: StartCheckoutOptions): StartCheckoutAction {\n        const event = calcCheckout(options);\n        return addAction(event);\n    }\n\n    /**\n     * Play given url's audio.\n     * Returns a promise that resolves once the sound starts playing.\n     *\n     * @example\n     * // Play a cow \"moo\"\n     * os.playSound(\"https://freesound.org/data/previews/58/58277_634166-lq.mp3\");\n     */\n    function playSound(url: string) {\n        const task = context.createTask();\n        const event = calcPlaySound(url, task.taskId, task.taskId);\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Preloads the audio for the given URL.\n     * Returns a promise that resolves when the audio has finished loading.\n     * @param url The URl to preload.\n     *\n     * @example\n     * // Preload a cow \"moo\"\n     * os.bufferSound(\"https://freesound.org/data/previews/58/58277_634166-lq.mp3\");\n     */\n    function bufferSound(url: string) {\n        const task = context.createTask();\n        const event = calcBufferSound(url, task.taskId);\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Cancels the sound with the given ID.\n     * Returns a promise that resolves when the audio has been canceled.\n     * @param soundId The ID of the sound that is being canceled.\n     *\n     * @example\n     * // Play and cancel a sound\n     * const id = await os.playSound(\"https://freesound.org/data/previews/58/58277_634166-lq.mp3\");\n     * os.cancelSound(id);\n     */\n    function cancelSound(soundId: number | string | object) {\n        const task = context.createTask();\n        const id =\n            typeof soundId === 'object'\n                ? getOriginalObject(soundId).soundID\n                : soundId;\n        const event = calcCancelSound(id, task.taskId);\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Determines whether the player has the given bot in their miniGridPortal.\n     * @param bots The bot or bots to check.\n     */\n    function hasBotInMiniPortal(bots: Bot | Bot[]): boolean {\n        if (!Array.isArray(bots)) {\n            bots = [bots];\n        }\n        let miniGridPortal = getMiniPortalDimension();\n        if (!hasValue(miniGridPortal)) {\n            return false;\n        }\n        return every(bots, (f) => getTag(f, miniGridPortal) === true);\n    }\n\n    /**\n     * Shares some information via the device's social sharing functionality.\n     * @param options The options.\n     */\n    function share(options: ShareOptions): Promise<void> {\n        const task = context.createTask();\n        const event = calcShare(options, task.taskId);\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Closes the circle wipe transition effect.\n     * @param options The options that should be used for the effect.\n     */\n    function closeCircleWipe(\n        options?: Partial<OpenCircleWipeOptions>\n    ): Promise<void> {\n        const task = context.createTask();\n        const event = circleWipe(\n            false,\n            {\n                color: options?.color || 'black',\n                duration: options?.duration || 1,\n            },\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Opens the circle wipe transition effect.\n     * @param options The options that should be used for the effect.\n     */\n    function openCircleWipe(\n        options?: Partial<OpenCircleWipeOptions>\n    ): Promise<void> {\n        const task = context.createTask();\n        const event = circleWipe(\n            true,\n            {\n                color: options?.color || 'black',\n                duration: options?.duration || 1,\n            },\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Adds the given list of snap targets to the current drag operation.\n     * @param targets The list of targets to add.\n     */\n    function addDropSnap(...targets: SnapTarget[]): AddDropSnapTargetsAction {\n        return addAction(calcAddDropSnap(null, targets));\n    }\n\n    /**\n     * Adds the given list of snap targets for when the specified bot is being dropped on.\n     * @param bot The bot.\n     * @param targets The targets that should be enabled when the bot is being dropped on.\n     */\n    function addBotDropSnap(\n        bot: RuntimeBot | string,\n        ...targets: SnapTarget[]\n    ): AddDropSnapTargetsAction {\n        return addAction(calcAddDropSnap(getID(bot), targets));\n    }\n\n    /**\n     * Adds the given list of grids to the current drag operation.\n     * @param targets The list of grids to add.\n     */\n    function addDropGrid(\n        ...targets: SnapGridTarget[]\n    ): AddDropGridTargetsAction {\n        return addAction(calcAddDropGrid(null, mapSnapGridTargets(targets)));\n    }\n\n    /**\n     * Adds the given list of grids to the current drag operation for when the specified bot is being dropped on.\n     * @param bot The bot.\n     * @param targets The list of grids to add.\n     */\n    function addBotDropGrid(\n        bot: Bot | string,\n        ...targets: SnapGridTarget[]\n    ): AddDropGridTargetsAction {\n        return addAction(\n            calcAddDropGrid(getID(bot), mapSnapGridTargets(targets))\n        );\n    }\n\n    function mapSnapGridTargets(targets: SnapGridTarget[]): SnapGrid[] {\n        return targets.map((t) => ({\n            position: t.position,\n            rotation: t.rotation,\n            bounds: t.bounds,\n            portalBotId: hasValue(t.portalBot) ? getID(t.portalBot) : undefined,\n            portalTag: t.portalTag,\n            priority: t.priority,\n            showGrid: t.showGrid,\n        }));\n    }\n\n    /**\n     * Enables custom dragging for the current drag operation.\n     * This will disable the built-in logic that moves the bot(s) and\n     * enables the \"onDragging\" and \"onAnyBotDragging\" listen tags.\n     */\n    function enableCustomDragging(): EnableCustomDraggingAction {\n        return addAction(calcEnableCustomDragging());\n    }\n\n    /**\n     * Logs the given data.\n     * @param args The data that should be logged.\n     */\n    function log(...args: any[]) {\n        console.log(...args);\n    }\n\n    /**\n     * Gets the geolocation of the device.\n     * Returns a promise that resolves with the location.\n     */\n    function getGeolocation(): Promise<Geolocation> {\n        const task = context.createTask();\n        const event = calcGetGeolocation(task.taskId);\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Specifies that the given prefix should be interpreted as code.\n     * @param prefix The prefix that code tags should start with.\n     * @param options The options for the prefix.\n     */\n    function registerPrefix(\n        prefix: string,\n        options: RegisterPrefixOptions = {}\n    ): Promise<void> {\n        if (typeof prefix !== 'string') {\n            throw new Error('A prefix must be provided.');\n        }\n\n        const task = context.createTask();\n        const event = calcRegisterPrefix(\n            prefix,\n            {\n                language: options?.language || 'javascript',\n            },\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Registers a custom portal for the given bot with the given options.\n     * @param portalId The ID of the portal.\n     * @param bot The bot that should be used to render the portal.\n     */\n    function registerApp(portalId: string, bot: Bot | string): Promise<void> {\n        const task = context.createTask();\n        const event = registerCustomApp(portalId, getID(bot), task.taskId);\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Unregisters a custom portal for the given bot with the given options.\n     * @param portalId The ID of the portal.\n     */\n    function unregisterApp(portalId: string): Promise<void> {\n        const task = context.createTask();\n        const event = unregisterCustomApp(portalId, task.taskId);\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Sets the output of the given portal.\n     * @param portalId The ID of the portal.\n     * @param output The output that the portal should display.\n     */\n    function setAppContent(portalId: string, output: any): SetAppOutputAction {\n        const event = setAppOutput(portalId, output);\n        return addAction(event);\n    }\n\n    /**\n     * Requests an Auth Bot for the current session.\n     */\n    async function requestAuthBot(): Promise<Bot> {\n        const data = await requestAuthData();\n\n        if (!data) {\n            return null;\n        }\n\n        let bot = getBot('id', data.userId);\n\n        if (!bot) {\n            bot = context.createBot(\n                createBot(\n                    data.userId,\n                    {\n                        avatarAddress: data.avatarUrl,\n                        avatarPortraitAddress: data.avatarPortraitUrl,\n                        name: data.name,\n                    },\n                    TEMPORARY_BOT_PARTITION_ID\n                )\n            );\n        }\n\n        await defineGlobalBot('auth', bot.id);\n        return bot;\n    }\n\n    function requestAuthData(): Promise<AuthData> {\n        const task = context.createTask();\n        const event = calcRequestAuthData(task.taskId);\n        return addAsyncAction(task, event);\n    }\n\n    function defineGlobalBot(name: string, botId: string): Promise<void> {\n        const task = context.createTask();\n        const event = calcDefineGlobalBot(name, botId, task.taskId);\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Gets an access key for the given public record.\n     * @param name The name of the record.\n     */\n    function getPublicRecordKey(\n        name: string\n    ): Promise<CreatePublicRecordKeyResult> {\n        const task = context.createTask();\n        const event = calcGetPublicRecordKey(name, 'subjectfull', task.taskId);\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Gets a subjectless access key for the given public record.\n     * @param name The name of the record.\n     */\n    function getSubjectlessPublicRecordKey(\n        name: string\n    ): Promise<CreatePublicRecordKeyResult> {\n        const task = context.createTask();\n        const event = calcGetPublicRecordKey(name, 'subjectless', task.taskId);\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Determines if the given value is a record key.\n     * @param key The value to check.\n     */\n    function isRecordKey(key: unknown): boolean {\n        return calcIsRecordKey(key);\n    }\n\n    /**\n     * Records the given data to the given address inside the record for the given record key.\n     * @param recordKey The key that should be used to access the record.\n     * @param address The address that the data should be stored at inside the record.\n     * @param data The data that should be stored.\n     * @param endpointOrOptions The options that should be used. Optional.\n     */\n    function recordData(\n        recordKey: string,\n        address: string,\n        data: any,\n        endpointOrOptions?: string | DataRecordOptions\n    ) {\n        return baseRecordData(\n            recordKey,\n            address,\n            data,\n            false,\n            endpointOrOptions\n        );\n    }\n\n    /**\n     * Records the given data to the given address inside the record for the given record key.\n     * Requires manual approval in order to read, write, or erase this data.\n     *\n     * @param recordKey The key that should be used to access the record.\n     * @param address The address that the data should be stored at inside the record.\n     * @param data The data that should be stored.\n     * @param endpointOrOptions The options that should be used. Optional.\n     */\n    function recordManualApprovalData(\n        recordKey: string,\n        address: string,\n        data: any,\n        endpointOrOptions?: string | DataRecordOptions\n    ) {\n        return baseRecordData(\n            recordKey,\n            address,\n            data,\n            true,\n            endpointOrOptions\n        );\n    }\n\n    /**\n     * Records the given data to the given address inside the record for the given record key.\n     * @param recordKey The key that should be used to access the record.\n     * @param address The address that the data should be stored at inside the record.\n     * @param data The data that should be stored.\n     * @param endpointOrOptions The options that should be used. Optional.\n     */\n    function baseRecordData(\n        recordKey: string,\n        address: string,\n        data: any,\n        requiresApproval: boolean,\n        endpointOrOptions: string | DataRecordOptions = null\n    ): Promise<RecordDataResult> {\n        const task = context.createTask();\n        let options: DataRecordOptions = {};\n        if (hasValue(endpointOrOptions)) {\n            if (typeof endpointOrOptions === 'string') {\n                options.endpoint = endpointOrOptions;\n            } else {\n                options = endpointOrOptions;\n            }\n        }\n        const event = calcRecordData(\n            recordKey,\n            address,\n            convertToCopiableValue(data),\n            requiresApproval,\n            options,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Gets the data stored in the given record at the given address.\n     * @param recordKeyOrName The record that the data should be retrieved from.\n     * @param address The address that the data is stored at.\n     * @param endpoint The records endpoint that should be queried. Optional.\n     */\n    function getData(\n        recordKeyOrName: string,\n        address: string,\n        endpoint: string = null\n    ): Promise<GetDataResult> {\n        return baseGetData(recordKeyOrName, address, false, endpoint);\n    }\n\n    /**\n     * Gets the data stored in the given record at the given address.\n     * @param recordKeyOrName The record that the data should be retrieved from.\n     * @param address The address that the data is stored at.\n     * @param endpoint The records endpoint that should be queried. Optional.\n     */\n    function getManualApprovalData(\n        recordKeyOrName: string,\n        address: string,\n        endpoint: string = null\n    ): Promise<GetDataResult> {\n        return baseGetData(recordKeyOrName, address, true, endpoint);\n    }\n\n    /**\n     * Gets the data stored in the given record at the given address.\n     * @param recordKeyOrName The record that the data should be retrieved from.\n     * @param address The address that the data is stored at.\n     * @param endpoint The records endpoint that should be queried. Optional.\n     */\n    function baseGetData(\n        recordKeyOrName: string,\n        address: string,\n        requiresApproval: boolean,\n        endpoint: string\n    ): Promise<GetDataResult> {\n        let recordName = isRecordKey(recordKeyOrName)\n            ? parseRecordKey(recordKeyOrName)[0]\n            : recordKeyOrName;\n        let options: RecordActionOptions = {};\n        if (hasValue(endpoint)) {\n            options.endpoint = endpoint;\n        }\n        const task = context.createTask();\n        const event = getRecordData(\n            recordName,\n            address,\n            requiresApproval,\n            options,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Lists the data stored in the given record starting with the given address.\n     * @param recordKeyOrName The record that the data should be retrieved from.\n     * @param startingAddress The address that the list should start with.\n     * @param endpoint The records endpoint that should be queried. Optional.\n     */\n    function listData(\n        recordKeyOrName: string,\n        startingAddress: string = null,\n        endpoint: string = null\n    ): Promise<ListDataResult> {\n        let recordName = isRecordKey(recordKeyOrName)\n            ? parseRecordKey(recordKeyOrName)[0]\n            : recordKeyOrName;\n        let options: RecordActionOptions = {};\n        if (hasValue(endpoint)) {\n            options.endpoint = endpoint;\n        }\n        const task = context.createTask();\n        const event = listDataRecord(\n            recordName,\n            startingAddress,\n            options,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Erases the data stored in the given record at the given address.\n     * @param recordKey The key that should be used to access the record.\n     * @param address The address that the data should be erased from.\n     * @param endpoint The records endpoint that should be queried. Optional.\n     */\n    function eraseData(\n        recordKey: string,\n        address: string,\n        endpoint: string = null\n    ): Promise<EraseDataResult> {\n        return baseEraseData(recordKey, address, false, endpoint);\n    }\n\n    /**\n     * Erases the data stored in the given record at the given address.\n     *\n     * @param recordKey The key that should be used to access the record.\n     * @param address The address that the data should be erased from.\n     * @param endpoint The records endpoint that should be queried. Optional.\n     */\n    function eraseManualApprovalData(\n        recordKey: string,\n        address: string,\n        endpoint: string = null\n    ): Promise<EraseDataResult> {\n        return baseEraseData(recordKey, address, true, endpoint);\n    }\n\n    /**\n     * Erases the data stored in the given record at the given address.\n     * @param recordKey The key that should be used to access the record.\n     * @param address The address that the data should be erased from.\n     * @param endpoint The records endpoint that should be queried. Optional.\n     */\n    function baseEraseData(\n        recordKey: string,\n        address: string,\n        requiresApproval: boolean,\n        endpoint: string = null\n    ): Promise<EraseDataResult> {\n        if (!hasValue(recordKey)) {\n            throw new Error('A recordKey must be provided.');\n        } else if (typeof recordKey !== 'string') {\n            throw new Error('recordKey must be a string.');\n        }\n\n        if (!hasValue(address)) {\n            throw new Error('A address must be provided.');\n        } else if (typeof address !== 'string') {\n            throw new Error('address must be a string.');\n        }\n        let options: RecordActionOptions = {};\n        if (hasValue(endpoint)) {\n            options.endpoint = endpoint;\n        }\n\n        const task = context.createTask();\n        const event = eraseRecordData(\n            recordKey,\n            address,\n            requiresApproval,\n            options,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Records the given data as a file.\n     * @param recordKey The record that the file should be recorded in.\n     * @param data The data that should be recorded.\n     * @param options The options that should be used to record the file.\n     * @param endpoint The records endpoint that should be queried. Optional.\n     */\n    function recordFile(\n        recordKey: string,\n        data: any,\n        options?: RecordFileOptions,\n        endpoint: string = null\n    ): Promise<RecordFileApiResult> {\n        if (!hasValue(recordKey)) {\n            throw new Error('A recordKey must be provided.');\n        } else if (typeof recordKey !== 'string') {\n            throw new Error('recordKey must be a string.');\n        }\n\n        if (!hasValue(data)) {\n            throw new Error('data must be provided.');\n        }\n\n        let recordOptions: RecordActionOptions = {};\n        if (hasValue(endpoint)) {\n            recordOptions.endpoint = endpoint;\n        }\n\n        const task = context.createTask();\n        const event = calcRecordFile(\n            recordKey,\n            convertToCopiableValue(data),\n            options?.description,\n            options?.mimeType,\n            recordOptions,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Gets the data stored in the given file.\n     * @param result The successful result of a os.recordFile() call.\n     */\n    function getFile(result: RecordFileApiSuccess): Promise<any>;\n    /**\n     * Gets the data stored in the given file.\n     * @param url The URL that the file is stored at.\n     */\n    function getFile(url: string): Promise<any>;\n    /**\n     * Gets the data stored in the given file.\n     * @param urlOrRecordFileResult The URL or the successful result of the record file operation.\n     */\n    function getFile(\n        urlOrRecordFileResult: string | RecordFileApiSuccess\n    ): Promise<any> {\n        if (!hasValue(urlOrRecordFileResult)) {\n            throw new Error(\n                'A url or successful os.recordFile() result must be provided.'\n            );\n        }\n\n        let url: string;\n        if (typeof urlOrRecordFileResult === 'string') {\n            url = urlOrRecordFileResult;\n        } else {\n            if (!urlOrRecordFileResult.success) {\n                throw new Error(\n                    'The result must be a successful os.recordFile() result.'\n                );\n            }\n            url = urlOrRecordFileResult.url;\n        }\n\n        let promise = webGet(url);\n        let action: any = (promise as any)[ORIGINAL_OBJECT];\n\n        let final = promise.then((result) => {\n            return result.data;\n        });\n        (final as any)[ORIGINAL_OBJECT] = action;\n        return final;\n    }\n\n    /**\n     * Deletes the specified file using the given record key.\n     * @param recordKey The key that should be used to delete the file.\n     * @param result The successful result of a os.recordFile() call.\n     * @param endpoint The records endpoint that should be queried. Optional.\n     */\n    function eraseFile(\n        recordKey: string,\n        result: RecordFileApiSuccess,\n        endpoint?: string\n    ): Promise<EraseFileResult>;\n    /**\n     * Deletes the specified file using the given record key.\n     * @param recordKey The key that should be used to delete the file.\n     * @param url The URL that the file is stored at.\n     * @param endpoint The records endpoint that should be queried. Optional.\n     */\n    function eraseFile(\n        recordKey: string,\n        url: string,\n        endpoint?: string\n    ): Promise<EraseFileResult>;\n    /**\n     * Deletes the specified file using the given record key.\n     * @param recordKey The key that should be used to delete the file.\n     * @param urlOrRecordFileResult The URL or the successful result of the record file operation.\n     * @param endpoint The records endpoint that should be queried. Optional.\n     */\n    function eraseFile(\n        recordKey: string,\n        fileUrlOrRecordFileResult: string | RecordFileApiSuccess,\n        endpoint: string = null\n    ): Promise<EraseFileResult> {\n        if (!hasValue(recordKey)) {\n            throw new Error('A recordKey must be provided.');\n        } else if (typeof recordKey !== 'string') {\n            throw new Error('recordKey must be a string.');\n        }\n\n        if (!hasValue(fileUrlOrRecordFileResult)) {\n            throw new Error(\n                'A url or successful os.recordFile() result must be provided.'\n            );\n        }\n\n        let url: string;\n        if (typeof fileUrlOrRecordFileResult === 'string') {\n            url = fileUrlOrRecordFileResult;\n        } else {\n            if (!fileUrlOrRecordFileResult.success) {\n                throw new Error(\n                    'The result must be a successful os.recordFile() result.'\n                );\n            }\n            url = fileUrlOrRecordFileResult.url;\n        }\n\n        let options: RecordActionOptions = {};\n        if (hasValue(endpoint)) {\n            options.endpoint = endpoint;\n        }\n\n        const task = context.createTask();\n        const event = calcEraseFile(recordKey, url, options, task.taskId);\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Records that the given event occurred.\n     * @param recordKey The key that should be used to record the event.\n     * @param eventName The name of the event.\n     * @param endpoint The records endpoint that should be queried. Optional.\n     */\n    function recordEvent(\n        recordKey: string,\n        eventName: string,\n        endpoint: string = null\n    ): Promise<AddCountResult> {\n        if (!hasValue(recordKey)) {\n            throw new Error('A recordKey must be provided.');\n        } else if (typeof recordKey !== 'string') {\n            throw new Error('recordKey must be a string.');\n        }\n\n        if (!hasValue(eventName)) {\n            throw new Error('A eventName must be provided.');\n        } else if (typeof eventName !== 'string') {\n            throw new Error('eventName must be a string.');\n        }\n\n        let options: RecordActionOptions = {};\n        if (hasValue(endpoint)) {\n            options.endpoint = endpoint;\n        }\n\n        const task = context.createTask();\n        const event = calcRecordEvent(\n            recordKey,\n            eventName,\n            1,\n            options,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Gets the number of times that the given event has been recorded.\n     * @param recordNameOrKey The name of the record.\n     * @param eventName The name of the event.\n     * @param endpoint The records endpoint that should be queried. Optional.\n     */\n    function countEvents(\n        recordNameOrKey: string,\n        eventName: string,\n        endpoint: string = null\n    ): Promise<GetCountResult> {\n        if (!hasValue(recordNameOrKey)) {\n            throw new Error('A recordNameOrKey must be provided.');\n        } else if (typeof recordNameOrKey !== 'string') {\n            throw new Error('recordNameOrKey must be a string.');\n        }\n\n        if (!hasValue(eventName)) {\n            throw new Error('A eventName must be provided.');\n        } else if (typeof eventName !== 'string') {\n            throw new Error('eventName must be a string.');\n        }\n\n        let recordName = isRecordKey(recordNameOrKey)\n            ? parseRecordKey(recordNameOrKey)[0]\n            : recordNameOrKey;\n\n        let options: RecordActionOptions = {};\n        if (hasValue(endpoint)) {\n            options.endpoint = endpoint;\n        }\n\n        const task = context.createTask();\n        const event = calcGetEventCount(\n            recordName,\n            eventName,\n            options,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Converts the given geolocation to a what3words (https://what3words.com/) address.\n     * @param location The latitude and longitude that should be converted to a 3 word address.\n     */\n    function convertGeolocationToWhat3Words(\n        location: ConvertGeolocationToWhat3WordsOptions\n    ): Promise<string> {\n        const task = context.createTask();\n        const event = calcConvertGeolocationToWhat3Words(location, task.taskId);\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Casts a 3D ray into the specified portal from the camera and returns information about the bots that were hit.\n     * @param portal The portal that should be tested.\n     * @param viewportCoordinates The 2D camera viewport coordinates that the ray should be sent from.\n     */\n    function raycastFromCamera(\n        portal: 'grid' | 'miniGrid' | 'map' | 'miniMap',\n        viewportCoordinates: Vector2\n    ): Promise<RaycastResult> {\n        const task = context.createTask();\n        const event = calcRaycastFromCamera(\n            portal,\n            { x: viewportCoordinates.x, y: viewportCoordinates.y },\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Casts a 3D ray into the specified portal using the given origin and direction and returns information about the bots that were hit.\n     * @param portal The portal that should be tested.\n     * @param origin The 3D point that the ray should start at.\n     * @param direction The 3D direction that the ray should travel in.\n     */\n    function raycast(\n        portal: 'grid' | 'miniGrid' | 'map' | 'miniMap',\n        origin: Vector3,\n        direction: Vector3\n    ): Promise<RaycastResult> {\n        const task = context.createTask();\n        const normalized = direction.normalize();\n        const event = calcRaycastInPortal(\n            portal,\n            {\n                x: origin.x,\n                y: origin.y,\n                z: origin.z,\n            },\n            {\n                x: normalized.x,\n                y: normalized.y,\n                z: normalized.z,\n            },\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Calculates the 3D ray that would be projected into the given portal based on the specified camera viewport coordinates.\n     * @param portal The portal that the ray should be projected into.\n     * @param viewportCoordinates The 2D camera viewport coordinates that the ray should be sent from.\n     */\n    function calculateRayFromCamera(\n        portal: 'grid' | 'miniGrid' | 'map' | 'miniMap',\n        viewportCoordinates: Vector2\n    ): Promise<RaycastRay> {\n        const task = context.createTask();\n        const event = calcCalculateRayFromCamera(\n            portal,\n            { x: viewportCoordinates.x, y: viewportCoordinates.y },\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Requests that the given address be pre-cached so that it is available for use on a bot.\n     * @param address The address that should be cached.\n     */\n    function bufferFormAddressGLTF(address: string): Promise<void> {\n        const task = context.createTask();\n        const event = bufferFormAddressGltf(address, task.taskId);\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Starts the given animation on the given bot(s).\n     * @param botOrBots The bot or list of bots that the animation should be started on.\n     * @param nameOrIndex The name of the animation.\n     * @param options The options for the animation.\n     */\n    function startFormAnimation(\n        botOrBots: Bot | string | (Bot | string)[],\n        nameOrIndex: string | number,\n        options?: StartFormAnimationOptions\n    ): Promise<void> {\n        const task = context.createTask();\n\n        const botIds = Array.isArray(botOrBots)\n            ? botOrBots.map((b) => (isBot(b) ? b.id : b))\n            : [isBot(botOrBots) ? botOrBots.id : botOrBots];\n\n        const event = calcStartFormAnimation(\n            botIds,\n            nameOrIndex,\n            options ?? {},\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Stops the animation on the given bot(s).\n     * Returns a promise that resolves when the animations have been stopped.\n     * @param botOrBots The bot or list of bots that the animation(s) should be stopped on.\n     * @param options The options that should be used.\n     */\n    function stopFormAnimation(\n        botOrBots: Bot | string | (Bot | string)[],\n        options?: StopFormAnimationOptions\n    ): Promise<void> {\n        const task = context.createTask();\n\n        const botIds = Array.isArray(botOrBots)\n            ? botOrBots.map((b) => (isBot(b) ? b.id : b))\n            : [isBot(botOrBots) ? botOrBots.id : botOrBots];\n\n        const event = calcStopFormAnimation(botIds, options ?? {}, task.taskId);\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Gets the list of animations that are included in the given the form or bot.\n     * @param botOrAddress The bot, bot ID, or address that the animations should be retrieved from.\n     */\n    function listFormAnimations(\n        botOrAddress: Bot | string\n    ): Promise<FormAnimationData[]> {\n        let address: string;\n        let bot = isBot(botOrAddress)\n            ? botOrAddress\n            : context.state[botOrAddress];\n        if (bot) {\n            address =\n                calculateStringTagValue(\n                    null,\n                    bot,\n                    'auxFormAnimationAddress',\n                    null\n                ) ?? calculateStringTagValue(null, bot, 'auxFormAddress', null);\n        } else if (typeof botOrAddress === 'string') {\n            address = botOrAddress;\n        }\n\n        if (!hasValue(address)) {\n            return Promise.resolve([]);\n        }\n\n        const task = context.createTask();\n        const event = calcListFormAnimations(address, task.taskId);\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Sends an event to the server to setup a new instance if it does not exist.\n     * @param inst The instance.\n     * @param botOrMod The bot or mod that should be cloned into the new inst.\n     */\n    function setupServer(inst: string, botOrMod?: Mod) {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            calcSetupServer(inst, convertToCopiableValue(botOrMod)),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Sends an event to the server to initialize rpio with provided settings\n     * @param options An object containing values to initilize with.\n     *\n     * @example\n     * // Initialize with default settings\n     * server.rpioInit({\n     *   gpiomem: true,\n     *   mapping: 'physical',\n     *   mock: undefined,\n     *   close_on_exit: false\n     * });\n     */\n    function rpioInit(options: object) {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            rpioInitPin(options),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Shuts down rpio, unmaps, and clears everything.\n     */\n    function rpioExit() {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            rpioExitPin(),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Sends an event to the server to open a pin as input or output.\n     * @param pin The physical pin number.\n     * @param mode The mode of the pin.\n     * @param options The state you want to initialize your pin as.\n     */\n    function rpioOpen(\n        pin: number,\n        mode: 'INPUT' | 'OUTPUT' | 'PWM',\n        options?: 'HIGH' | 'LOW' | 'PULL_OFF' | 'PULL_DOWN' | 'PULL_UP'\n    ) {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            rpioOpenPin(pin, mode, options),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Sends an event to the server to change the mode of a pin as input or output.\n     * @param pin The physical pin number.\n     * @param mode The mode of the pin.\n     * @param options The state you want to initialize your pin as.\n     */\n    function rpioMode(\n        pin: number,\n        mode: 'INPUT' | 'OUTPUT' | 'PWM',\n        options?: 'HIGH' | 'LOW' | 'PULL_OFF' | 'PULL_DOWN' | 'PULL_UP'\n    ) {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            rpioModePin(pin, mode, options),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Sends an event to the server to read the value of a pin.\n     * @param pin The physical BCM pin number.\n     */\n    function rpioRead(pin: number) {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            rpioReadPin(pin),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Reads a pin's current buffer.\n     * @param pin The physical BCM Pin on the server.\n     * @param length The length of the buffer.\n     */\n    function rpioReadSequence(pin: number, length: number) {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            rpioReadSequencePin(pin, length),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Sends an event to the server to write to a pin and set it as HIGH or LOW.\n     * @param pin The physical pin number.\n     * @param value The mode of the pin.\n     */\n    function rpioWrite(pin: number, value: 'HIGH' | 'LOW') {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            rpioWritePin(pin, value),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Writes to a pin's current buffer.\n     * @param pin The physical BCM Pin on the server.\n     * @param buffer The buffer to write to  the pin.\n     */\n    function rpioWriteSequence(pin: number, buffer: number[]) {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            rpioWriteSequencePin(pin, buffer),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Read the current state of the GPIO pad control for the specified GPIO group.\n     * On current models of Raspberry Pi there are three groups.\n     *\n     * 'PAD_GROUP_0_27' is GPIO0 - GPIO27. Use this for the main GPIO header.\n     * 'PAD_GROUP_28_45' is GPIO28 - GPIO45. Use this to configure the P5 header.\n     * 'PAD_GROUP_46_53' is GPIO46 - GPIO53. Internal, you probably won't need this.\n     *\n     * @param group The GPIO group to be read.\n     * @param bitmask The bitmask you want to check.\n     */\n    function rpioReadpad(\n        group: 'PAD_GROUP_0_27' | 'PAD_GROUP_28_45' | 'PAD_GROUP_46_53',\n        bitmask: 'slew' | 'hysteresis' | 'current'\n    ) {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            rpioReadpadPin(group, bitmask),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Write `control` settings to the pad control for `group`.\n     *\n     * 'PAD_GROUP_0_27' is GPIO0 - GPIO27. Use this for the main GPIO header.\n     * 'PAD_GROUP_28_45' is GPIO28 - GPIO45. Use this to configure the P5 header.\n     * 'PAD_GROUP_46_53' is GPIO46 - GPIO53. Internal, you probably won't need this.\n     *\n     * @param group The GPIO group to be read.\n     * @param slew Slew rate unlimited if set to true.\n     * @param hysteresis Hysteresis is enabled if set to true.\n     * @param current Drive current set in mA. Must be an even number 2-16.\n     */\n    function rpioWritepad(\n        group: 'PAD_GROUP_0_27' | 'PAD_GROUP_28_45' | 'PAD_GROUP_46_53',\n        slew?: boolean,\n        hysteresis?: boolean,\n        current?: 2 | 4 | 6 | 8 | 10 | 12 | 14 | 16\n    ) {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            rpioWritepadPin(group, slew, hysteresis, current),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Configure the pin's internal pullup or pulldown resistors.\n     * @param pin The pin that you want to use.\n     * @param state Configure the pin's resistors as: 'PULL_OFF', 'PULL_DOWN' or 'PULL_UP'\n     */\n    function rpioPud(pin: number, state: 'PULL_OFF' | 'PULL_DOWN' | 'PULL_UP') {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            rpioPudPin(pin, state),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Watch `pin` for changes and execute the callback `cb()` on events.\n     * @param pin The pin that you want to use.\n     * @param cb The callback executed on events.\n     * @param options Optional. Used to watch for specific events.\n     */\n    function rpioPoll(\n        pin: number,\n        cb: any,\n        options?: 'POLL_LOW' | 'POLL_HIGH' | 'POLL_BOTH'\n    ) {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            rpioPollPin(pin, cb, options),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Sends an event to the server to close a pin and what state to leave it in.\n     * @param pin The physical pin number.\n     * @param options The state to leave the pin in upon closing.\n     */\n    function rpioClose(pin: number, options: 'PIN_RESET' | 'PIN_PRESERVE') {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            rpioClosePin(pin, options),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Initializes i2c for use.\n     */\n    function rpioI2CBegin() {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            rpioI2CBeginPin(),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Configure the slave address.\n     * @param address The slave address to set.\n     */\n    function rpioI2CSetSlaveAddress(address: number) {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            rpioI2CSetSlaveAddressPin(address),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Set the baud rate. Directly set the speed in hertz.\n     * @param rate The i2c refresh rate in hertz.\n     */\n    function rpioI2CSetBaudRate(rate: number) {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            rpioI2CSetBaudRatePin(rate),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Set the baud rate. Set it based on a divisor of the base 250MHz rate.\n     * @param rate The i2c refresh rate based on a divisor of the base 250MHz rate.\n     */\n    function rpioI2CSetClockDivider(rate: number) {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            rpioI2CSetClockDividerPin(rate),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Read from the i2c slave.\n     * @param rx Buffer to read.\n     * @param length Optional. Length of the buffer to read.\n     */\n    function rpioI2CRead(rx: number[], length?: number) {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            rpioI2CReadPin(rx, length),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Write to the i2c slave.\n     * @param tx Buffer to write.\n     * @param length Optional. Length of the buffer to write.\n     */\n    function rpioI2CWrite(tx: number[], length?: number) {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            rpioI2CWritePin(tx, length),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     *\n     */\n    // function rpioI2CReadRegisterRestart() {\n    //     const task = context.createTask(true, true);\n    //     const event = calcRemote(\n    //         rpioI2CReadRegisterRestartPin(),\n    //         undefined,\n    //         undefined,\n    //         task.taskId\n    //     );\n    //     return addAsyncAction(task, event);\n    // }\n\n    /**\n     *\n     */\n    // function rpioI2CWriteReadRestart() {\n    //     const task = context.createTask(true, true);\n    //     const event = calcRemote(\n    //         rpioI2CWriteReadRestartPin(),\n    //         undefined,\n    //         undefined,\n    //         task.taskId\n    //     );\n    //     return addAsyncAction(task, event);\n    // }\n\n    /**\n     * Turn off the ic interface and return the pins to GPIO.\n     */\n    function rpioI2CEnd() {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            rpioI2CEndPin(),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * This is a power-of-two divisor of the base 19.2MHz rate, with a maximum value of 4096 (4.6875kHz).\n     * @param rate The PWM refresh rate.\n     */\n    function rpioPWMSetClockDivider(rate: number) {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            rpioPWMSetClockDividerPin(rate),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * This determines the maximum pulse width.\n     * @param pin The physical pin number.\n     * @param range The PWM range for a pin.\n     */\n    function rpioPWMSetRange(pin: number, range: number) {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            rpioPWMSetRangePin(pin, range),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Set the width for a given pin.\n     * @param pin The physical pin number.\n     * @param width The PWM width for a pin.\n     */\n    function rpioPWMSetData(pin: number, width: number) {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            rpioPWMSetDataPin(pin, width),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Initiate SPI mode.\n     */\n    function rpioSPIBegin() {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            rpioSPIBeginPin(),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Choose which of the chip select / chip enable pins to control.\n     *  Value | Pin\n     *  ------|---------------------\n     *    0   | SPI_CE0 (24 / GPIO8)\n     *    1   | SPI_CE1 (26 / GPIO7)\n     *    2   | Both\n     * @param value The value correlating to pin(s) to control.\n     */\n    function rpioSPIChipSelect(value: 0 | 1 | 2) {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            rpioSPIChipSelectPin(value),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * If your device's CE pin is active high, use this to change the polarity.\n     * *  Value | Pin\n     *  ------|---------------------\n     *    0   | SPI_CE0 (24 / GPIO8)\n     *    1   | SPI_CE1 (26 / GPIO7)\n     *    2   | Both\n     * @param value The value correlating to pin(s) to control.\n     * @param polarity Set the polarity it activates on. HIGH or LOW\n     */\n    function rpioSPISetCSPolarity(value: 0 | 1 | 2, polarity: 'HIGH' | 'LOW') {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            rpioSPISetCSPolarityPin(value, polarity),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Set the SPI clock speed.\n     * @param rate It is an even divisor of the base 250MHz rate ranging between 0 and 65536.\n     */\n    function rpioSPISetClockDivider(rate: number) {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            rpioSPISetClockDividerPin(rate),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Set the SPI Data Mode.\n     *  Mode | CPOL | CPHA\n     *  -----|------|-----\n     *    0  |  0   |  0\n     *    1  |  0   |  1\n     *    2  |  1   |  0\n     *    3  |  1   |  1\n     * @param mode The SPI Data Mode.\n     */\n    function rpioSPISetDataMode(mode: 0 | 1 | 2 | 3) {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            rpioSPISetDataModePin(mode),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     *\n     */\n    function rpioSPITransfer(tx: number[]) {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            rpioSPITransferPin(tx),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     *\n     */\n    function rpioSPIWrite(tx: number[]) {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            rpioSPIWritePin(tx),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Release the pins back to general purpose use.\n     */\n    function rpioSPIEnd() {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            rpioSPIEndPin(),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Establish the connection to the bluetooth serial device\n     * @param name A friendly device name. Example: Brush01\n     * @param device The device path. Example: /dev/rfcomm0\n     * @param mac The device MAC address. Example: AA:BB:CC:DD:EE\n     * @param channel The device channel. Example: 1\n     * @param options\n     * {boolean} [autoOpen=true] Automatically opens the port on `nextTick`.\n     *\n     * {number=} [baudRate=9600] The baud rate of the port to be opened. This should match one of the commonly available baud rates, such as 110, 300, 1200, 2400, 4800, 9600, 14400, 19200, 38400, 57600, or 115200. Custom rates are supported best effort per platform. The device connected to the serial port is not guaranteed to support the requested baud rate, even if the port itself supports that baud rate.\n     *\n     * {number} [dataBits=8] Must be one of these: 8, 7, 6, or 5.\n     *\n     * {number} [highWaterMark=65536] The size of the read and write buffers defaults to 64k.\n     *\n     * {boolean} [lock=true] Prevent other processes from opening the port. Windows does not currently support `false`.\n     *\n     * {number} [stopBits=1] Must be one of these: 1 or 2.\n     *\n     * {string} [parity=none] Must be one of these: 'none', 'even', 'mark', 'odd', 'space'.\n     *\n     * {boolean} [rtscts=false] flow control setting\n     *\n     * {boolean} [xon=false] flow control setting\n     *\n     * {boolean} [xoff=false] flow control setting\n     *\n     * {boolean} [xany=false] flow control setting\n     *\n     * {object=} bindingOptions sets binding-specific options\n     *\n     * {Binding=} Binding The hardware access binding. `Bindings` are how Node-Serialport talks to the underlying system. Will default to the static property `Serialport.Binding`.\n     *\n     * {number} [bindingOptions.vmin=1] see [`man termios`](http://linux.die.net/man/3/termios) LinuxBinding and DarwinBinding\n     *\n     * {number} [bindingOptions.vtime=0] see [`man termios`](http://linux.die.net/man/3/termios) LinuxBinding and DarwinBinding\n     */\n    function serialConnect(\n        name: string,\n        device: string,\n        mac: string,\n        channel: number,\n        options?: object,\n        cb?: any\n    ) {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            serialConnectPin(name, device, mac, channel, options, cb),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Parses and returns the serial stream to the event tag 'onSerialData'.\n     * @param bot The id of the bot you want data streamed to. The bot needs the 'onSerialData' tag.\n     * @param name A friendly device name. Example: Brush01\n     */\n    function serialStream(bot: string, name: string) {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            serialStreamPin(bot, name),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Opens the serial connection if you set the option in serialConnect to {autoOpen: false}\n     * @param name A friendly device name. Example: Brush01\n     */\n    function serialOpen(name: string) {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            serialOpenPin(name),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Updates the SerialPort object with a new baudRate.\n     * @param name A friendly device name. Example: Brush01\n     * @param options {number=} [baudRate=9600] The baud rate of the port to be opened. This should match one of the commonly available baud rates, such as 110, 300, 1200, 2400, 4800, 9600, 14400, 19200, 38400, 57600, or 115200. Custom rates are supported best effort per platform. The device connected to the serial port is not guaranteed to support the requested baud rate, even if the port itself supports that baud rate.\n     * @param cb\n     */\n    function serialUpdate(name: string, options: object, cb?: any) {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            serialUpdatePin(name, options, cb),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Writes the provided data/command to the device\n     * @param name A friendly device name. Example: Brush01\n     * @param data The data/command to send\n     * @param encoding The encoding, if chunk is a string. Defaults to 'utf8'. Also accepts 'utf16le', 'latin1', 'ascii', 'base64', 'binary', 'ucs2', and 'hex'\n     * @param cb\n     * @param taskId The ID of the async task.\n     */\n    function serialWrite(\n        name: string,\n        data: string | number[],\n        encoding?: string,\n        cb?: any\n    ) {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            serialWritePin(name, data, encoding, cb),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Request a number of bytes from the SerialPort.\n     * @param name A friendly device name. Example: Brush01\n     * @param size Specify how many bytes of data to return, if available.\n     * @param taskId The ID of the async task.\n     */\n    function serialRead(name: string, size?: number) {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            serialReadPin(name, size),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Closes an open connection.\n     * @param name A friendly device name. Example: Brush01\n     * @param cb\n     * @param device The device path. Example: /dev/rfcomm0\n     * @param taskId The ID of the async task.\n     */\n    function serialClose(name: string, device: string, cb?: any) {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            serialClosePin(name, device, cb),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Flush discards data that has been received but not read, or written but not transmitted by the operating system.\n     * @param name A friendly device name. Example: Brush01\n     */\n    function serialFlush(name: string) {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            serialFlushPin(name),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Waits until all output data is transmitted to the serial port. After any pending write has completed, it calls `tcdrain()` or `FlushFileBuffers()` to ensure it has been written to the device.\n     * @param name A friendly device name. Example: Brush01\n     */\n    function serialDrain(name: string) {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            serialDrainPin(name),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Causes a stream in flowing mode to stop emitting 'data' events, switching out of flowing mode. Any data that becomes available remains in the internal buffer.\n     * @param name A friendly device name. Example: Brush01\n     */\n    function serialPause(name: string) {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            serialPausePin(name),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Causes an explicitly paused, Readable stream to resume emitting 'data' events, switching the stream into flowing mode.\n     * @param name A friendly device name. Example: Brush01\n     */\n    function serialResume(name: string) {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            serialResumePin(name),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Executes the given shell script on the server.\n     * @param script The shell script  that should be executed.\n     */\n    function shell(script: string): RemoteAction | RemoteAction[] {\n        return remote(calcShell(script));\n    }\n\n    /**\n     * Backs up all the AUX instances to a Github Gist.\n     * @param auth The Github Personal Access Token that should be used to grant access to your Github account. See https://help.github.com/en/articles/creating-a-personal-access-token-for-the-command-line\n     */\n    function backupToGithub(auth: string): RemoteAction | RemoteAction[] {\n        return remote(calcBackupToGithub(auth));\n    }\n\n    /**\n     * Backs up all the AUX instances to a zip bot.\n     */\n    function backupAsDownload(\n        target: SessionSelector\n    ): RemoteAction | RemoteAction[] {\n        return remote(calcBackupAsDownload(convertSessionSelector(target)));\n    }\n\n    /**\n     * Finishes the checkout process by charging the payment fee to the user.\n     *\n     * @param options The options for finishing the checkout.\n     *\n     * @example\n     * // Finish the checkout process\n     * inst.finishCheckout({\n     *   secretKey: 'YOUR_SECRET_API_KEY',\n     *   token: 'token from onCheckout',\n     *\n     *   // 1000 cents == $10.00\n     *   amount: 1000,\n     *   currency: 'usd',\n     *   description: 'Description for purchase'\n     * });\n     */\n    function finishCheckout(\n        options: FinishCheckoutOptions\n    ): FinishCheckoutAction {\n        const event = calcFinishCheckout(\n            options.secretKey,\n            options.token,\n            options.amount,\n            options.currency,\n            options.description,\n            options.extra\n        );\n        return addAction(event);\n    }\n\n    /**\n     * Saves the current state as a history mark.\n     * @param options The options that describe what information the mark should contain.\n     *\n     * @example\n     * // Bookmark the current state with a message\n     * inst.markHistory({\n     *   message: \"Save recent changes\"\n     * });\n     */\n    function markHistory(options: MarkHistoryOptions): Promise<void> {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            calcMarkHistory(options),\n            undefined,\n            false,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Loads the \"history\" space into the inst.\n     */\n    function browseHistory(): Promise<void> {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            calcBrowseHistory(),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Restores the current state to the given mark.\n     * @param mark The bot or bot ID that represents the mark that should be restored.\n     */\n    function restoreHistoryMark(mark: Bot | string): Promise<void> {\n        const id = getID(mark);\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            calcRestoreHistoryMark(id),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Restores the current state to the given mark.\n     * @param mark The bot or bot ID that represents the mark that should be restored.\n     * @param inst The inst that the mark should be restored to.\n     */\n    function restoreHistoryMarkToServer(\n        mark: Bot | string,\n        inst: string\n    ): Promise<void> {\n        const id = getID(mark);\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            calcRestoreHistoryMark(id, inst),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Loads a file from the server at the given path.\n     * @param path The path of the file.\n     * @param options The options.\n     */\n    function loadFile(path: string, options?: LoadFileOptions): Promise<any> {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            calcLoadFile({\n                path: path,\n                ...(options || {}),\n            }),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Saves a file at the given path.\n     * @param path The path.\n     * @param data The data to save.\n     * @param options The options to use.\n     */\n    function saveFile(\n        path: string,\n        data: string,\n        options?: SaveFileOptions\n    ): Promise<any> {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            calcSaveFile({\n                path: path,\n                data: data,\n                ...(options || {}),\n            }),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Gets the number of remotes that are viewing the current inst.\n     * @param inst The instance to get the statistics for. If omitted, then the current instance is used.\n     */\n    function serverRemoteCount(inst?: string): Promise<number> {\n        const task = context.createTask(true, true);\n        const actualServer = hasValue(inst) ? inst : getCurrentServer();\n        const event = calcRemote(\n            getRemoteCount(actualServer),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Gets the total number of remotes that are connected to the server.\n     */\n    function totalRemoteCount(): Promise<number> {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            getRemoteCount(),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Gets the list of instances that are on the server.\n     */\n    function servers(): Promise<string[]> {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            getServers(),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Gets the list of instances that are on the server.\n     */\n    function serverStatuses(): Promise<\n        {\n            inst: string;\n            lastUpdateTime: Date;\n        }[]\n    > {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            getServerStatuses(),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Gets the list of remote IDs that are connected to the instance.\n     */\n    function remotes(): Promise<string[]> {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            getRemotes(),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Gets the list of updates that have been applied to this inst.\n     */\n    function listInstUpdates(): Promise<InstUpdate[]> {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            calcListInstUpdates(),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Gets the inst state that was produced by the given set of updates.\n     * @param updates The updates.\n     */\n    function getInstStateFromUpdates(\n        updates: InstUpdate[]\n    ): Promise<BotsState> {\n        const task = context.createTask(true, true);\n        const event = calcRemote(\n            calcGetInstStateFromUpdates(updates),\n            undefined,\n            undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Sends the given operation to all the devices that matches the given selector.\n     * In effect, this allows users to send each other events directly without having to edit tags.\n     *\n     * Note that currently, devices will only accept events sent from the inst.\n     *\n     * @param event The event that should be executed in the remote session(s).\n     * @param selector The selector that indicates where the event should be sent. The event will be sent to all sessions that match the selector.\n     *                 For example, specifying a username means that the event will be sent to every active session that the user has open.\n     *                 If a selector is not specified, then the event is sent to the inst.\n     * @param allowBatching Whether to allow batching this remote event with other remote events. This will preserve ordering between remote events but may not preserve ordering\n     *                      with respect to other events. Defaults to true.\n     *\n     * @example\n     * // Send a toast to all sessions for the username \"bob\"\n     * remote(os.toast(\"Hello, Bob!\"), { username: \"bob\" });\n     */\n    function remote(\n        event: BotAction,\n        selector?: SessionSelector | string | (SessionSelector | string)[],\n        allowBatching?: boolean\n    ): RemoteAction | RemoteAction[] {\n        if (!event) {\n            return;\n        }\n        let actions = [];\n        let selectors = Array.isArray(selector) ? selector : [selector];\n        for (let s of selectors) {\n            const r = calcRemote(\n                event,\n                convertSessionSelector(s),\n                allowBatching\n            );\n            actions.push(addAction(r));\n        }\n\n        if (Array.isArray(selector)) {\n            return actions;\n        } else {\n            return actions[0];\n        }\n    }\n\n    /**\n     * Sends the given shout to the given remote or list of remotes.\n     * The other remotes will recieve an onRemoteWhisper event for this whisper.\n     *\n     * In effect, this allows remotes to communicate with each other by sending arbitrary events.\n     *\n     * @param remoteId The ID of the other remote or remotes to whisper to.\n     * @param name The name of the event.\n     * @param arg The optional argument to include in the whisper.\n     */\n    function remoteWhisper(\n        remoteId: string | string[],\n        name: string,\n        arg?: any\n    ): RemoteAction | RemoteAction[] {\n        return remote(action(name, null, null, arg), remoteId);\n    }\n\n    /**\n     * Sends the given shout to all remotes.\n     * The other remotes will recieve an onRemoteWhisper event for this whisper.\n     *\n     * In effect, this allows remotes to communicate with each other by sending arbitrary events.\n     *\n     * @param name The name of the event.\n     * @param arg The optional argument to include in the whisper.\n     */\n    function remoteShout(\n        name: string,\n        arg?: any\n    ): RemoteAction | RemoteAction[] {\n        return remote(action(name, null, null, arg), {\n            broadcast: true,\n        });\n    }\n\n    /**\n     * Sends an HTTP GET request for the given URL using the given options.\n     * @param url The URL to request.\n     * @param options The options to use.\n     */\n    function webGet(\n        url: string,\n        options: WebhookOptions = {}\n    ): Promise<WebhookResult> {\n        return webhook({\n            ...options,\n            method: 'GET',\n            url,\n        });\n    }\n\n    /**\n     * Sends a HTTP POST request to the given URL with the given data and options.\n     * @param url The URL that the request should be sent to.\n     * @param data The data that should be included in the request.\n     * @param options The options to use.\n     */\n    function webPost(\n        url: string,\n        data?: any,\n        options?: WebhookOptions\n    ): Promise<WebhookResult> {\n        return webhook({\n            ...options,\n            method: 'POST',\n            url,\n            data,\n        });\n    }\n\n    /**\n     * Creates a new function that is mockable based on if the context is currently mocking async actions.\n     * @param func The function to mock.\n     * @param functionName The name of the function.\n     * @returns\n     */\n    function makeMockableFunction<T>(\n        func: T,\n        functionName: string\n    ): T & MaskableFunction {\n        if (context.mockAsyncActions) {\n            let mock: any = (...args: any[]) => {\n                return context.getNextMockReturn(func, functionName, args);\n            };\n            mock.mask = (...args: any) => ({\n                returns(value: any) {\n                    context.setMockReturn(func, args, value);\n                },\n            });\n            mock[ORIGINAL_OBJECT] = func;\n            return mock;\n        } else {\n            return func as any;\n        }\n    }\n\n    /**\n     * Sends an HTTP request based on the given options.\n     * @param options The options that should be used to send the webhook.\n     */\n    function webhook(options: WebhookOptions): Promise<WebhookResult> {\n        if (options.retryCount > 0) {\n            return _retryWebhook(options);\n        } else {\n            return _webhook(options);\n        }\n    }\n\n    async function _retryWebhook(options: WebhookOptions) {\n        const retryCount = Math.min(options.retryCount, MAX_RETRY_COUNT);\n        const timeToWait = Math.max(\n            0,\n            Math.min(\n                options.retryAfterMs ?? DEFAULT_RETRY_AFTER_MS,\n                MAX_RETRY_AFTER_MS\n            )\n        );\n        const statusCodes =\n            options.retryStatusCodes ?? DEFUALT_RETRY_STATUS_CODES;\n        let retries = 0;\n        while (true) {\n            try {\n                return await _webhook(options);\n            } catch (err) {\n                if (retries >= retryCount) {\n                    throw err;\n                } else if (!statusCodes.includes(err.response?.status ?? 0)) {\n                    throw err;\n                }\n                await sleep(timeToWait);\n                retries += 1;\n            }\n        }\n    }\n\n    function _webhook(options: WebhookOptions): Promise<WebhookResult> {\n        const task = context.createTask();\n        const event = calcWebhook(\n            {\n                method: options.method,\n                url: options.url,\n                responseShout: options.responseShout,\n                data: options.data,\n                headers: options.headers,\n            },\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Creates a Universally Unique IDentifier (UUID).\n     */\n    function uuid(): string {\n        return context.uuid();\n    }\n\n    /**\n     * Sleeps for time in ms.\n     * @param time The Time to sleep in ms. 1 second is 1000 ms.\n     */\n    function sleep(time: number): Promise<void> {\n        let sleepy = new Promise<void>((resolve) => setTimeout(resolve, time));\n        return sleepy;\n    }\n\n    /**\n     * Animates the given tag. Returns a promise when the animation is finished.\n     * @param bot The bot or list of bots that should be animated.\n     * @param tag The tag that should be animated.\n     * @param options The options for the animation.\n     */\n    function animateTag(\n        bot: RuntimeBot | (RuntimeBot | string)[] | string,\n        tag: string,\n        options: AnimateTagFunctionOptions\n    ): Promise<void>;\n\n    /**\n     * Animates the given tags. Returns a promise when the animation is finished.\n     * @param bot The bot or list of bots that should be animated.\n     * @param options The options for the animation. fromValue should be an object which contains the starting tag values and toValue should be an object that contains the ending tag values.\n     */\n    function animateTag(\n        bot: RuntimeBot | (RuntimeBot | string)[] | string,\n        options: AnimateTagFunctionOptions\n    ): Promise<void>;\n    /**\n     * Animates the given tag. Returns a promise when the animation is finished.\n     * @param bot The bot or list of bots that should be animated.\n     * @param tag The tag that should be animated.\n     * @param options The options for the animation.\n     */\n    function animateTag(\n        bot: RuntimeBot | (RuntimeBot | string)[] | string,\n        tagOrOptions: string | AnimateTagFunctionOptions,\n        options?: AnimateTagFunctionOptions\n    ): Promise<void> {\n        if (Array.isArray(bot)) {\n            const bots = bot\n                .map((b) => (typeof b === 'string' ? getBot('id', b) : b))\n                .filter((b) => !!b);\n\n            const promises = bots.map((b) =>\n                animateBotTag(b, tagOrOptions, options)\n            );\n\n            const allPromises = Promise.all(promises);\n            return <Promise<void>>(<any>allPromises);\n        } else if (typeof bot === 'string') {\n            const finalBot = getBot('id', bot);\n            if (finalBot) {\n                return animateBotTag(finalBot, tagOrOptions, options);\n            } else {\n                return Promise.resolve();\n            }\n        } else {\n            return animateBotTag(bot, tagOrOptions, options);\n        }\n    }\n\n    function animateBotTag(\n        bot: RuntimeBot,\n        tagOrOptions: string | AnimateTagFunctionOptions,\n        options: AnimateTagFunctionOptions\n    ): Promise<void> {\n        if (!hasValue(bot)) {\n            return Promise.reject(\n                new Error('animateTag() cannot accept null bots')\n            );\n        }\n        if (typeof tagOrOptions === 'string') {\n            return animateSingleTag(bot, tagOrOptions, options);\n        } else {\n            return animateMultipleTags(bot, tagOrOptions);\n        }\n    }\n\n    async function animateMultipleTags(\n        bot: RuntimeBot,\n        options: AnimateTagFunctionOptions\n    ) {\n        if (typeof options.fromValue !== 'object') {\n            throw new Error(\n                'You must provide an object as fromValue when not specifying a tag.'\n            );\n        }\n        if (typeof options.toValue !== 'object') {\n            throw new Error(\n                'You must provide an object as toValue when not specifying a tag.'\n            );\n        }\n        if (typeof options.duration !== 'number') {\n            throw new Error('You must provide a duration.');\n        }\n\n        const keys = Object.keys(options.fromValue);\n        const groupId = uuid();\n        await Promise.all(\n            keys.map((k) =>\n                animateSingleTag(\n                    bot,\n                    k,\n                    {\n                        ...options,\n                        fromValue: options.fromValue[k],\n                        toValue: options.toValue[k],\n                    },\n                    groupId\n                )\n            )\n        );\n    }\n\n    function animateSingleTag(\n        bot: RuntimeBot,\n        tag: string,\n        options: AnimateTagFunctionOptions,\n        groupId?: string\n    ) {\n        if (!options) {\n            clearAnimations(bot, tag);\n            return Promise.resolve();\n        }\n        if (typeof options.duration !== 'number') {\n            throw new Error('You must provide a duration.');\n        }\n\n        return new Promise<void>((resolve, reject) => {\n            let initialValue = hasValue(options.fromValue)\n                ? options.fromValue\n                : bot.tags[tag];\n            const easing = getEasing(options.easing);\n            const startTime = hasValue(options.startTime)\n                ? options.startTime - context.startTime\n                : context.localTime;\n            let targetValue = options.toValue;\n            let getValue = (elapsed: number) => {\n                return valueHolder[tag];\n            };\n\n            if (targetValue instanceof Vector3) {\n                const startValue = new Vector3(\n                    realNumberOrDefault(initialValue.x, 0),\n                    realNumberOrDefault(initialValue.y, 0),\n                    realNumberOrDefault(initialValue.z, 0)\n                );\n                initialValue = {\n                    x: startValue.x,\n                    y: startValue.y,\n                    z: startValue.z,\n                };\n                getValue = (elapsed: number) => {\n                    return Vector3.interpolatePosition(\n                        startValue,\n                        targetValue,\n                        easing(elapsed)\n                    );\n                };\n            } else if (targetValue instanceof Vector2) {\n                const startValue = new Vector2(\n                    realNumberOrDefault(initialValue.x, 0),\n                    realNumberOrDefault(initialValue.y, 0)\n                );\n                initialValue = {\n                    x: startValue.x,\n                    y: startValue.y,\n                };\n                getValue = (elapsed: number) => {\n                    return Vector2.interpolatePosition(\n                        startValue,\n                        targetValue,\n                        easing(elapsed)\n                    );\n                };\n            } else if (targetValue instanceof Rotation) {\n                const startValue =\n                    initialValue instanceof Rotation\n                        ? initialValue\n                        : initialValue instanceof Quaternion\n                        ? new Rotation(initialValue)\n                        : new Rotation();\n                initialValue = {\n                    x: startValue.quaternion.x,\n                    y: startValue.quaternion.y,\n                    z: startValue.quaternion.z,\n                    w: startValue.quaternion.w,\n                };\n                getValue = (elapsed: number) => {\n                    return Rotation.interpolate(\n                        startValue,\n                        targetValue,\n                        easing(elapsed)\n                    );\n                };\n            }\n            let valueHolder = {\n                [tag]: initialValue,\n            };\n            const tween = new TWEEN.Tween<any>(valueHolder)\n                .to({\n                    [tag]: targetValue,\n                })\n                .duration(options.duration * 1000)\n                .easing(easing)\n                .onUpdate((obj, elapsed) => {\n                    if (\n                        options.tagMaskSpace === false ||\n                        options.tagMaskSpace === getBotSpace(bot)\n                    ) {\n                        setTag(bot, tag, getValue(elapsed));\n                    } else {\n                        setTagMask(\n                            bot,\n                            tag,\n                            getValue(elapsed),\n                            options.tagMaskSpace || 'tempLocal'\n                        );\n                    }\n                })\n                .onComplete(() => {\n                    context.removeBotTimer(bot.id, 'animation', tween.getId());\n                    resolve();\n                })\n                .start(startTime);\n\n            context.recordBotTimer(bot.id, {\n                type: 'animation',\n                timerId: tween.getId(),\n                tag: tag,\n                groupId,\n                cancel: () => {\n                    tween.stop();\n                    reject(new Error('The animation was canceled.'));\n                },\n            });\n        });\n    }\n\n    /**\n     * Cancels the animations that are running on the given bot(s).\n     * @param bot The bot or list of bots that should cancel their animations.\n     * @param tag The tag or list of tags that the animations should be canceld for. If omitted then all tags will be canceled.\n     */\n    function clearAnimations(\n        bot: RuntimeBot | (RuntimeBot | string)[] | string,\n        tag?: string | string[]\n    ) {\n        const bots = Array.isArray(bot)\n            ? bot\n                  .map((b) => (typeof b === 'string' ? getBot('id', b) : b))\n                  .filter((b) => !!b)\n            : typeof bot === 'string'\n            ? getBots('id', bot)\n            : [bot];\n\n        let tags = (\n            !hasValue(tag) ? null : Array.isArray(tag) ? tag : [tag]\n        ) as string[];\n\n        let groups = [] as string[];\n        for (let bot of bots) {\n            if (!bot) {\n                continue;\n            }\n            const timers = context.getBotTimers(bot.id);\n            for (let timer of timers) {\n                if (timer.type === 'animation' && timer.cancel) {\n                    if (!hasValue(tag) || tags.indexOf(timer.tag) >= 0) {\n                        if (hasValue(timer.groupId)) {\n                            groups.push(timer.groupId);\n                        }\n                        timer.cancel();\n                        context.removeBotTimer(\n                            bot.id,\n                            timer.type,\n                            timer.timerId\n                        );\n                    }\n                }\n            }\n        }\n\n        clearGroupAnimations(bots, groups);\n    }\n\n    function clearGroupAnimations(bots: RuntimeBot[], groups: string[]) {\n        if (groups.length <= 0) {\n            return;\n        }\n        for (let bot of bots) {\n            const timers = context.getBotTimers(bot.id);\n            for (let timer of timers) {\n                if (timer.type === 'animation' && timer.cancel) {\n                    if (\n                        hasValue(timer.groupId) &&\n                        groups.indexOf(timer.groupId) >= 0\n                    ) {\n                        timer.cancel();\n                        context.removeBotTimer(\n                            bot.id,\n                            timer.type,\n                            timer.timerId\n                        );\n                    }\n                }\n            }\n        }\n    }\n\n    // /**\n    //  * Sends a web request based on the given options.\n    //  * @param options The options that specify where and what to send in the web request.\n    //  *\n    //  * @example\n    //  * // Send a HTTP POST request to https://www.example.com/api/createThing\n    //  * webhook({\n    //  *   method: 'POST',\n    //  *   url: 'https://www.example.com/api/createThing',\n    //  *   data: {\n    //  *     hello: 'world'\n    //  *   },\n    //  *   responseShout: 'requestFinished'\n    //  * });\n    //  */\n    // const webhook: {\n    //     (options: WebhookOptions): BotAction;\n\n    //     /**\n    //      * Sends a HTTP POST request to the given URL with the given data.\n    //      *\n    //      * @param url The URL that the request should be sent to.\n    //      * @param data That that should be sent.\n    //      * @param options The options that should be included in the request.\n    //      *\n    //      * @example\n    //      * // Send a HTTP POST request to https://www.example.com/api/createThing\n    //      * webhook.post('https://www.example.com/api/createThing', {\n    //      *   hello: 'world'\n    //      * }, { responseShout: 'requestFinished' });\n    //      */\n    //     post: (url: string, data?: any, options?: WebhookOptions) => BotAction;\n    // } = <any>;\n\n    /**\n     * Performs the given action.\n     * @param action The action to perform.\n     */\n    function perform(action: any): any {\n        const event: BotAction = action;\n        if (event.type === 'update_bot') {\n            if (event.update.tags) {\n                for (let tag in event.update.tags) {\n                    const val = event.update.tags[tag];\n                    if (isTagEdit(val)) {\n                        val.isRemote = true;\n                    }\n                }\n            }\n            if (event.update.masks) {\n                for (let space in event.update.masks) {\n                    const tags = event.update.masks[space];\n                    if (tags) {\n                        for (let tag in tags) {\n                            const val = tags[tag];\n                            if (isTagEdit(val)) {\n                                val.isRemote = true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return addAction(action);\n    }\n\n    /**\n     * Rejects the given action.\n     * @param action The action to reject.\n     */\n    function reject(action: any): RejectAction {\n        const original = getOriginalObject(action);\n        const event = Array.isArray(original)\n            ? calcReject(...original)\n            : calcReject(original);\n        return addAction(event);\n    }\n\n    /**\n     * Unlocks admin space using the given password.\n     * Returns a promise that resolves when the space is unlocked.\n     * @param password The password to use to unlock admin space.\n     */\n    function unlockAdminSpace(password: string): Promise<void> {\n        const task = context.createTask();\n        const event = unlockSpace('admin', password, task.taskId);\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Sets the password that should be used for admin space.\n     * @param oldPassword The old password for the admin space.\n     * @param newPassword The new password that should be used.\n     */\n    function setAdminSpacePassword(\n        oldPassword: string,\n        newPassword: string\n    ): Promise<void> {\n        const task = context.createTask();\n        const event = setSpacePassword(\n            'admin',\n            oldPassword,\n            newPassword,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Plays the given animation on the given bot locally.\n     * Reverts back to the original animation when done playing.\n     * @param bot The bot.\n     * @param animation The animation to play.\n     */\n    function localFormAnimation(\n        bot: Bot | string,\n        animation: string | number\n    ): LocalFormAnimationAction {\n        return addAction(calcLocalFormAnimation(getID(bot), animation));\n    }\n\n    /**\n     * Tweens the position of the given bot.\n     * @param bot The bot or bot ID to tween.\n     * @param dimension The dimension that the bot should be tweened in.\n     * @param position The position that the bot should be tweened to.\n     * @param options The options that should be used for the tween.\n     */\n    function localPositionTween(\n        bot: Bot | string,\n        dimension: string,\n        position: { x: number; y: number; z?: number },\n        options?: TweenOptions\n    ): Promise<void> {\n        const task = context.createTask();\n        const action = calcLocalPositionTween(\n            getID(bot),\n            dimension,\n            position,\n            options ? options.easing : undefined,\n            options ? options.duration : undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, action);\n    }\n\n    /**\n     * Tweens the rotation of the given bot.\n     * @param bot The bot or bot ID to tween.\n     * @param dimension The dimension that the bot should be tweened in.\n     * @param rotation The rotation that the bot should be tweened to.\n     * @param options The options that should be used for the tween.\n     */\n    function localRotationTween(\n        bot: Bot | string,\n        dimension: string,\n        rotation: { x: number; y: number; z?: number },\n        options?: TweenOptions\n    ): Promise<void> {\n        const task = context.createTask();\n        const action = calcLocalRotationTween(\n            getID(bot),\n            dimension,\n            rotation,\n            options ? options.easing : undefined,\n            options ? options.duration : undefined,\n            task.taskId\n        );\n        return addAsyncAction(task, action);\n    }\n\n    /**\n     * Gets the position that the center of the given bot would placed at if it had the given anchor point.\n     * @param bot The bot.\n     * @param dimension The dimension to get the position of.\n     * @param anchorPoint The anchor point.\n     */\n    function getAnchorPointPosition(\n        bot: Bot,\n        dimension: string,\n        anchorPoint: BotAnchorPoint\n    ): { x: number; y: number; z: number } {\n        const offset = getAnchorPointOffset(anchorPoint);\n        const scale = getBotScale(null, bot, 1);\n        const position = calcGetBotPosition(null, bot, dimension);\n\n        return {\n            x: position.x + offset.x * scale.x,\n            y: position.y + offset.y * scale.y,\n            z: position.z + offset.z * scale.z,\n        };\n    }\n\n    /**\n     * Starts a new audio recording.\n     */\n    function beginAudioRecording(\n        options?: Omit<BeginAudioRecordingAction, 'type' | 'taskId'>\n    ): Promise<void> {\n        const task = context.createTask();\n        const action = calcBeginAudioRecording(options ?? {}, task.taskId);\n        return addAsyncAction(task, action);\n    }\n\n    /**\n     * Finishes an audio recording.\n     * Returns a promise that resolves with the recorded blob.\n     */\n    function endAudioRecording(): Promise<Blob> {\n        const task = context.createTask();\n        const action = calcEndAudioRecording(task.taskId);\n        return addAsyncAction(task, action);\n    }\n\n    /**\n     * Starts a new recording.\n     * @param options The options for the recording.\n     * @returns A promise that resolves when the recording has started.\n     */\n    function beginRecording(\n        options: RecordingOptions = { audio: true, video: true, screen: false }\n    ): Promise<void> {\n        const task = context.createTask();\n        const action = calcBeginRecording(options, task.taskId);\n        return addAsyncAction(task, action);\n    }\n\n    /**\n     * Finishes a recording.\n     * Returns a promise that resolves with the recorded data.\n     */\n    function endRecording(): Promise<Recording> {\n        const task = context.createTask();\n        const action = calcEndRecording(task.taskId);\n        return addAsyncAction(task, action);\n    }\n\n    /**\n     * Sends commands to the Jitsi Meet API.\n     * See https://jitsi.github.io/handbook/docs/dev-guide/dev-guide-iframe/#commands for a list of commands.\n     * Returns a promise that resolves when the command has been executed.\n     * @param command The command to execute.\n     * @param args The args for the command (if any).\n     */\n    function meetCommand(command: string, ...args: any): Promise<void> {\n        const task = context.createTask();\n        const action = calcMeetCommand(command, args, task.taskId);\n        return addAsyncAction(task, action);\n    }\n\n    /**\n     * Executes the given function from the Jitsi Meet API and returns a promise with the result.\n     * See https://jitsi.github.io/handbook/docs/dev-guide/dev-guide-iframe/#functions for a list of functions.\n     * @param functionName The name of the function to execute.\n     * @param args The arguments to provide to the function.\n     */\n    function meetFunction(functionName: string, ...args: any[]): Promise<any> {\n        const task = context.createTask();\n        const action = calcMeetFunction(functionName, args, task.taskId);\n        return addAsyncAction(task, action);\n    }\n\n    /**\n     * Speaks the given text.\n     * Returns a promise that resolves when the text has been spoken.\n     * @param text The text that should be spoken.\n     * @param options The options that should be used.\n     */\n    function speakText(\n        text: string,\n        options: {\n            rate?: number;\n            pitch?: number;\n            voice?: string | SyntheticVoice;\n        } = {}\n    ): Promise<void> {\n        const task = context.createTask();\n        const voice =\n            typeof options.voice === 'object'\n                ? options.voice?.name\n                : options.voice;\n        const action = calcSpeakText(\n            text,\n            {\n                ...options,\n                voice,\n            },\n            task.taskId\n        );\n        return addAsyncAction(task, action);\n    }\n\n    /**\n     * Gets the list of synthetic voices that are supported by the system.\n     * Returns a promise that resolves with the voices.\n     */\n    function getVoices(): Promise<SyntheticVoice[]> {\n        const task = context.createTask();\n        const action = calcGetVoices(task.taskId);\n        return addAsyncAction(task, action);\n    }\n\n    /**\n     * Sums the given array of numbers and returns the result.\n     * If any value in the list is not a number, it will be converted to one.\n     * If the given value is not an array, then it will be converted to a number and returned.\n     *\n     * @param list The value that should be summed. If it is a list, then the result will be the sum of the items in the list.\n     *             If it is not a list, then the result will be the value converted to a number.\n     */\n    function sum(list: any): number {\n        if (!Array.isArray(list)) {\n            return parseFloat(list);\n        }\n\n        let carry = 0;\n        for (let i = 0; i < list.length; i++) {\n            const l = list[i];\n            if (!Array.isArray(l)) {\n                carry += parseFloat(l);\n            } else {\n                carry += sum(l);\n            }\n        }\n        return carry;\n    }\n\n    /**\n     * Calculates the average of the numbers in the given list and returns the result.\n     * @param list The value that should be averaged.\n     *             If it is a list, then the result will be sum(list)/list.length.\n     *             If it is not a list, then the result will be the value converted to a number.\n     */\n    function avg(list: any): number {\n        if (!Array.isArray(list)) {\n            return parseFloat(list);\n        }\n\n        let total = sum(list);\n        let count = list.length;\n        return total / count;\n    }\n\n    /**\n     * Calculates the square root of the given number.\n     * @param value The number.\n     */\n    function sqrt(value: any): number {\n        return Math.sqrt(parseFloat(value));\n    }\n\n    /**\n     * Calculates the absolute value of a number.\n     * @param number The number to get the absolute value of.\n     */\n    function abs(number: any): number {\n        return Math.abs(parseFloat(number));\n    }\n\n    /**\n     * Calculates the standard deviation of the numbers in the given list and returns the result.\n     *\n     * @param list The value that the standard deviation should be calculated for.\n     */\n    function stdDev(list: any): number {\n        if (!Array.isArray(list)) {\n            list = [parseFloat(list)];\n        }\n\n        let mean = avg(list);\n        let numbersMinusMean = list.map((l: number) => (l - mean) * (l - mean));\n\n        let standardMean = avg(numbersMinusMean);\n        return sqrt(standardMean);\n    }\n\n    /**\n     * Creates a new random number generator and returns it.\n     * @param seed The value that should be used to seed the random number generator.\n     */\n    function getSeededRandomNumberGenerator(\n        seed?: number | string\n    ): PseudoRandomNumberGenerator {\n        if (hasValue(seed)) {\n            let s = typeof seed !== 'string' ? seed.toString() : seed;\n            return _wrapPrng(seed, SeedRandom(s));\n        }\n\n        return _wrapPrng(null, SeedRandom());\n    }\n\n    function _wrapPrng(\n        seed: number | string,\n        prng: SeedRandom.prng\n    ): PseudoRandomNumberGenerator {\n        return {\n            seed: seed,\n            random(min?: number, max?: number): number {\n                return randomBase(min, max, prng);\n            },\n            randomInt(min: number, max: number) {\n                return randomIntBase(min, max, prng);\n            },\n        };\n    }\n\n    /**\n     * Sets the seed that should be used for random numbers.\n     * @param seed The seed that should be used. If given null, then the numbers will be unseeded.\n     */\n    function setRandomSeed(seed: number | string): void {\n        if (!hasValue(seed)) {\n            context.pseudoRandomNumberGenerator = null;\n            return;\n        }\n        if (typeof seed !== 'string') {\n            seed = seed.toString();\n        }\n\n        context.pseudoRandomNumberGenerator = SeedRandom(seed);\n    }\n\n    /**\n     * Generates a random integer number between min and max.\n     * @param min The smallest allowed value.\n     * @param max The largest allowed value.\n     */\n    function randomInt(min: number = 0, max?: number): number {\n        return randomIntBase(min, max, context.pseudoRandomNumberGenerator);\n    }\n\n    /**\n     * Generates a random number between min and max.\n     * @param min The smallest allowed value.\n     * @param max The largest allowed value.\n     */\n    function random(min: number = 0, max?: number): number {\n        return randomBase(min, max, context.pseudoRandomNumberGenerator);\n    }\n\n    function randomBase(\n        min: number = 0,\n        max: number,\n        prng: SeedRandom.prng\n    ): number {\n        const rand = _random(prng);\n        if (max) {\n            return rand * (max - min) + min;\n        } else {\n            return rand + min;\n        }\n    }\n\n    function randomIntBase(\n        min: number,\n        max: number,\n        prng: SeedRandom.prng\n    ): number {\n        min = Math.ceil(min);\n        max = Math.floor(max);\n        const rand = _random(prng);\n        if (max) {\n            return Math.floor(rand * (max - min)) + min;\n        } else {\n            return Math.floor(rand) + min;\n        }\n    }\n\n    function _random(prng: SeedRandom.prng): number {\n        if (prng) {\n            return prng();\n        }\n        return Math.random();\n    }\n\n    /**\n     * Converts the given number of degrees to radians and returns the result.\n     * @param degrees The number of degrees.\n     */\n    function degreesToRadians(degrees: number): number {\n        return degrees * DEG_TO_RAD;\n    }\n\n    /**\n     * Converts the given number of radians to degrees and returns the result.\n     * @param radians The number of radians.\n     */\n    function radiansToDegrees(radians: number): number {\n        return radians * RAD_TO_DEG;\n    }\n\n    /**\n     * Gets the forward direction for the given rotation.\n     * @param pointerRotation The rotation that the pointer has represented in radians.\n     */\n    function getForwardDirection(\n        pointerRotation:\n            | {\n                  x: number;\n                  y: number;\n                  z: number;\n                  w?: number;\n              }\n            | Rotation\n    ): Vector3 {\n        const rotation =\n            pointerRotation instanceof Rotation\n                ? pointerRotation\n                : 'w' in pointerRotation\n                ? new Rotation({\n                      quaternion: new Quaternion(\n                          pointerRotation.x,\n                          pointerRotation.y,\n                          pointerRotation.z,\n                          pointerRotation.w\n                      ),\n                  })\n                : new Rotation({\n                      euler: {\n                          x: pointerRotation.x,\n                          y: pointerRotation.y,\n                          z: pointerRotation.z,\n                      },\n                  });\n        const direction = new Vector3(0, 1, 0);\n        return rotation.rotateVector3(direction);\n    }\n\n    /**\n     * Finds the point at which the the given ray and ground plane intersect.\n     * @param origin The origin of the ray.\n     * @param direction The direction that the ray is pointing.\n     */\n    function intersectPlane(\n        origin: { x: number; y: number; z: number },\n        direction: { x: number; y: number; z: number }\n    ): Vector3 {\n        let plane = new Plane(new ThreeVector3(0, 0, 1));\n        let final = new ThreeVector3();\n        let ray = new Ray(\n            new ThreeVector3(origin.x, origin.y, origin.z),\n            new ThreeVector3(direction.x, direction.y, direction.z)\n        );\n        let result = ray.intersectPlane(plane, final);\n\n        if (result) {\n            return new Vector3(result.x, result.y, result.z);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Gets the position offset for the given bot anchor point.\n     * @param anchorPoint The anchor point to get the offset for.\n     */\n    function getAnchorPointOffset(anchorPoint: BotAnchorPoint): Vector3 {\n        const value = calculateAnchorPoint(anchorPoint);\n        const offset = calculateAnchorPointOffset(value);\n        return new Vector3(offset.x, -offset.y, offset.z);\n    }\n\n    /**\n     * Adds the given vectors together and returns the result.\n     * @param vectors The vectors that should be added together.\n     */\n    function addVectors<T>(...vectors: T[]): T {\n        if (vectors.length <= 0) {\n            return {} as T;\n        }\n        let hasX = false;\n        let hasY = false;\n        let hasZ = false;\n        let hasOther = false;\n        let result = {} as any;\n\n        for (let i = 0; i < vectors.length; i++) {\n            const v = vectors[i] as any;\n            if (!hasValue(v)) {\n                continue;\n            }\n            const keys = Object.keys(v);\n            for (let key of keys) {\n                if (key === 'x') {\n                    hasX = true;\n                } else if (key === 'y') {\n                    hasY = true;\n                } else if (key === 'z') {\n                    hasZ = true;\n                } else {\n                    hasOther = true;\n                }\n\n                if (key in result) {\n                    result[key] += v[key];\n                } else {\n                    result[key] = v[key];\n                }\n            }\n        }\n\n        if (hasX && hasY && !hasZ && !hasOther) {\n            return new Vector2(result.x, result.y) as any;\n        } else if (hasX && hasY && hasZ && !hasOther) {\n            return new Vector3(result.x, result.y, result.z) as any;\n        }\n        return result;\n    }\n\n    /**\n     * Subtracts the given vectors from each other and returns the result.\n     * @param vectors The vectors that should be subtracted from each other.\n     */\n    function subtractVectors<T>(...vectors: T[]): T {\n        if (vectors.length <= 0) {\n            return {} as T;\n        }\n        let hasX = false;\n        let hasY = false;\n        let hasZ = false;\n        let hasOther = false;\n        let result = {} as any;\n\n        for (let i = 0; i < vectors.length; i++) {\n            const v = vectors[i] as any;\n            if (!hasValue(v)) {\n                continue;\n            }\n            const keys = Object.keys(v);\n            for (let key of keys) {\n                if (key === 'x') {\n                    hasX = true;\n                } else if (key === 'y') {\n                    hasY = true;\n                } else if (key === 'z') {\n                    hasZ = true;\n                } else {\n                    hasOther = true;\n                }\n\n                if (key in result) {\n                    result[key] -= v[key];\n                } else {\n                    result[key] = v[key];\n                }\n            }\n        }\n\n        if (hasX && hasY && !hasZ && !hasOther) {\n            return new Vector2(result.x, result.y) as any;\n        } else if (hasX && hasY && hasZ && !hasOther) {\n            return new Vector3(result.x, result.y, result.z) as any;\n        }\n        return result;\n    }\n\n    /**\n     * Negates the given vector and returns the result.\n     * @param vector The vector that should be negated.\n     */\n    function negateVector<T>(vector: T): T {\n        if (!hasValue(vector)) {\n            return vector;\n        }\n        if (vector instanceof Vector2) {\n            return vector.negate() as any;\n        } else if (vector instanceof Vector3) {\n            return vector.negate() as any;\n        }\n        let result = {} as any;\n\n        const keys = Object.keys(vector);\n        for (let key of keys) {\n            result[key] = -(vector as any)[key];\n        }\n\n        return result;\n    }\n\n    /**\n     * Normalizes the given vector and returns the result.\n     * @param vector The vector that should be normalized.\n     */\n    function normalizeVector<T>(vector: T): T {\n        if (!hasValue(vector)) {\n            return vector;\n        }\n        if (vector instanceof Vector2) {\n            return vector.normalize() as any;\n        } else if (vector instanceof Vector3) {\n            return vector.normalize() as any;\n        }\n        let result = {} as any;\n        const length = vectorLength(vector);\n\n        if (length === 0) {\n            return vector;\n        }\n\n        const keys = Object.keys(vector);\n        for (let key of keys) {\n            const val = (vector as any)[key];\n            result[key] = val / length;\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculates the length of the given vector.\n     * @param vector The vector to calculate the length of.\n     */\n    function vectorLength<T>(vector: T): number {\n        if (!hasValue(vector)) {\n            return null;\n        }\n        let result = 0;\n\n        const keys = Object.keys(vector);\n        for (let key of keys) {\n            const val = (vector as any)[key];\n            result += val * val;\n        }\n\n        return Math.sqrt(result);\n    }\n\n    /**\n     * Multiplies each component of the given vector by the given scale and returns the result.\n     * @param vector The vector that should be scaled.\n     * @param scale The number that the vector should be multiplied by.\n     */\n    function scaleVector<T>(vector: T, scale: number): T {\n        if (!hasValue(vector)) {\n            return vector;\n        }\n        if (vector instanceof Vector2) {\n            return vector.multiplyScalar(scale) as any;\n        } else if (vector instanceof Vector3) {\n            return vector.multiplyScalar(scale) as any;\n        }\n        let result = {} as any;\n\n        const keys = Object.keys(vector);\n        for (let key of keys) {\n            result[key] = (vector as any)[key] * scale;\n        }\n\n        return result;\n    }\n\n    /**\n     * Determines if the two given numbers within 2 decimal places of each other.\n     * @param first The first number to check.\n     * @param second The second number to check.\n     */\n    function areClose(first: number, second: number): boolean {\n        const maxDelta = 0.005;\n        const delta = Math.abs(first - second);\n        return delta < maxDelta;\n    }\n\n    /**\n     * Converts the given 3D point into a mod that sets the cameraPositionOffset tags.\n     * @param point The mod that represents the 3D point.\n     */\n    function cameraPositionOffset(point: {\n        x?: number;\n        y?: number;\n        z?: number;\n    }) {\n        let result = {} as any;\n        if ('x' in point) {\n            result.cameraPositionOffsetX = point.x;\n        }\n        if ('y' in point) {\n            result.cameraPositionOffsetY = point.y;\n        }\n        if ('z' in point) {\n            result.cameraPositionOffsetZ = point.z;\n        }\n\n        return result;\n    }\n\n    /**\n     * Converts the given 3D rotation into a mod that sets the cameraRotationOffset tags.\n     * @param rotation The mod that represents the 3D rotation.\n     */\n    function cameraRotationOffset(rotation: {\n        x?: number;\n        y?: number;\n        z?: number;\n    }) {\n        let result = {} as any;\n        if ('x' in rotation) {\n            result.cameraRotationOffsetX = rotation.x;\n        }\n        if ('y' in rotation) {\n            result.cameraRotationOffsetY = rotation.y;\n        }\n        if ('z' in rotation) {\n            result.cameraRotationOffsetZ = rotation.z;\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculates the cryptographic hash for the given data and returns the result in the specified format.\n     * @param algorithm The algorithm that should be used to hash the data.\n     * @param format The format that the hash should be returned in.\n     *               - \"hex\" indicates that a hexadecimal string should be returned.\n     *               - \"base64\" indicates that a base64 formatted string should be returned.\n     *               - \"raw\" indicates that an array of bytes should be returned.\n     * @param data The data that should be hashed.\n     */\n    function hash(\n        algorithm: 'sha256' | 'sha512' | 'sha1',\n        format: 'hex' | 'base64',\n        ...data: unknown[]\n    ): string;\n\n    /**\n     * Calculates the cryptographic hash for the given data and returns the result in the specified format.\n     * @param algorithm The algorithm that should be used to hash the data.\n     * @param format The format that the hash should be returned in.\n     *               - \"hex\" indicates that a hexadecimal string should be returned.\n     *               - \"base64\" indicates that a base64 formatted string should be returned.\n     *               - \"raw\" indicates that an array of bytes should be returned.\n     * @param data The data that should be hashed.\n     */\n    function hash(\n        algorithm: 'sha256' | 'sha512' | 'sha1',\n        format: 'raw',\n        ...data: unknown[]\n    ): Uint8Array;\n\n    /**\n     * Calculates the cryptographic hash for the given data and returns the result in the specified format.\n     * @param algorithm The algorithm that should be used to hash the data.\n     * @param format The format that the hash should be returned in.\n     *               - \"hex\" indicates that a hexadecimal string should be returned.\n     *               - \"base64\" indicates that a base64 formatted string should be returned.\n     *               - \"raw\" indicates that an array of bytes should be returned.\n     * @param data The data that should be hashed.\n     */\n    function hash(\n        algorithm: 'sha256' | 'sha512' | 'sha1',\n        format: 'hex' | 'base64' | 'raw',\n        ...data: unknown[]\n    ): string | Uint8Array {\n        let h =\n            algorithm === 'sha256'\n                ? hashSha256()\n                : algorithm === 'sha512'\n                ? hashSha512()\n                : algorithm === 'sha1'\n                ? hashSha1()\n                : null;\n\n        if (!h) {\n            throw new Error('Not supported algorithm: ' + algorithm);\n        }\n\n        return _hash(h, data, format as any);\n    }\n\n    /**\n     * Calculates the HMAC of the given data and returns the result in the specified format.\n     * HMAC is commonly used to verify that a message was created with a specific key.\n     * @param algorithm The algorithm that should be used to hash the data.\n     * @param format The format that the hash should be returned in.\n     *               - \"hex\" indicates that a hexadecimal string should be returned.\n     *               - \"base64\" indicates that a base64 formatted string should be returned.\n     *               - \"raw\" indicates that an array of bytes should be returned.\n     * @param key The key that should be used to sign the message.\n     * @param data The data that should be hashed.\n     */\n    function hmac(\n        algorithm: 'hmac-sha256' | 'hmac-sha512' | 'hmac-sha1',\n        format: 'hex' | 'base64',\n        key: string,\n        ...data: unknown[]\n    ): string;\n\n    /**\n     * Calculates the HMAC of the given data and returns the result in the specified format.\n     * HMAC is commonly used to verify that a message was created with a specific key.\n     * @param algorithm The algorithm that should be used to hash the data.\n     * @param format The format that the hash should be returned in.\n     *               - \"hex\" indicates that a hexadecimal string should be returned.\n     *               - \"base64\" indicates that a base64 formatted string should be returned.\n     *               - \"raw\" indicates that an array of bytes should be returned.\n     * @param key The key that should be used to sign the message.\n     * @param data The data that should be hashed.\n     */\n    function hmac(\n        algorithm: 'hmac-sha256' | 'hmac-sha512' | 'hmac-sha1',\n        format: 'raw',\n        key: string,\n        ...data: unknown[]\n    ): Uint8Array;\n\n    /**\n     * Calculates the HMAC of the given data and returns the result in the specified format.\n     * HMAC is commonly used to verify that a message was created with a specific key.\n     * @param algorithm The algorithm that should be used to hash the data.\n     * @param format The format that the hash should be returned in.\n     *               - \"hex\" indicates that a hexadecimal string should be returned.\n     *               - \"base64\" indicates that a base64 formatted string should be returned.\n     *               - \"raw\" indicates that an array of bytes should be returned.\n     * @param key The key that should be used to sign the message.\n     * @param data The data that should be hashed.\n     */\n    function hmac(\n        algorithm: 'hmac-sha256' | 'hmac-sha512' | 'hmac-sha1',\n        format: 'hex' | 'base64' | 'raw',\n        key: string,\n        ...data: unknown[]\n    ): string | Uint8Array {\n        let h =\n            algorithm === 'hmac-sha256'\n                ? hashSha256\n                : algorithm === 'hmac-sha512'\n                ? hashSha512\n                : algorithm === 'hmac-sha1'\n                ? hashSha1\n                : null;\n\n        if (!h) {\n            throw new Error('Not supported algorithm: ' + algorithm);\n        }\n\n        if (!hasValue(key)) {\n            throw new Error('The key must not be empty, null, or undefined');\n        }\n\n        if (typeof key !== 'string') {\n            throw new Error('The key must be a string');\n        }\n\n        let hmac = calcHmac(<any>h, key);\n        return _hash(hmac, data, format as any);\n    }\n\n    /**\n     * Calculates the SHA-256 hash of the given data.\n     * @param data The data that should be hashed.\n     */\n    function sha256(...data: unknown[]): string {\n        let sha = hashSha256();\n        return _hash(sha, data, 'hex');\n    }\n\n    /**\n     * Calculates the SHA-512 hash of the given data.\n     * @param data The data that should be hashed.\n     */\n    function sha512(...data: unknown[]): string {\n        let sha = hashSha512();\n        return _hash(sha, data, 'hex');\n    }\n\n    /**\n     * Calculates the HMAC SHA-256 hash of the given data.\n     * HMAC is commonly used to verify that a message was created with a specific key.\n     * @param key The key that should be used to sign the message.\n     * @param data The data that should be hashed.\n     */\n    function hmacSha256(key: string, ...data: unknown[]): string {\n        if (!hasValue(key)) {\n            throw new Error('The key must not be empty, null, or undefined');\n        }\n        if (typeof key !== 'string') {\n            throw new Error('The key must be a string');\n        }\n        let sha = calcHmac(<any>hashSha256, key);\n        return _hash(sha, data, 'hex');\n    }\n\n    /**\n     * Calculates the HMAC SHA-512 hash of the given data.\n     * HMAC is commonly used to verify that a message was created with a specific key.\n     * @param key The key that should be used to sign the message.\n     * @param data The data that should be hashed.\n     */\n    function hmacSha512(key: string, ...data: unknown[]): string {\n        if (!hasValue(key)) {\n            throw new Error('The key must not be empty, null, or undefined');\n        }\n        if (typeof key !== 'string') {\n            throw new Error('The key must be a string');\n        }\n        let sha = calcHmac(<any>hashSha512, key);\n        return _hash(sha, data, 'hex');\n    }\n\n    /**\n     * Encrypts the given data with the given secret and returns the result.\n     *\n     * @description Always choose a strong unique secret. Use a password manager such as LastPass or 1Password to\n     * help you create and keep track of them.\n     *\n     * Assuming the above, this method will return a string of encrypted data that is confidential (unreadable without the secret),\n     * reliable (the encrypted data cannot be changed without making it unreadable), and authentic (decryptability proves that the secret was used to encrypt the data).\n     *\n     * As a consequence, encrypting the same data with the same secret will produce different results.\n     * This is to ensure that an attacker cannot correlate different pieces of data to potentially deduce the original plaintext.\n     *\n     * Encrypts the given data using an authenticated encryption mechanism\n     * based on XSalsa20 (An encryption cipher) and Poly1305 (A message authentication code).\n     *\n     * @param secret The secret to use to secure the data.\n     * @param data The data to encrypt.\n     */\n    function encrypt(secret: string, data: string): string {\n        if (typeof data === 'string') {\n            const encoder = new TextEncoder();\n            const bytes = encoder.encode(data);\n            return realEncrypt(secret, bytes);\n        } else {\n            throw new Error('The data to encrypt must be a string.');\n        }\n    }\n\n    /**\n     * Decrypts the given data using the given secret and returns the result.\n     * If the data was unable to be decrypted, null will be returned.\n     *\n     * @param secret The secret to use to decrypt the data.\n     * @param data The data to decrypt.\n     */\n    function decrypt(secret: string, data: string): string {\n        if (typeof data === 'string') {\n            const bytes = realDecrypt(secret, data);\n            if (!bytes) {\n                return null;\n            }\n            const decoder = new TextDecoder();\n            return decoder.decode(bytes);\n        } else {\n            throw new Error('The data to encrypt must be a string.');\n        }\n    }\n\n    /**\n     * Creates a new keypair that can be used for encrypting and decrypting data.\n     *\n     * @description Always choose a strong unique secret. Use a password manager such as LastPass or 1Password to\n     * help you create and keep track of them.\n     *\n     * Keypairs are made up of a private key and a public key.\n     * The public key is a special value that can be used to encrypt data and\n     * the private key is a related value that can be used to decrypt data that was encrypted by the public key.\n     *\n     * The private key is called \"private\" because it is encrypted using the given secret\n     * while the public key is called \"public\" because it is not encrypted so anyone can use it if they have access to it.\n     *\n     * Note that both the private and public keys are randomly generated, so while the public key is unencrypted, it won't be able to be used by someone else unless\n     * they have access to it.\n     *\n     * @param secret The secret that should be used to encrypt the private key.\n     */\n    function asymmetricKeypair(secret: string): string {\n        return realAsymmetricKeypair(secret);\n    }\n\n    /**\n     * Encrypts the given data with the given keypair and returns the result.\n     *\n     * @description This method will return a string of encrypted data that is confidential (unreadable without the keypair and secret used to encrypt it),\n     * reliable (the encrypted data cannot be changed without making it unreadable), and authentic (decryptability proves that the keypair was used to encrypt the data).\n     *\n     * As a consequence, encrypting the same data with the same keypair will produce different results.\n     * This is to ensure that an attacker cannot correlate different pieces of data to potentially deduce the original plaintext.\n     *\n     * Encrypts the given data using an asymmetric authenticated encryption mechanism\n     * based on x25519 (A key-exchange mechanism), XSalsa20 (An encryption cipher) and Poly1305 (A message authentication code).\n     *\n     * You may notice that this function does not need a secret to decrypt the keypair.\n     * This is because the public key of the keypair is used to encrypt the data.\n     * Due to how asymmetric encryption works, only the encrypted private key will be able to decrypt the data.\n     *\n     * @param keypair The keypair to use to secure the data.\n     * @param data The data to encrypt.\n     */\n    function asymmetricEncrypt(keypair: string, data: string): string {\n        if (typeof data === 'string') {\n            const encoder = new TextEncoder();\n            const bytes = encoder.encode(data);\n            return realAsymmetricEncrypt(keypair, bytes);\n        } else {\n            throw new Error('The data to encrypt must be a string.');\n        }\n    }\n\n    /**\n     * Decrypts the given data with the given keypair and secret and returns the result.\n     * If the data was unable to be decrypted, null will be returned.\n     *\n     * @param keypair The keypair to use to decrypt the data.\n     * @param secret The secret to use to decrypt the keypair's private key.\n     * @param data The data to decrypt.\n     */\n    function asymmetricDecrypt(\n        keypair: string,\n        secret: string,\n        data: string\n    ): string {\n        if (typeof data === 'string') {\n            const bytes = realAsymmetricDecrypt(keypair, secret, data);\n            if (!bytes) {\n                return null;\n            }\n            const decoder = new TextDecoder();\n            return decoder.decode(bytes);\n        } else {\n            throw new Error('The data to encrypt must be a string.');\n        }\n    }\n\n    /**\n     * Creates a new keypair that can be used for signing and verifying data.\n     *\n     * @description\n     * Keypairs are made up of a private key and a public key.\n     * The private key is a special value that can be used to create digital signatures and\n     * the public key is a related value that can be used to verify that a digitital signature was created by the private key.\n     *\n     * The private key is called \"private\" because it is encrypted using the given secret\n     * while the public key is called \"public\" because it is not encrypted so anyone can use it if they have access to it.\n     *\n     * Note that both the private and public keys are randomly generated, so while the public key is unencrypted, it won't be able to be used by someone else unless\n     * they have access to it.\n     *\n     * @param secret The secret that should be used to encrypt the private key.\n     */\n    function keypair(secret: string): string {\n        return realKeypair(secret);\n    }\n\n    /**\n     * Creates a digital signature for the given data using the private key from the given keypair.\n     *\n     * @description\n     * Digital signatures are used to verifying the authenticity and integrity of data.\n     *\n     * This works by leveraging asymetric encryption but in reverse.\n     * If we can encrypt some data such that only the public key of a keypair can decrypt it, then we can prove that\n     * the data was encrypted (i.e. signed) by the corresponding private key. And since the public key is available to everyone but the private\n     * key is only usable when you have the secret, we can use this to prove that a particular piece of data was signed by whoever knows the secret.\n     *\n     * @param keypair The keypair that should be used to create the signature.\n     * @param secret The secret that was used when creating the keypair. Used to decrypt the private key.\n     * @param data The data to sign.\n     */\n    function sign(keypair: string, secret: string, data: string): string {\n        if (typeof data === 'string') {\n            const encoder = new TextEncoder();\n            const bytes = encoder.encode(data);\n            return realSign(keypair, secret, bytes);\n        } else {\n            throw new Error('The data to encrypt must be a string.');\n        }\n    }\n\n    /**\n     * Validates that the given signature for the given data was created by the given keypair.\n     * @param keypair The keypair that should be used to validate the signature.\n     * @param signature The signature that was returned by the sign() operation.\n     * @param data The data that was used in the sign() operation.\n     */\n    function verify(keypair: string, signature: string, data: string): boolean {\n        if (typeof data === 'string') {\n            const encoder = new TextEncoder();\n            const bytes = encoder.encode(data);\n            return realVerify(keypair, signature, bytes);\n        } else {\n            throw new Error('The data to encrypt must be a string.');\n        }\n    }\n\n    /**\n     * Creates a new certified bot that is signed using the given certified bot.\n     * @param certificate The certified bot that the new certificate should be signed with.\n     *                    This is commonly known as the signing certificate.\n     *                    If given null, then the new certificate will be self-signed.\n     * @param secret The signing certificate's secret. This is the secret that was used to create\n     *                 the keypair for the signing certificate. If the new certificate will be self-signed, then this\n     *                 is the secret that was used to create the given keypair.\n     * @param keypair The keypair that the new certificate should use.\n     */\n    function createCertificate(\n        certificate: Bot | string,\n        secret: string,\n        keypair: string\n    ): Promise<RuntimeBot> {\n        const signingBotId = getID(certificate);\n        const task = context.createTask();\n        const action = hasValue(signingBotId)\n            ? calcCreateCertificate(\n                  {\n                      keypair: keypair,\n                      signingBotId: signingBotId,\n                      signingPassword: secret,\n                  },\n                  task.taskId\n              )\n            : calcCreateCertificate(\n                  {\n                      keypair: keypair,\n                      signingPassword: secret,\n                  },\n                  task.taskId\n              );\n\n        return addAsyncAction(task, action);\n    }\n\n    /**\n     * Signs the tag on the given bot using the given certificate and secret.\n     * @param certificate The certificate to use to create the signature.\n     * @param secret The secret to use to decrypt the certificate's private key.\n     * @param bot The bot that should be signed.\n     * @param tag The tag that should be signed.\n     */\n    function signTag(\n        certificate: Bot | string,\n        secret: string,\n        bot: Bot | string,\n        tag: string\n    ): Promise<void> {\n        tag = trimTag(tag);\n        const signingBotId = getID(certificate);\n        const realBot = getBot('id', getID(bot));\n        const value = realBot.raw[tag];\n        const task = context.createTask();\n        const action = calcSignTag(\n            signingBotId,\n            secret,\n            realBot.id,\n            tag,\n            value,\n            task.taskId\n        );\n        return addAsyncAction(task, action);\n    }\n\n    /**\n     * Verifies that the given tag on the given bot has been signed by a certificate.\n     * @param bot The bot.\n     * @param tag The tag to check.\n     */\n    function verifyTag(bot: RuntimeBot | string, tag: string): boolean {\n        tag = trimTag(tag);\n        const id = getID(bot);\n        const realBot = isRuntimeBot(bot) ? bot : getBot('id', id);\n        if (!realBot.signatures) {\n            return false;\n        }\n        const value = realBot.raw[tag];\n        const sig = tagValueHash(id, tag, value);\n        return realBot.signatures[sig] === tag;\n    }\n\n    /**\n     * Revokes the given certificate using the given secret.\n     * In effect, this deletes the certificate bot from the inst.\n     * Additionally, any tags signed with the given certificate will no longer be verified.\n     *\n     * If given a signer, then the specified certificate will be used to sign the revocation.\n     * This lets you use a parent or grandparent certificate to remove the child.\n     *\n     * If no signer is given, then the certificate will be used to revoke itself.\n     *\n     * @param certificate The certificate that should be revoked.\n     * @param secret The secret that should be used to decrypt the corresponding certificate's private key.\n     *                 If given a signer, then this is the secret for the signer certificate. If no signer is given,\n     *                 then this is the secret for the revoked certificate.\n     * @param signer The certificate that should be used to revoke the aforementioned certificate. If not specified then the revocation will be self-signed.\n     */\n    function revokeCertificate(\n        certificate: Bot | string,\n        secret: string,\n        signer?: Bot | string\n    ): Promise<void> {\n        const certId = getID(certificate);\n        const signerId = getID(signer || certificate);\n        const task = context.createTask();\n        const action = calcRevokeCertificate(\n            signerId,\n            secret,\n            certId,\n            task.taskId\n        );\n        return addAsyncAction(task, action);\n    }\n\n    /**\n     * Gets performance stats from the runtime.\n     */\n    function getStats(): PerformanceStats {\n        return {\n            numberOfBots: context.bots.length,\n            shoutTimes: context.getShoutTimers(),\n            numberOfActiveTimers: context.getNumberOfActiveTimers(),\n            loadTimes: context.getLoadTimes(),\n        };\n    }\n\n    function _hash(\n        hash: MessageDigest<any>,\n        data: unknown[],\n        format: 'hex' | 'base64'\n    ): string;\n    function _hash(\n        hash: MessageDigest<any>,\n        data: unknown[],\n        format: 'raw'\n    ): Uint8Array;\n    function _hash(\n        hash: MessageDigest<any>,\n        data: unknown[],\n        format: 'hex' | 'base64' | 'raw'\n    ): string | Uint8Array {\n        for (let d of data) {\n            if (!hasValue(d)) {\n                d = '';\n            } else if (typeof d === 'object') {\n                d = stableStringify(d);\n            } else if (typeof d !== 'string') {\n                d = d.toString();\n            }\n            hash.update(d);\n        }\n\n        if (!!format && format !== 'hex') {\n            const result = hash.digest();\n            const array = new Uint8Array(result);\n            if (format === 'base64') {\n                return fromByteArray(array);\n            } else {\n                return array;\n            }\n        }\n\n        return hash.digest('hex');\n    }\n\n    /**\n     * Sets the value of the given tag stored in the given bot.\n     * @param bot The bot.\n     * @param tag The tag to set.\n     * @param value The value to set.\n     *\n     * @example\n     * // Set a bot's color to \"green\".\n     * setTag(this, \"color\", \"green\");\n     */\n    function setTag(bot: Bot | Bot[] | BotTags, tag: string, value: any): any {\n        tag = trimTag(tag);\n        if (tag === 'id' || tag === BOT_SPACE_TAG) {\n            return value;\n        }\n        if (isRuntimeBot(value)) {\n            throw new Error(\n                `It is not possible to save bots as tag values. (Setting '${tag}')`\n            );\n        }\n        if (Array.isArray(bot) && bot.length > 0) {\n            for (let b of bot) {\n                setTag(b, tag, value);\n            }\n            return value;\n        } else if (bot && isBot(bot)) {\n            bot.tags[tag] = value;\n            return value;\n        } else if (bot) {\n            (<BotTags>bot)[tag] = value;\n            return value;\n        }\n    }\n\n    /**\n     * Sets the value of the given tag mask in the given bot.\n     * @param bot The bot.\n     * @param tag The tag to set.\n     * @param value The value to set.\n     * @param space The space that the tag mask should be placed in. If not specified, then the tempLocal space will be used.\n     *\n     * @example\n     * // Set a bot's color to \"green\".\n     * setTagMask(this, \"color\", \"green\")\n     */\n    function setTagMask(\n        bot: RuntimeBot | RuntimeBot[],\n        tag: string,\n        value: any,\n        space?: string\n    ): any {\n        tag = trimTag(tag);\n        if (tag === 'id' || tag === BOT_SPACE_TAG) {\n            return value;\n        }\n        if (Array.isArray(bot) && bot.length > 0) {\n            for (let b of bot) {\n                setTagMask(b, tag, value, space);\n            }\n            return value;\n        } else if (bot && isRuntimeBot(bot)) {\n            bot[SET_TAG_MASK_SYMBOL](tag, value, space);\n            return value;\n        }\n    }\n\n    /**\n     * Clears the tag masks from the given bot.\n     * @param bot The bot or bots that the tag masks should be cleared from.\n     * @param space The space that the tag masks should be cleared from. If not specified, then all spaces will be cleared.\n     */\n    function clearTagMasks(\n        bot: RuntimeBot | RuntimeBot[],\n        space?: string\n    ): void {\n        if (Array.isArray(bot) && bot.length > 0) {\n            for (let b of bot) {\n                clearTagMasks(b, space);\n            }\n        } else if (bot && isRuntimeBot(bot)) {\n            bot[CLEAR_TAG_MASKS_SYMBOL](space);\n        }\n    }\n\n    /**\n     * Inserts the given text into the given tag at the given index.\n     * Returns the resulting raw tag value.\n     * @param bot The bot that should be edited.\n     * @param tag The tag that should be edited.\n     * @param index The index that the text should be inserted at.\n     * @param text The text that should be inserted.\n     */\n    function insertTagText(\n        bot: RuntimeBot,\n        tag: string,\n        index: number,\n        text: string\n    ): string {\n        const currentValue = convertToString(bot.raw[tag]);\n        if (index < 0) {\n            index += currentValue.length;\n        }\n        index = Math.max(0, Math.min(index, currentValue.length));\n        bot[EDIT_TAG_SYMBOL](tag, [preserve(index), insert(text)]);\n        return bot.raw[tag];\n    }\n\n    /**\n     * Inserts the given text into the given tag and space at the given index.\n     * Returns the resulting raw tag mask value.\n     * @param bot The bot that should be edited.\n     * @param tag The tag that should be edited.\n     * @param index The index that the text should be inserted at.\n     * @param text The text that should be inserted.\n     * @param space The space that the tag exists in. If not specified then the tempLocal space will be used.\n     */\n    function insertTagMaskText(\n        bot: RuntimeBot,\n        tag: string,\n        index: number,\n        text: string,\n        space?: BotSpace\n    ): string {\n        const currentValue = convertToString(bot.masks[tag]);\n        if (index < 0) {\n            index += currentValue.length;\n        }\n        index = Math.max(0, Math.min(index, currentValue.length));\n        bot[EDIT_TAG_MASK_SYMBOL](tag, [preserve(index), insert(text)], space);\n        return bot.masks[tag];\n    }\n\n    /**\n     * Deletes the specified number of characters from the given tag.\n     * Returns the resulting raw tag value.\n     * @param bot The bot that should be edited.\n     * @param tag The tag that should be edited.\n     * @param index The index that the text should be deleted at.\n     * @param count The number of characters to delete.\n     */\n    function deleteTagText(\n        bot: RuntimeBot,\n        tag: string,\n        index: number,\n        count: number\n    ): string {\n        const currentValue = convertToString(bot.raw[tag]);\n        if (index < 0) {\n            index += currentValue.length;\n        }\n        index = Math.max(0, Math.min(index, currentValue.length));\n        count = Math.min(count, currentValue.length - index);\n        if (count > 0) {\n            bot[EDIT_TAG_SYMBOL](tag, [preserve(index), del(count)]);\n        }\n        return bot.raw[tag] || '';\n    }\n\n    /**\n     * Deletes the specified number of characters from the given tag mask.\n     * Returns the resulting raw tag mask value.\n     * @param bot The bot that should be edited.\n     * @param tag The tag that should be edited.\n     * @param index The index that the text should be deleted at.\n     * @param count The number of characters to delete.\n     * @param space The space that the tag mask exists in. If not specified then the tempLocal space will be used.\n     */\n    function deleteTagMaskText(\n        bot: RuntimeBot,\n        tag: string,\n        index: number,\n        count: number,\n        space?: string\n    ): string {\n        const currentValue = convertToString(bot.masks[tag]);\n        if (index < 0) {\n            index += currentValue.length;\n        }\n        index = Math.max(0, Math.min(index, currentValue.length));\n        count = Math.min(count, currentValue.length - index);\n        if (count > 0) {\n            bot[EDIT_TAG_MASK_SYMBOL](\n                tag,\n                [preserve(index), del(count)],\n                space\n            );\n        }\n        return bot.masks[tag] || '';\n    }\n\n    /**\n     * Removes tags from the given list of bots.\n     * @param bot The bot, bot ID, or list of bots that should have their matching tags removed.\n     * @param tagSection The tag section which should be removed from the bot(s). If given a string, then all the tags\n     *                   starting with the given name will be removed. If given a RegExp, then all the tags matching the regex will be removed.\n     *\n     * @example\n     * // Remove tags named starting with \"abc\" from the `this` bot.\n     * removeTags(this, \"abc\");\n     *\n     * @example\n     * // Remove tags named \"hello\" using a case-insensitive regex from the `this` bot.\n     * removeTags(this, /^hello$/gi);\n     *\n     */\n    function removeTags(bot: Bot | Bot[], tagSection: string | RegExp): void {\n        if (typeof bot === 'object' && Array.isArray(bot)) {\n            let botList: any[] = bot;\n\n            for (let h = 0; h < bot.length; h++) {\n                let currentBot = botList[h];\n                let tags = tagsOnBot(currentBot);\n\n                for (let i = tags.length - 1; i >= 0; i--) {\n                    if (tagSection instanceof RegExp) {\n                        if (tagSection.test(tags[i])) {\n                            setTag(currentBot, tags[i], null);\n                        }\n                    } else if (tags[i].indexOf(tagSection) === 0) {\n                        setTag(currentBot, tags[i], null);\n                    }\n                }\n            }\n        } else {\n            let tags = tagsOnBot(bot);\n\n            for (let i = tags.length - 1; i >= 0; i--) {\n                // if the tag section is relevant to the curretn tag at all\n                if (tagSection instanceof RegExp) {\n                    if (tagSection.test(tags[i])) {\n                        setTag(bot, tags[i], null);\n                    }\n                } else if (tags[i].indexOf(tagSection) === 0) {\n                    // if the tag starts with the tag section\n                    setTag(bot, tags[i], null);\n                }\n            }\n        }\n    }\n\n    /**\n     * Renames the given original tag to the given new tag using the given bot or list of bots.\n     * @param bot The bot or list of bots that the tag should be renamed on.\n     * @param originalTag The original tag to rename.\n     * @param newTag The new tag name.\n     */\n    function renameTag(\n        bot: Bot | Bot[],\n        originalTag: string,\n        newTag: string\n    ): void {\n        if (Array.isArray(bot)) {\n            for (let b of bot) {\n                renameTag(b, originalTag, newTag);\n            }\n        } else {\n            if (originalTag in bot.tags) {\n                const original = bot.tags[originalTag];\n                delete bot.tags[originalTag];\n                bot.tags[newTag] = original;\n            }\n        }\n    }\n\n    /**\n     * Applies the given mods to the given bot.\n     * @param bot The bot.\n     * @param diffs The mods to apply.\n     */\n    function applyMod(bot: any, ...diffs: Mod[]): void {\n        let appliedDiffs: BotTags[] = [];\n        for (let diff of diffs) {\n            if (!diff) {\n                continue;\n            }\n            let tags: BotTags;\n            if (isRuntimeBot(diff)) {\n                tags = diff.raw;\n            } else if (isBot(diff)) {\n                tags = diff.tags;\n            } else {\n                tags = diff;\n            }\n            appliedDiffs.push(tags);\n            for (let key in tags) {\n                setTag(bot, key, tags[key]);\n            }\n        }\n    }\n\n    /**\n     * subrtacts the given diff from the given bot.\n     * @param bot The bot.\n     * @param diff The diff to apply.\n     */\n    function subtractMods(bot: any, ...diffs: Mod[]): void {\n        let subtractedDiffs: BotTags[] = [];\n        for (let diff of diffs) {\n            if (!diff) {\n                continue;\n            }\n            let tags: BotTags;\n            if (isBot(diff)) {\n                tags = diff.tags;\n            } else {\n                tags = diff;\n            }\n            subtractedDiffs.push(tags);\n            for (let key in tags) {\n                setTag(bot, key, null);\n            }\n        }\n    }\n\n    /**\n     * Creates a new bot and returns it.\n     * @param parent The bot that should be the parent of the new bot.\n     * @param mods The mods which specify the new bot's tag values. If given a mod with no tags, then an error will be thrown.\n     * @returns The bot(s) that were created.\n     *\n     * @example\n     * // Create a red bot without a parent.\n     * let redBot = create(null, { \"color\": \"red\" });\n     *\n     * @example\n     * // Create a red bot and a blue bot with `this` as the parent.\n     * let [redBot, blueBot] = create(this, [\n     *    { \"color\": \"red\" },\n     *    { \"color\": \"blue\" }\n     * ]);\n     *\n     */\n    function create(botId: string, ...mods: Mod[]) {\n        return createBase(botId, () => context.uuid(), ...mods);\n    }\n\n    function createBase(\n        botId: string,\n        idFactory: () => string,\n        ...datas: Mod[]\n    ) {\n        let parentDiff = botId ? { creator: botId } : {};\n        return createFromMods(idFactory, parentDiff, ...datas);\n    }\n\n    /**\n     * Creates a new bot that contains the given tags.\n     * @param mods The mods that specify what tags to set on the bot.\n     */\n    function createFromMods(\n        idFactory: () => string,\n        ...mods: (Mod | Mod[])[]\n    ): RuntimeBot | RuntimeBot[] {\n        let variants: Mod[][] = new Array<Mod[]>(1);\n        variants[0] = [];\n\n        for (let i = 0; i < mods.length; i++) {\n            let diff = mods[i];\n            if (Array.isArray(diff)) {\n                let newVariants: Mod[][] = new Array<Mod[]>(\n                    variants.length * diff.length\n                );\n\n                for (let b = 0; b < newVariants.length; b++) {\n                    let diffIdx = Math.floor(b / variants.length);\n                    let d = diff[diffIdx];\n                    let variantIdx = b % variants.length;\n                    let newVariant = variants[variantIdx].slice();\n                    newVariant.push(d);\n                    newVariants[b] = newVariant;\n                }\n\n                variants = newVariants;\n            } else if (typeof diff === 'object') {\n                for (let b = 0; b < variants.length; b++) {\n                    variants[b].push(diff);\n                }\n            }\n        }\n\n        let bots: Bot[] = variants.map((v) => {\n            let bot: Bot = {\n                id: idFactory(),\n                tags: {},\n            };\n            for (let i = v.length - 1; i >= 0; i--) {\n                const mod = v[i];\n                if (mod && BOT_SPACE_TAG in mod) {\n                    const space = mod[BOT_SPACE_TAG];\n                    if (hasValue(space)) {\n                        bot.space = space;\n                    }\n                    break;\n                }\n            }\n            applyMod(bot.tags, ...v);\n\n            if ('creator' in bot.tags) {\n                let clearCreator = false;\n                const creatorId = bot.tags['creator'];\n                if (!creatorId) {\n                    clearCreator = true;\n                } else {\n                    const creator = getBot('id', creatorId);\n                    if (!creator) {\n                        clearCreator = true;\n                    } else {\n                        const creatorSpace = getBotSpace(creator);\n                        const currentSpace = getBotSpace(bot);\n                        if (creatorSpace !== currentSpace) {\n                            clearCreator = true;\n                        }\n                    }\n                }\n\n                if (clearCreator) {\n                    delete bot.tags['creator'];\n                }\n            }\n\n            return bot;\n        });\n\n        if (bots.some((b) => Object.keys(b.tags).length <= 0)) {\n            throw new Error('Cannot create a bot with zero tags.');\n        }\n\n        let ret = new Array<RuntimeBot>(bots.length);\n        for (let i = 0; i < bots.length; i++) {\n            ret[i] = context.createBot(bots[i]);\n        }\n\n        event(CREATE_ACTION_NAME, ret);\n        for (let bot of ret) {\n            event(CREATE_ANY_ACTION_NAME, null, {\n                bot: bot,\n            });\n        }\n\n        if (ret.length === 1) {\n            return ret[0];\n        } else {\n            return ret;\n        }\n    }\n\n    /**\n     * Destroys the given bot, bot ID, or list of bots.\n     * @param bot The bot, bot ID, or list of bots to destroy.\n     */\n    function destroy(\n        bot: RuntimeBot | string | Bot | (RuntimeBot | string | Bot)[]\n    ): void {\n        if (typeof bot === 'object' && Array.isArray(bot)) {\n            bot.forEach((f) => destroyBot(f));\n        } else {\n            destroyBot(bot);\n        }\n    }\n\n    /**\n     * Removes the given bot or bot ID from the simulation.\n     * @param bot The bot or bot ID to remove from the simulation.\n     */\n    function destroyBot(bot: RuntimeBot | string | Bot): void {\n        let realBot: RuntimeBot;\n        let id: string;\n        if (!hasValue(bot)) {\n            return;\n        }\n        if (typeof bot === 'object') {\n            if (isRuntimeBot(bot)) {\n                id = bot.id;\n                realBot = bot;\n            } else if (isBot(bot)) {\n                id = bot.id;\n                realBot = getBot('id', id);\n            } else {\n                return;\n            }\n        } else if (typeof bot === 'string') {\n            if (!hasValue(bot)) {\n                return;\n            }\n            id = bot;\n            realBot = getBot('id', id);\n        }\n\n        if (!realBot || !isRuntimeBot(realBot) || !hasValue(id)) {\n            return;\n        }\n\n        let destroyable = realBot.tags.auxDestroyable;\n        if (hasValue(destroyable) && destroyable !== true) {\n            return;\n        }\n\n        destroyable = realBot.tags.destroyable;\n        if (hasValue(destroyable) && destroyable !== true) {\n            return;\n        }\n\n        if (id) {\n            event(DESTROY_ACTION_NAME, [id]);\n            context.destroyBot(realBot);\n        }\n\n        destroyChildren(id);\n    }\n\n    function destroyChildren(id: string): void {\n        const children = getBots(byTag('creator', createBotLink([id])));\n        for (let child of children) {\n            destroyBot(child);\n        }\n    }\n\n    /**\n     * Changes the state that the given bot is in.\n     * @param bot The bot to change.\n     * @param stateName The state that the bot should move to.\n     * @param groupName The group of states that the bot's state should change in. (Defaults to \"state\")\n     */\n    function changeState(\n        bot: Bot,\n        stateName: string,\n        groupName: string = 'state'\n    ): void {\n        const previousState = getTag(bot, groupName);\n        if (previousState === stateName) {\n            return;\n        }\n        setTag(bot, groupName, stateName);\n\n        const arg = {\n            to: stateName,\n            from: previousState,\n        };\n        if (hasValue(previousState)) {\n            whisper(bot, `${groupName}${previousState}OnExit`, arg);\n        }\n        whisper(bot, `${groupName}${stateName}OnEnter`, arg);\n    }\n\n    /**\n     * Creates a tag value that can be used to link to the given bots.\n     * @param bots The bots that the link should point to.\n     */\n    function createBotLinkApi(\n        ...bots: (Bot | string | (Bot | string)[])[]\n    ): string {\n        let targets = flatMap(bots);\n        let result = [] as string[];\n        for (let t of targets) {\n            if (isBot(t)) {\n                result.push(t.id);\n            } else {\n                let links = parseBotLink(t);\n                if (links) {\n                    result.push(...links);\n                } else {\n                    result.push(t);\n                }\n            }\n        }\n        return createBotLink(result);\n    }\n\n    /**\n     * Gets the list of bot links that are stored in this bot's tags.\n     * @param bot The bot to get the links for.\n     */\n    function getBotLinks(bot: Bot): ParsedBotLink[] {\n        let links = [] as ParsedBotLink[];\n        for (let tag of Object.keys(bot.tags)) {\n            const val = bot.tags[tag];\n            const ids = parseBotLink(val);\n            if (ids) {\n                links.push({\n                    tag,\n                    botIDs: ids,\n                });\n            }\n        }\n\n        return links;\n    }\n\n    /**\n     * Updates all the links in the given bot using the given ID map.\n     * Useful if you know that the links in the given bot are outdated and you know which IDs map to the new IDs.\n     * @param bot The bot to update.\n     * @param idMap The map of old IDs to new IDs that should be used.\n     */\n    function updateBotLinks(\n        bot: Bot,\n        idMap: Map<string, string | Bot> | { [id: string]: string | Bot }\n    ): void {\n        let map: Map<string, string | Bot>;\n        if (idMap instanceof Map) {\n            map = idMap;\n        } else if (typeof idMap === 'object') {\n            map = new Map();\n            for (let key in idMap) {\n                const newId = idMap[key];\n                if (typeof newId === 'string') {\n                    map.set(key, newId);\n                } else if (isBot(newId)) {\n                    map.set(key, newId.id);\n                }\n            }\n        } else {\n            return;\n        }\n\n        for (let tag of Object.keys(bot.tags)) {\n            const val = bot.tags[tag];\n            const ids = parseBotLink(val);\n            if (ids) {\n                const mapped = ids.map((id) => {\n                    if (map.has(id)) {\n                        const newId = map.get(id);\n                        if (typeof newId === 'string') {\n                            return newId;\n                        } else if (isBot(newId)) {\n                            return newId.id;\n                        }\n                    }\n                    return id;\n                });\n                bot.tags[tag] = createBotLink(mapped);\n            }\n        }\n    }\n\n    /**\n     * Parses the given value into a date time object.\n     * Returns null if the value could not be parsed into a date time.\n     * @param value The value to parse.\n     */\n    function getDateTime(value: unknown): DateTime {\n        if (typeof value === 'string') {\n            if (!isBotDate(value)) {\n                value = DATE_TAG_PREFIX + value;\n            }\n\n            return parseBotDate(value);\n        } else if (value instanceof DateTime) {\n            return value;\n        } else if (value instanceof Date) {\n            return DateTime.fromJSDate(value);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Shouts the given event to every bot in every loaded simulation.\n     * @param eventName The name of the event to shout.\n     * @param arg The argument to shout. This gets passed as the `that` variable to the other scripts.\n     */\n    function superShout(eventName: string, arg?: any): SuperShoutAction {\n        const event = calcSuperShout(trimEvent(eventName), arg);\n        return addAction(event);\n    }\n\n    /**\n     * Shouts the given events in order until a bot returns a result.\n     * Returns the result that was produced or undefined if no result was produced.\n     * @param eventNames The names of the events to shout.\n     * @param arg The argument to shout.\n     */\n    function priorityShout(eventNames: string[], arg?: any) {\n        for (let name of eventNames) {\n            let results: any = event(name, null, arg, undefined, true);\n\n            if (results.hasResult) {\n                return results[results.length - 1];\n            }\n        }\n\n        return undefined;\n    }\n\n    /**\n     * Asks every bot in the inst to run the given action.\n     * In effect, this is like shouting to a bunch of people in a room.\n     *\n     * @param name The event name.\n     * @param arg The optional argument to include in the shout.\n     * @returns Returns a list which contains the values returned from each script that was run for the shout.\n     *\n     * @example\n     * // Tell every bot to reset themselves.\n     * shout(\"reset()\");\n     *\n     * @example\n     * // Ask every bot for its name.\n     * const names = shout(\"getName()\");\n     *\n     * @example\n     * // Tell every bot say \"Hi\" to you.\n     * shout(\"sayHi()\", \"My Name\");\n     */\n    function shout(name: string, arg?: any) {\n        if (!hasValue(name) || typeof name !== 'string') {\n            throw new Error('shout() name must be a string.');\n        }\n        return event(name, null, arg);\n    }\n\n    /**\n     * Asks the given bots to run the given action.\n     * In effect, this is like whispering to a specific set of people in a room.\n     *\n     * @param bot The bot(s) to send the event to.\n     * @param eventName The name of the event to send.\n     * @param arg The optional argument to include.\n     * @returns Returns a list which contains the values returned from each script that was run for the shout.\n     *\n     * @example\n     * // Tell all the red bots to reset themselves.\n     * whisper(getBots(\"#color\", \"red\"), \"reset()\");\n     *\n     * @example\n     * // Ask all the tall bots for their names.\n     * const names = whisper(getBots(\"scaleZ\", height => height >= 2), \"getName()\");\n     *\n     * @example\n     * // Tell every friendly bot to say \"Hi\" to you.\n     * whisper(getBots(\"friendly\", true), \"sayHi()\", \"My Name\");\n     */\n    function whisper(\n        bot: (Bot | string)[] | Bot | string,\n        eventName: string,\n        arg?: any\n    ) {\n        if (!hasValue(eventName) || typeof eventName !== 'string') {\n            throw new Error('whisper() eventName must be a string.');\n        }\n        let bots;\n        if (Array.isArray(bot)) {\n            bots = bot;\n        } else if (hasValue(bot)) {\n            bots = [bot];\n        } else {\n            return [];\n        }\n\n        return event(eventName, bots, arg);\n    }\n\n    /**\n     * Gets whether the player is in the sheet dimension.\n     */\n    function inSheet(): boolean {\n        return getPortalDimension('sheet') !== null;\n    }\n\n    /**\n     * Gets the 3D position of the player's camera.\n     * @param portal The portal that the camera position should be retrieved for.\n     */\n    function getCameraPosition(portal: 'grid' | 'miniGrid' = 'grid'): Vector3 {\n        const bot = context.global[`${portal}PortalBot`];\n        if (!bot) {\n            return new Vector3(NaN, NaN, NaN);\n        }\n\n        return new Vector3(\n            bot.tags[`cameraPositionX`],\n            bot.tags[`cameraPositionY`],\n            bot.tags[`cameraPositionZ`]\n        );\n    }\n\n    /**\n     * Gets the 3D rotation of the player's camera.\n     * @param portal The portal that the camera rotation should be retrieved for.\n     */\n    function getCameraRotation(portal: 'grid' | 'miniGrid' = 'grid'): {\n        x: number;\n        y: number;\n        z: number;\n    } {\n        const bot = context.global[`${portal}PortalBot`];\n        if (!bot) {\n            return {\n                x: NaN,\n                y: NaN,\n                z: NaN,\n            };\n        }\n\n        return {\n            x: bot.tags[`cameraRotationX`],\n            y: bot.tags[`cameraRotationY`],\n            z: bot.tags[`cameraRotationZ`],\n        };\n    }\n\n    /**\n     * Gets the 3D point that the player's camera is focusing on.\n     * @param portal The portal that the camera focus point should be retrieved for.\n     */\n    function getFocusPoint(portal: 'grid' | 'miniGrid' = 'grid'): Vector3 {\n        const bot = context.global[`${portal}PortalBot`];\n        if (!bot) {\n            return new Vector3(NaN, NaN, NaN);\n        }\n\n        return new Vector3(\n            bot.tags[`cameraFocusX`],\n            bot.tags[`cameraFocusY`],\n            bot.tags[`cameraFocusZ`]\n        );\n    }\n\n    /**\n     * Gets the 3D position of the player's pointer.\n     * @param pointer The position of the pointer to retrieve.\n     */\n    function getPointerPosition(\n        pointer: 'mouse' | 'left' | 'right' = 'mouse'\n    ): Vector3 {\n        const user = context.playerBot;\n        if (!user) {\n            return new Vector3(NaN, NaN, NaN);\n        }\n\n        return new Vector3(\n            user.tags[`${pointer}PointerPositionX`],\n            user.tags[`${pointer}PointerPositionY`],\n            user.tags[`${pointer}PointerPositionZ`]\n        );\n    }\n\n    /**\n     * Gets the 3D rotation of the player's pointer.\n     * @param pointer The rotation of the pointer to retrieve.\n     */\n    function getPointerRotation(\n        pointer: 'mouse' | 'left' | 'right' = 'mouse'\n    ): { x: number; y: number; z: number } {\n        const user = context.playerBot;\n        if (!user) {\n            return {\n                x: NaN,\n                y: NaN,\n                z: NaN,\n            };\n        }\n\n        return {\n            x: user.tags[`${pointer}PointerRotationX`],\n            y: user.tags[`${pointer}PointerRotationY`],\n            z: user.tags[`${pointer}PointerRotationZ`],\n        };\n    }\n\n    /**\n     * Gets the 3D direction that the given pointer is pointing in.\n     * @param pointer The pointer to get the direction of.\n     */\n    function getPointerDirection(\n        pointer: 'mouse' | 'left' | 'right' = 'mouse'\n    ): Vector3 {\n        const rotation = getPointerRotation(pointer);\n        if (isNaN(rotation.x) || isNaN(rotation.y) || isNaN(rotation.z)) {\n            return new Vector3(NaN, NaN, NaN);\n        }\n        return getForwardDirection(rotation);\n    }\n\n    /**\n     * Gets the input state of the given button on the given controller.\n     * @param controller The name of the controller that should be checked.\n     * @param button The name of the button on the controller.\n     */\n    function getInputState(\n        controller: string,\n        button: string\n    ): null | 'down' | 'held' {\n        const user = context.playerBot;\n        if (!user) {\n            return null;\n        }\n\n        return user.tags[`${controller}_${button}`] || null;\n    }\n\n    /**\n     * Gets the list of inputs that are currently available.\n     */\n    function getInputList(): string[] {\n        const user = context.playerBot;\n        if (!user) {\n            return [];\n        }\n\n        return user.tags.inputList || [];\n    }\n\n    /**\n     * Gets permission from user to access audio and/or video streams from the device.\n     * @param options The options.\n     */\n    function getMediaPermission(options: MediaPermssionOptions) {\n        const task = context.createTask();\n        const event = calcGetMediaPermission(options, task.taskId);\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Gets the current average frame rate for the 3D portals in seconds.\n     * @returns A promise that resolves with the number of frames over the last second.\n     */\n    function getAverageFrameRate(): Promise<number> {\n        const task = context.createTask();\n        const event = calcGetAverageFrameRate(task.taskId);\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Attempts to join the given meeting room.\n     * @param roomName The name of the meeting room to join.\n     * @param options The options for the meeting.\n     */\n    function joinRoom(\n        roomName: string,\n        options: JoinRoomActionOptions = {}\n    ): Promise<JoinRoomResult> {\n        const task = context.createTask();\n        const event = calcJoinRoom(roomName, options, task.taskId);\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Attempts to leave the given meeting room.\n     * @param roomName THe name of the meeting room to leave.\n     * @param options The options.\n     */\n    function leaveRoom(\n        roomName: string,\n        options: RecordActionOptions = {}\n    ): Promise<LeaveRoomResult> {\n        const task = context.createTask();\n        const event = calcLeaveRoom(roomName, options, task.taskId);\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Attempts to set the options for the given meeting room.\n     * Useful for enabling/disabling video, audio, and screensharing.\n     * @param roomName The name of the room.\n     * @param options The options to set. Omitted properties remain unchanged.\n     */\n    function setRoomOptions(\n        roomName: string,\n        options: Partial<RoomOptions>\n    ): Promise<SetRoomOptionsResult> {\n        const task = context.createTask();\n        const event = calcSetRoomOptions(roomName, options, task.taskId);\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Gets the options for the given meeting room.\n     * Returns a promise that resolves with the options.\n     * @param roomName The name of the room that the options should be retrieved for.\n     */\n    function getRoomOptions(roomName: string): Promise<GetRoomOptionsResult> {\n        const task = context.createTask();\n        const event = calcGetRoomOptions(roomName, task.taskId);\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Gets the options for the track with the given address in the given room.\n     * @param roomName The name of the room.\n     * @param address The address of the track that the options should be retrieved for.\n     */\n    function getRoomTrackOptions(\n        roomName: string,\n        address: string\n    ): Promise<GetRoomTrackOptionsResult> {\n        const task = context.createTask();\n        const event = calcGetRoomTrackOptions(roomName, address, task.taskId);\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Sets the options for the track with the given address in the given room.\n     * @param roomName The name of the room.\n     * @param address The address of the track that the options should be retrieved for.\n     * @param options The options that should be set for the track.\n     */\n    function setRoomTrackOptions(\n        roomName: string,\n        address: string,\n        options: SetRoomTrackOptions\n    ): Promise<SetRoomTrackOptionsResult> {\n        const task = context.createTask();\n        const event = calcSetRoomTrackOptions(\n            roomName,\n            address,\n            options,\n            task.taskId\n        );\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Gets the options for the specified remote user in the specified room.\n     * @param roomName The name of the room.\n     * @param remoteId The ID of the remote user.\n     */\n    function getRoomRemoteOptions(\n        roomName: string,\n        remoteId: string\n    ): Promise<GetRoomRemoteOptionsResult> {\n        const task = context.createTask();\n        const event = calcGetRoomRemoteOptions(roomName, remoteId, task.taskId);\n        return addAsyncAction(task, event);\n    }\n\n    /**\n     * Runs an event on the given bots.\n     * @param name The name of the event to run.\n     * @param bots The bots that the event should be executed on. If null, then the event will be run on every bot.\n     * @param arg The argument to pass.\n     * @param sort Whether to sort the Bots before processing. Defaults to true.\n     * @param shortCircuit Whether to stop processing bots when one returns a value.\n     */\n    function event(\n        name: string,\n        bots: (Bot | string)[],\n        arg?: any,\n        sendListenEvents: boolean = true,\n        shortCircuit: boolean = false\n    ): any[] {\n        const startTime = globalThis.performance.now();\n        let tag = trimEvent(name);\n\n        let ids = !!bots\n            ? bots.map((bot) => {\n                  return !!bot\n                      ? typeof bot === 'string'\n                          ? bot\n                          : bot.id\n                      : null;\n              })\n            : context.getBotIdsWithListener(tag);\n\n        let results = [] as any[];\n\n        let targets = [] as RuntimeBot[];\n        let listeners = [] as RuntimeBot[];\n        let checkedEnergy = false;\n        let stop = false;\n\n        for (let id of ids) {\n            if (stop) {\n                break;\n            }\n            if (!id) {\n                continue;\n            }\n            const bot = context.state[id];\n            if (bot) {\n                targets.push(bot);\n            }\n            if (\n                !bot ||\n                bot.tags.auxListening === false ||\n                bot.tags.listening === false\n            ) {\n                continue;\n            }\n\n            let listener = bot.listeners[tag];\n            if (listener) {\n                if (!checkedEnergy) {\n                    checkedEnergy = true;\n                    __energyCheck();\n                }\n                try {\n                    const result = listener(arg);\n\n                    if (result instanceof Promise) {\n                        result.catch((ex) => {\n                            context.enqueueError(ex);\n                        });\n                    }\n                    results.push(result);\n\n                    if (shortCircuit && result !== undefined) {\n                        stop = true;\n                    }\n                } catch (ex) {\n                    context.enqueueError(ex);\n                    results.push(undefined);\n                }\n                listeners.push(bot);\n            }\n        }\n\n        const endTime = globalThis.performance.now();\n        const delta = endTime - startTime;\n        context.addShoutTime(name, delta);\n\n        if (sendListenEvents) {\n            const listenArg = {\n                name: name,\n                that: arg,\n                responses: results,\n                targets,\n                listeners,\n            };\n            event('onListen', listeners, listenArg, false);\n            event('onAnyListen', null, listenArg, false);\n        }\n\n        if (shortCircuit && stop) {\n            (<any>results).hasResult = true;\n        }\n\n        return results;\n    }\n\n    function __energyCheck() {\n        let current = context.energy;\n        current -= 1;\n        context.energy = current;\n        if (current <= 0) {\n            throw new RanOutOfEnergyError();\n        }\n    }\n\n    // Helpers\n    function addAction<T extends BotAction>(action: T) {\n        context.enqueueAction(action);\n        return action;\n    }\n\n    function addAsyncAction<T extends AsyncActions>(\n        task: AsyncTask,\n        action: T\n    ) {\n        addAction(action);\n        let promise = task.promise;\n        (<any>promise)[ORIGINAL_OBJECT] = action;\n        return promise;\n    }\n\n    function getDownloadState(state: BotsState): {\n        version: number;\n        state: BotsState;\n    } {\n        return {\n            version: 1,\n            state,\n        };\n    }\n\n    function isPdf(filename: string): boolean {\n        return filename.endsWith('.pdf');\n    }\n\n    function formatAuxFilename(filename: string): string {\n        if (filename.endsWith('.aux')) {\n            return filename;\n        } else if (isPdf(filename)) {\n            return filename;\n        }\n        return filename + '.aux';\n    }\n\n    function convertSessionSelector(\n        selector: SessionSelector | string\n    ): DeviceSelector {\n        if (typeof selector === 'string') {\n            return {\n                sessionId: selector,\n            };\n        }\n        return selector\n            ? {\n                  sessionId: selector.session,\n                  username: selector.username,\n                  deviceId: selector.device,\n                  broadcast: selector.broadcast,\n              }\n            : undefined;\n    }\n}\n","import Vue from 'vue';\nimport Component from 'vue-class-component';\n\n@Component\nexport default class Tagline extends Vue {}\n","\n<div class=\"tagline\"> CasualOS</div>\n","import Component from 'vue-class-component';\nimport Vue from 'vue';\nimport { hasValue } from '@casual-simulation/aux-common';\nimport { Prop } from 'vue-property-decorator';\nimport Tagline from '../Tagline/Tagline';\n\n@Component({\n    components: {\n        tagline: Tagline,\n    },\n})\nexport default class Loading extends Vue {\n    @Prop({ default: '' }) status: string;\n    @Prop({ default: 0 }) progress: number;\n    @Prop({ default: null }) error: string;\n    @Prop({ default: false }) show: boolean;\n    @Prop({}) version: string;\n    @Prop({ default: 'Dismiss' }) errorAction: string;\n    @Prop({ default: 'An error has occured.' }) errorTitle: string;\n\n    showSpinner: boolean;\n\n    get hasError(): boolean {\n        return hasValue(this.error);\n    }\n\n    onErrorDismiss() {\n        this.$emit('dismiss');\n    }\n\n    created() {\n        const circleElement = document.createElementNS(\n            'http://www.w3.org/2000/svg',\n            'circle'\n        );\n        this.showSpinner = circleElement instanceof SVGElement;\n    }\n}\n","\n<div>\n    <md-dialog\n        :md-fullscreen=\"false\"\n        :md-click-outside-to-close=\"false\"\n        :md-close-on-esc=\"false\"\n        :md-backdrop=\"true\"\n        :md-active=\"show\"\n    >\n        <div v-if=\"!hasError\" class=\"loading-dialog\">\n            <div class=\"loading-text-content\">\n                <div class=\"loading-progress\">\n                    <md-progress-spinner\n                        v-if=\"showSpinner\"\n                        md-mode=\"indeterminate\"\n                        :md-diameter=\"20\"\n                        :md-stroke=\"2\"\n                    ></md-progress-spinner>\n                </div>\n            </div>\n            <md-progress-bar md-mode=\"determinate\" :md-value=\"progress\"></md-progress-bar>\n            <div class=\"version\">{{ version }}</div>\n        </div>\n        <div v-else class=\"loading-error\">\n            <div class=\"loading-text-content error-text-content\">\n                <h1>{{ errorTitle }}</h1>\n                <p>{{ error }}</p>\n            </div>\n            <md-button @click=\"onErrorDismiss\">{{ errorAction }}</md-button>\n        </div>\n    </md-dialog>\n</div>\n","import Vue from 'vue';\nimport Component from 'vue-class-component';\nimport { Prop } from 'vue-property-decorator';\n\n@Component({})\nexport default class SvgIcon extends Vue {\n    @Prop({ required: true }) name: string;\n    @Prop({ required: false }) width: number;\n    @Prop({ required: false }) height: number;\n\n    get symbolId() {\n        return `#icon-${this.name}`;\n    }\n}\n","\n<svg>\n    <use :href=\"symbolId\" :width=\"width\" :height=\"height\" />\n</svg>\n","import { EventBus } from '@casual-simulation/aux-components';\nimport Vue from 'vue';\nimport Component from 'vue-class-component';\nimport { Provide } from 'vue-property-decorator';\nimport { authManager } from '../../shared/index';\nimport { SvgIcon } from '@casual-simulation/aux-components';\n\ndocument.title = location.hostname;\n\n@Component({\n    components: {\n        'svg-icon': SvgIcon,\n    },\n})\nexport default class AuthApp extends Vue {\n    showLogout: boolean;\n\n    get title() {\n        return location.hostname;\n    }\n\n    created() {\n        this.showLogout = false;\n        authManager.loginState.subscribe((state) => {\n            this.showLogout = authManager.isLoggedIn();\n        });\n    }\n\n    async logout() {\n        await authManager.logout();\n        this.$router.push({ name: 'login' });\n    }\n}\n","\n<div id=\"app\">\n    <md-toolbar>\n        <a class=\"title-link md-title\" href=\"/\" style=\"flex: 1\">\n            <svg-icon name=\"PersonPinCircle\" class=\"title-img\"></svg-icon>\n            <strong>{{ title }}</strong>\n        </a>\n        <md-button v-if=\"showLogout\" @click=\"logout\">Logout</md-button>\n    </md-toolbar>\n    <router-view></router-view>\n</div>\n","import Vue from 'vue';\nimport Component from 'vue-class-component';\nimport { EventBus, Loading } from '@casual-simulation/aux-components';\nimport { Subscription } from 'rxjs';\nimport { Prop } from 'vue-property-decorator';\nimport axios from 'axios';\n\nconst WOLF3D_IFRAME_URL = 'https://casualos.readyplayer.me';\n\n@Component({\n    components: {\n        loading: Loading,\n    },\n})\nexport default class AuthAvatar extends Vue {\n    @Prop() avatarUrl: string;\n    @Prop({ default: null }) render: string;\n\n    iframeUrl: string = WOLF3D_IFRAME_URL;\n\n    /**\n     * Wether we are in the process of creating or changing the avatar.\n     */\n    createAvatar: boolean = false;\n\n    /**\n     * Whether we have received an avatar from Wofl3D.\n     */\n    createdAvatar: boolean = false;\n\n    get hasAvatar(): boolean {\n        return !!this.avatarUrl;\n    }\n\n    private _sub: Subscription;\n\n    created() {\n        this.createAvatar = false;\n        this.iframeUrl = WOLF3D_IFRAME_URL;\n        this._onMessage = this._onMessage.bind(this);\n    }\n\n    mounted() {\n        this._sub = new Subscription();\n\n        window.addEventListener('message', this._onMessage, false);\n\n        this._sub.add(() => {\n            window.removeEventListener('message', this._onMessage);\n        });\n    }\n\n    changeAvatar() {\n        this.createAvatar = true;\n        this.createdAvatar = false;\n    }\n\n    private async _onMessage(event: MessageEvent) {\n        if (event.origin !== this.iframeUrl) {\n            return;\n        }\n\n        let avatarUrl = event.data;\n\n        this.createdAvatar = true;\n        console.log('[AuthAvatar] Got Avatar!', avatarUrl);\n\n        let portraitUrl: string = null;\n        console.log('[AuthAvatar] Getting portrait URL...');\n\n        try {\n            const response = await axios.post(\n                'https://render.readyplayer.me/render',\n                {\n                    model: avatarUrl,\n                    scene: 'fullbody-portrait-v1',\n                }\n            );\n\n            if (\n                response.data &&\n                response.data.renders &&\n                response.data.renders.length > 0\n            ) {\n                portraitUrl = response.data.renders[0];\n                console.log('[AuthAvatar] Got portrait!', portraitUrl);\n            }\n        } catch (e) {\n            console.warn('[AuthAvatar] Failed to get portrait', e);\n        }\n\n        this.createdAvatar = false;\n\n        this.$emit('updateAvatar', {\n            url: avatarUrl,\n            render: portraitUrl,\n        });\n    }\n}\n","\n<div>\n    <div v-if=\"hasAvatar\">\n        <h3>Avatar</h3>\n        <p>You have an avatar! {{ avatarUrl }}</p>\n        <img v-if=\"render\" class=\"avatar-img\" :src=\"render\" />\n    </div>\n    <md-button @click=\"changeAvatar()\">\n        {{ hasAvatar ? 'Change Avatar' : 'Create Avatar' }}\n    </md-button>\n\n    <md-dialog class=\"avatar-dialog\" :md-active.sync=\"createAvatar\">\n        <md-dialog-content>\n            <md-progress-spinner\n                v-if=\"createdAvatar\"\n                md-mode=\"indeterminate\"\n                :md-diameter=\"20\"\n                :md-stroke=\"2\"\n            ></md-progress-spinner>\n            <iframe v-if=\"!createdAvatar\" :src=\"iframeUrl\"></iframe>\n        </md-dialog-content>\n    </md-dialog>\n</div>\n","import Vue from 'vue';\nimport Component from 'vue-class-component';\nimport { Prop, Provide, Watch } from 'vue-property-decorator';\n\n@Component({\n    components: {},\n})\nexport default class SessionLocation extends Vue {\n    @Prop() session: any;\n}\n","\n<span v-if=\"session.currentSession\">\n    <md-tooltip>{{ session.ipAddress }}</md-tooltip>\n    <md-icon v-if=\"session.currentSession\">verified_user</md-icon>\n    Your current session\n</span>\n<span v-else>\n    {{ session.ipAddress }}\n</span>\n","import Vue from 'vue';\nimport Component from 'vue-class-component';\nimport { Prop, Provide, Watch } from 'vue-property-decorator';\nimport { DateTime } from 'luxon';\n\n@Component({\n    components: {},\n})\nexport default class RelativeTime extends Vue {\n    @Prop() millis: number;\n\n    get relativeTime() {\n        const time = DateTime.fromMillis(this.millis);\n        return time.toRelative();\n    }\n\n    get commonTime() {\n        const time = DateTime.fromMillis(this.millis);\n        return time.toLocaleString(DateTime.DATETIME_FULL);\n    }\n}\n","\n<span>\n    <md-tooltip>{{ commonTime }}</md-tooltip>\n    {{ relativeTime }}\n</span>\n","import { AppMetadata, UserMetadata } from '../../../shared/AuthMetadata';\nimport Vue from 'vue';\nimport Component from 'vue-class-component';\nimport { Provide, Watch } from 'vue-property-decorator';\nimport { authManager } from '../../shared/index';\nimport { Subscription } from 'rxjs';\nimport { debounce, sortBy } from 'lodash';\nimport { tap } from 'rxjs/operators';\nimport type { ListedSession } from '@casual-simulation/aux-records/AuthController';\nimport { DateTime } from 'luxon';\nimport SessionLocation from '../SessionLocation/SessionLocation';\nimport RelativeTime from '../RelativeTime/RelativeTime';\n\n@Component({\n    components: {\n        'session-location': SessionLocation,\n        'relative-time': RelativeTime,\n    },\n})\nexport default class AuthSecurity extends Vue {\n    private _sub: Subscription;\n\n    sessions: ListedSession[] = [];\n    loading: boolean = false;\n\n    showConfirmRevokeAllSessions: boolean = false;\n\n    created() {\n        this.sessions = [];\n        this.loading = false;\n        this.showConfirmRevokeAllSessions = false;\n    }\n\n    mounted() {\n        this._sub = authManager.loginState\n            .pipe(\n                tap((state) => {\n                    if (state) {\n                        this._loadSessions();\n                    }\n                })\n            )\n            .subscribe();\n    }\n\n    beforeDestroy() {\n        this._sub?.unsubscribe();\n    }\n\n    async revokeSession(session: ListedSession) {\n        const currentSession =\n            session.userId === authManager.userId &&\n            session.sessionId === authManager.sessionId;\n        const result = await authManager.revokeSession(\n            session.userId,\n            session.sessionId\n        );\n\n        if (result.success) {\n            this._loadSessions();\n\n            if (currentSession) {\n                this.$router.push({ name: 'login' });\n            }\n        }\n    }\n\n    requestRevokeAllSessions() {\n        this.showConfirmRevokeAllSessions = true;\n    }\n\n    cancelRevokeAllSessions() {\n        this.showConfirmRevokeAllSessions = false;\n    }\n\n    async revokeAllSessions() {\n        const result = await authManager.revokeAllSessions();\n        if (result.success) {\n            this.$router.push({ name: 'login' });\n        }\n    }\n\n    private async _loadSessions() {\n        this.loading = true;\n        const now = Date.now();\n        try {\n            let filteredSessions = [] as ListedSession[];\n            let expireTime = null as number;\n            let hasNewSessions = false;\n            do {\n                hasNewSessions = false;\n                const result = await authManager.listSessions(expireTime);\n\n                for (let session of result) {\n                    if (session.expireTimeMs > now) {\n                        filteredSessions.push(session);\n                        hasNewSessions = true;\n                    }\n\n                    if (!expireTime || session.expireTimeMs < expireTime) {\n                        expireTime = session.expireTimeMs;\n                    }\n                }\n            } while (hasNewSessions);\n\n            this.sessions = sortBy(filteredSessions, (s) =>\n                s.revokeTimeMs ? s.revokeTimeMs : -s.expireTimeMs\n            );\n        } catch (err) {\n            console.error('[AuthSecurity] Unable to load sessions:', err);\n            this.sessions = [];\n        } finally {\n            this.loading = false;\n        }\n    }\n}\n","\n<div>\n    <div class=\"sessions-title\">\n        <h2 class=\"md-title\">Sessions</h2>\n        <md-menu md-align-trigger>\n            <md-button md-menu-trigger class=\"md-icon-button\">\n                <md-icon>more_vert</md-icon>\n                <span class=\"sr-only\">All Session Options</span>\n                <md-tooltip>All Session Options</md-tooltip>\n            </md-button>\n            <md-menu-content>\n                <md-menu-item @click=\"requestRevokeAllSessions()\"\n                    >Revoke All Sessions</md-menu-item\n                >\n            </md-menu-content>\n        </md-menu>\n    </div>\n    <div>\n        <md-table>\n            <md-table-row>\n                <md-table-head>ID</md-table-head>\n                <md-table-head>Location</md-table-head>\n                <md-table-head>Status</md-table-head>\n                <md-table-head>Granted</md-table-head>\n            </md-table-row>\n\n            <md-table-row v-for=\"session of sessions\" :key=\"session.sessionId\">\n                <md-table-cell>{{ session.sessionId.substring(0, 8) }}</md-table-cell>\n                <md-table-cell><session-location :session=\"session\" /></md-table-cell>\n                <md-table-cell>\n                    <span v-if=\"session.revokeTimeMs\"\n                        >Revoked <relative-time :millis=\"session.revokeTimeMs\"\n                    /></span>\n                    <span v-else>Expires <relative-time :millis=\"session.expireTimeMs\" /></span>\n                </md-table-cell>\n                <md-table-cell><relative-time :millis=\"session.grantedTimeMs\" /></md-table-cell>\n                <md-table-cell>\n                    <md-menu md-align-trigger>\n                        <md-button\n                            v-if=\"!session.revokeTimeMs\"\n                            md-menu-trigger\n                            class=\"md-icon-button\"\n                        >\n                            <md-icon>more_vert</md-icon>\n                            <span class=\"sr-only\">Session Options</span>\n                            <md-tooltip>Session Options</md-tooltip>\n                        </md-button>\n                        <md-menu-content>\n                            <md-menu-item @click=\"revokeSession(session)\"\n                                >Revoke Session</md-menu-item\n                            >\n                        </md-menu-content>\n                    </md-menu>\n                </md-table-cell>\n            </md-table-row>\n        </md-table>\n    </div>\n\n    <md-dialog-confirm\n        :md-active.sync=\"showConfirmRevokeAllSessions\"\n        md-title=\"Revoke All Sessions?\"\n        md-content=\"Are you sure you want to revoke all of the active sessions? This will log you out everywhere.\"\n        md-confirm-text=\"Revoke\"\n        md-cancel-text=\"Cancel\"\n        @md-cancel=\"cancelRevokeAllSessions\"\n        @md-confirm=\"revokeAllSessions\"\n    />\n</div>\n","import { AppMetadata, UserMetadata } from '../../../shared/AuthMetadata';\nimport Vue from 'vue';\nimport Component from 'vue-class-component';\nimport { Provide, Watch } from 'vue-property-decorator';\nimport { authManager } from '../../shared/index';\nimport { Subscription } from 'rxjs';\nimport { debounce } from 'lodash';\nimport Avatar from '../AuthAvatar/AuthAvatar';\nimport Security from '../AuthSecurity/AuthSecurity';\n\n@Component({\n    components: {\n        avatar: Avatar,\n        security: Security,\n    },\n})\nexport default class AuthHome extends Vue {\n    metadata: UserMetadata = null;\n    originalEmail: string = null;\n    originalName: string = null;\n    originalPhone: string = null;\n    originalAvatarUrl: string = null;\n    originalAvatarPortraitUrl: string = null;\n\n    updating: boolean = false;\n    updated: boolean = false;\n\n    private _sub: Subscription;\n\n    created() {\n        this.metadata = null;\n        this.updating = false;\n        this.updated = false;\n\n        this._updateMetadata = this._updateMetadata.bind(this);\n        this._updateMetadata = debounce(this._updateMetadata, 500);\n    }\n\n    mounted() {\n        this._sub = authManager.loginState.subscribe((state) => {\n            this.originalEmail = authManager.email;\n            this.originalName = authManager.name;\n            this.originalAvatarUrl = authManager.avatarUrl;\n            this.originalAvatarPortraitUrl = authManager.avatarPortraitUrl;\n            this.originalPhone = authManager.phone;\n            this.metadata = {\n                email: authManager.email,\n                avatarUrl: authManager.avatarUrl,\n                avatarPortraitUrl: authManager.avatarPortraitUrl,\n                name: authManager.name,\n                phone: authManager.phone,\n            };\n        });\n    }\n\n    beforeDestroy() {\n        this._sub?.unsubscribe();\n    }\n\n    saveEmail() {\n        // TODO: Handle errors\n        authManager.changeEmail(this.metadata.email);\n    }\n\n    @Watch('metadata.name')\n    updateName() {\n        if (this.originalName === this.metadata.name) {\n            return;\n        }\n        this.updating = true;\n        this.updated = false;\n        this._updateMetadata();\n    }\n\n    updateAvatar(avatar: { url: string; render: string }) {\n        this.metadata.avatarUrl = avatar.url;\n        this.metadata.avatarPortraitUrl = avatar.render;\n        if (\n            this.originalAvatarUrl === this.metadata.avatarUrl &&\n            this.originalAvatarPortraitUrl === this.metadata.avatarPortraitUrl\n        ) {\n            return;\n        }\n        this.updating = true;\n        this.updated = false;\n        this._updateMetadata();\n    }\n\n    private async _updateMetadata() {\n        let newMetadata: Partial<AppMetadata> = {};\n        let hasChange = false;\n        if (this.originalName !== this.metadata.name) {\n            newMetadata.name = this.metadata.name;\n            hasChange = true;\n        }\n\n        if (this.originalAvatarUrl !== this.metadata.avatarUrl) {\n            newMetadata.avatarUrl = this.metadata.avatarUrl;\n            hasChange = true;\n        }\n\n        if (\n            this.originalAvatarPortraitUrl !== this.metadata.avatarPortraitUrl\n        ) {\n            newMetadata.avatarPortraitUrl = this.metadata.avatarPortraitUrl;\n            hasChange = true;\n        }\n\n        if (hasChange) {\n            await authManager.updateMetadata(newMetadata);\n        }\n\n        this.updating = false;\n\n        if (hasChange) {\n            this.updated = true;\n        }\n    }\n}\n","\n<div>\n    <div class=\"home-container\">\n        <!-- <h1 class=\"md-title\">You are logged in!</h1> -->\n\n        <div v-if=\"metadata\">\n            <div>\n                <md-field>\n                    <label for=\"name\">Name</label>\n                    <md-input v-model=\"metadata.name\" type=\"text\" placeholder=\"Name\"></md-input>\n                </md-field>\n            </div>\n            <div class=\"button-field\">\n                <md-field class=\"md-disabled\">\n                    <label for=\"email\">Email</label>\n                    <md-input\n                        v-model=\"metadata.email\"\n                        type=\"text\"\n                        placeholder=\"Email\"\n                    ></md-input>\n                </md-field>\n                <md-button v-show=\"metadata.email !== originalEmail\" @click=\"saveEmail()\"\n                    >Save Email</md-button\n                >\n            </div>\n            <div class=\"button-field\">\n                <md-field class=\"md-disabled\">\n                    <label for=\"email\">Phone</label>\n                    <md-input\n                        v-model=\"metadata.phone\"\n                        type=\"text\"\n                        placeholder=\"Phone\"\n                        disabled\n                    ></md-input>\n                </md-field>\n            </div>\n            <div>\n                <avatar\n                    :avatarUrl=\"metadata.avatarUrl\"\n                    :render=\"metadata.avatarPortraitUrl\"\n                    @updateAvatar=\"updateAvatar\"\n                ></avatar>\n            </div>\n\n            <p v-show=\"updating\">Updating...</p>\n            <p v-show=\"updated\">Updated!</p>\n\n            <security />\n        </div>\n    </div>\n</div>\n","import {\n    cleanPhoneNumber,\n    mightBeEmailAddress,\n} from '@casual-simulation/aux-common';\nimport Vue from 'vue';\nimport Component from 'vue-class-component';\nimport { Prop, Provide, Watch } from 'vue-property-decorator';\nimport { authManager } from '../../shared/index';\n\ndeclare let ENABLE_SMS_AUTHENTICATION: boolean;\n\n@Component({\n    components: {},\n})\nexport default class AuthLogin extends Vue {\n    address: string = '';\n    processing: boolean = false;\n\n    acceptedTerms: boolean = false;\n    showTermsOfServiceError: boolean = false;\n    showEmailError: boolean = false;\n    showSmsError: boolean = false;\n    showInvalidAddressError: boolean = false;\n    showEnterAddressError: boolean = false;\n    supportsSms: boolean = false;\n\n    @Prop({ default: null }) after: string;\n\n    private _loggedIn: boolean;\n\n    get addressFieldHint() {\n        return this.supportsSms ? `Email or Phone Number` : `Email`;\n    }\n\n    get addressFieldClass() {\n        return this.showEmailError ||\n            this.showSmsError ||\n            this.showEnterAddressError ||\n            this.showInvalidAddressError\n            ? 'md-invalid'\n            : '';\n    }\n\n    get enterAddressErrorMessage() {\n        if (this.supportsSms) {\n            return 'Please enter an Email Address or Phone Number';\n        } else {\n            return 'Please enter an Email Address';\n        }\n    }\n\n    async created() {\n        this.address = authManager.savedEmail || '';\n        this.acceptedTerms = authManager.hasAcceptedTerms;\n        this.processing = false;\n        this._loggedIn = false;\n        this.supportsSms = ENABLE_SMS_AUTHENTICATION === true;\n    }\n\n    async mounted() {\n        if (authManager.isLoggedIn()) {\n            this._loggedIn = true;\n        }\n\n        await this._loadInfoAndNavigate();\n    }\n\n    private async _loadInfoAndNavigate() {\n        if (this._loggedIn) {\n            await authManager.loadUserInfo();\n\n            if (this.after) {\n                this.$router.push({ name: this.after });\n            } else {\n                this.$router.push({ name: 'home' });\n            }\n        }\n    }\n\n    private async _checkLoginStatus() {\n        if (authManager.isLoggedIn()) {\n            await this._loadInfoAndNavigate();\n            return true;\n        }\n\n        return false;\n    }\n\n    @Watch('acceptedTerms')\n    termsOfServiceAccepted() {\n        if (this.acceptedTerms) {\n            this.showTermsOfServiceError = false;\n        }\n    }\n\n    async login() {\n        this.processing = true;\n        try {\n            if (await this._checkLoginStatus()) {\n                return;\n            }\n\n            if (!this.acceptedTerms) {\n                this.showTermsOfServiceError = true;\n                return;\n            }\n            if (!this.address) {\n                this.showEnterAddressError = true;\n                return;\n            }\n            this.showTermsOfServiceError = false;\n            this.showEnterAddressError = false;\n            this.showEmailError = false;\n            this.showEmailError = false;\n\n            if (!this.supportsSms || mightBeEmailAddress(this.address)) {\n                await this._loginWithEmail();\n            } else {\n                const sms = cleanPhoneNumber(this.address);\n                if (!sms) {\n                    this.showInvalidAddressError = true;\n                } else {\n                    await this._loginWithPhoneNumber(sms);\n                }\n            }\n        } finally {\n            this.processing = false;\n        }\n    }\n\n    private async _loginWithEmail() {\n        try {\n            if (!(await authManager.validateEmail(this.address))) {\n                this.showEmailError = true;\n                this.processing = false;\n                return;\n            }\n\n            const result = await authManager.loginWithEmail(this.address);\n            if (result.success) {\n                this.$router.push({\n                    name: 'code',\n                    query: {\n                        after: this.after,\n                        userId: result.userId,\n                        requestId: result.requestId,\n                        address: this.address,\n                        addressTypeToCheck: 'email',\n                    },\n                });\n            } else if (result.success === false) {\n                if (result.errorCode === 'unacceptable_address') {\n                    this.showEmailError = true;\n                } else if (result.errorCode === 'address_type_not_supported') {\n                    this.showEnterAddressError = true;\n                }\n                return;\n            }\n        } catch (err) {\n            console.error('[AuthLogin] Could not login with email:', err);\n            this._loggedIn = false;\n        }\n    }\n\n    private async _loginWithPhoneNumber(sms: string) {\n        try {\n            if (!(await authManager.validateSmsNumber(sms))) {\n                this.showEmailError = true;\n                this.processing = false;\n                return;\n            }\n\n            const result = await authManager.loginWithPhoneNumber(sms);\n            if (result.success) {\n                this.$router.push({\n                    name: 'code',\n                    query: {\n                        after: this.after,\n                        userId: result.userId,\n                        requestId: result.requestId,\n                        address: sms,\n                        addressTypeToCheck: 'phone',\n                    },\n                });\n            } else if (result.success === false) {\n                if (result.errorCode === 'unacceptable_address') {\n                    this.showSmsError = true;\n                } else if (result.errorCode === 'address_type_not_supported') {\n                    this.showEnterAddressError = true;\n                }\n                return;\n            }\n        } catch (err) {\n            console.error(\n                '[AuthLogin] Could not login with phone number:',\n                err\n            );\n            this._loggedIn = false;\n        }\n    }\n}\n","\n<div class=\"login-container\">\n    <form @submit.prevent=\"login\">\n        <md-card>\n            <md-card-header>\n                <div class=\"md-title\">Login</div>\n            </md-card-header>\n            <md-card-content>\n                <div class=\"md-layout md-gutter\">\n                    <div class=\"md-layout-item\">\n                        <md-field :class=\"addressFieldClass\">\n                            <label for=\"address\">{{ addressFieldHint }}</label>\n                            <md-input\n                                name=\"address\"\n                                id=\"address\"\n                                autocomplete=\"email\"\n                                v-model=\"address\"\n                                :disabled=\"processing\"\n                            />\n                            <span v-show=\"showEmailError\" class=\"md-error\"\n                                >This email is not allowed</span\n                            >\n                            <span v-show=\"showSmsError\" class=\"md-error\"\n                                >This phone number is not allowed</span\n                            >\n                            <span v-if=\"showInvalidAddressError\" class=\"md-error\"\n                                >This value is not recognized as a phone number or email\n                                address</span\n                            >\n                            <span v-if=\"showEnterAddressError\" class=\"md-error\">{{\n                                enterAddressErrorMessage\n                            }}</span>\n                        </md-field>\n                    </div>\n                </div>\n                <div class=\"terms-of-service-container\">\n                    <div v-show=\"showTermsOfServiceError\" class=\"terms-of-service-error\">\n                        Please accept the terms of service.\n                    </div>\n                    <div class=\"terms-of-service-wrapper\">\n                        <md-checkbox v-model=\"acceptedTerms\" id=\"terms-of-service\">\n                        </md-checkbox>\n                        <label for=\"terms-of-service\">\n                            I accept the\n                            <a target=\"_blank\" href=\"/terms\">Terms of Service</a>\n                        </label>\n                    </div>\n                </div>\n            </md-card-content>\n\n            <md-card-actions>\n                <md-button type=\"submit\" class=\"md-primary\" :disabled=\"processing\">\n                    <md-progress-spinner\n                        v-if=\"processing\"\n                        md-mode=\"indeterminate\"\n                        :md-diameter=\"20\"\n                        :md-stroke=\"2\"\n                        >Processing</md-progress-spinner\n                    >\n                    <span v-else>Send</span>\n                </md-button>\n            </md-card-actions>\n        </md-card>\n    </form>\n</div>\n","import Vue from 'vue';\nimport Component from 'vue-class-component';\nimport { Prop, Provide, Watch } from 'vue-property-decorator';\nimport { authManager } from '../../shared/index';\n\n@Component({\n    components: {},\n})\nexport default class AuthLogin extends Vue {\n    code: string = '';\n    processing: boolean = false;\n\n    showCodeError: boolean = false;\n    showInvalidCodeError: boolean = false;\n\n    @Prop({ default: null }) after: string;\n    @Prop({ default: null }) userId: string;\n    @Prop({ default: null }) requestId: string;\n    @Prop() address: string;\n    @Prop({ default: 'email' }) addressTypeToCheck: 'email' | 'phone';\n\n    get codeFieldClass() {\n        return this.showCodeError || this.showInvalidCodeError\n            ? 'md-invalid'\n            : '';\n    }\n\n    get checkAddressTitle() {\n        return `Check your ${\n            this.addressTypeToCheck === 'phone' ? 'phone' : 'email'\n        }`;\n    }\n\n    async created() {\n        this.code = '';\n        this.processing = false;\n    }\n\n    async mounted() {\n        await this._checkLoginStatus();\n    }\n\n    async sendCode() {\n        try {\n            this.processing = true;\n            this.showCodeError = false;\n            this.showInvalidCodeError = false;\n            const code = this.code?.trim();\n\n            if (!code) {\n                this.showCodeError = true;\n                return;\n            } else {\n                const result = await authManager.completeLogin(\n                    this.userId,\n                    this.requestId,\n                    code\n                );\n\n                if (result.success) {\n                    this._checkLoginStatus();\n                } else if (result.success === false) {\n                    if (result.errorCode === 'invalid_code') {\n                        this.showInvalidCodeError = true;\n                    } else if (result.errorCode === 'invalid_request') {\n                        this.cancelLogin();\n                    }\n                    return;\n                }\n            }\n        } finally {\n            this.processing = false;\n        }\n    }\n\n    cancelLogin() {\n        this.$router.push({\n            name: 'login',\n            query: {\n                after: this.after,\n            },\n        });\n    }\n\n    private async _loadInfoAndNavigate() {\n        await authManager.loadUserInfo();\n\n        if (this.after) {\n            this.$router.push({ name: this.after });\n        } else {\n            this.$router.push({ name: 'home' });\n        }\n    }\n\n    private async _checkLoginStatus() {\n        if (authManager.isLoggedIn()) {\n            await this._loadInfoAndNavigate();\n            return true;\n        }\n\n        return false;\n    }\n}\n","\n<div class=\"login-container\">\n    <form @submit.prevent=\"sendCode\">\n        <md-card>\n            <md-card-header>\n                <div class=\"md-title\">{{ checkAddressTitle }}</div>\n            </md-card-header>\n            <md-card-content>\n                <div class=\"md-layout md-gutter\">\n                    <div class=\"md-layout-item\">\n                        <p>\n                            We sent a login code to <strong>{{ address }}</strong\n                            >. Enter it below to complete login.\n                        </p>\n                        <md-field :class=\"codeFieldClass\">\n                            <label for=\"code\">Code</label>\n                            <md-input\n                                name=\"code\"\n                                id=\"code\"\n                                v-model=\"code\"\n                                :disabled=\"processing\"\n                            />\n                            <span v-if=\"showCodeError\" class=\"md-error\"\n                                >Please enter the login code</span\n                            >\n                            <span v-if=\"showInvalidCodeError\" class=\"md-error\"\n                                >The provided code was invalid</span\n                            >\n                        </md-field>\n                    </div>\n                </div>\n            </md-card-content>\n\n            <md-card-actions>\n                <md-button @click=\"cancelLogin()\" :disabled=\"processing\">Cancel</md-button>\n                <md-button type=\"submit\" class=\"md-primary\" :disabled=\"processing\">\n                    <md-progress-spinner\n                        v-if=\"processing\"\n                        md-mode=\"indeterminate\"\n                        :md-diameter=\"20\"\n                        :md-stroke=\"2\"\n                        >Processing</md-progress-spinner\n                    >\n                    <span v-else>Send</span>\n                </md-button>\n            </md-card-actions>\n        </md-card>\n    </form>\n</div>\n","import Vue from 'vue';\nimport Component from 'vue-class-component';\nimport { EventBus, Loading } from '@casual-simulation/aux-components';\nimport { authManager } from '../../shared/index';\n\n@Component({\n    components: {\n        loading: Loading,\n    },\n})\nexport default class AuthLoading extends Vue {\n    loading: boolean = false;\n\n    get version() {\n        return authManager.version;\n    }\n\n    created() {\n        this.loading = false;\n\n        EventBus.$on('startLoading', () => {\n            this.loading = true;\n        });\n        EventBus.$on('stopLoading', () => {\n            this.loading = false;\n        });\n    }\n}\n","\n<div>\n    <loading\n        v-if=\"loading\"\n        :status=\"''\"\n        :progress=\"0\"\n        :error=\"null\"\n        :show=\"loading\"\n        :version=\"version\"\n    >\n    </loading>\n</div>\n","import Vue from 'vue';\nimport Component from 'vue-class-component';\nimport { Prop, Provide, Watch } from 'vue-property-decorator';\n\n@Component({\n    components: {},\n})\nexport default class AuthTerms extends Vue {\n    get origin() {\n        return location.origin;\n    }\n\n    get hostname() {\n        return location.hostname;\n    }\n}\n","\n<div class=\"terms-container\">\n    <md-card>\n        <md-card-header>\n            <h1 class=\"md-title\">{{ hostname }} Terms of Service</h1>\n        </md-card-header>\n        <md-card-content>\n            <p><em>Last updated on April 19th, 2022</em></p>\n            <p>\n                You can find a plain-text version of these terms\n                <a href=\"/terms-of-service.txt\">here</a>.\n            </p>\n            <p>\n                By using our products or services, you agree to these Terms of Service as well\n                as our <a href=\"/acceptable-use-policy\">Acceptable Use Policy</a>\n                and\n                <a href=\"/privacy-policy\">Privacy Policy</a>.\n            </p>\n            <p>We welcome you to use ab1.bot! Casual Simulation offers tools for authoring open source experiences.</p>\n            <p>\n                Please review the entirety of these terms carefully as they apply how your data\n                is used, the rights you have to content you create or share, and more.\n            </p>\n            <div class=\"terms-of-service-content\">\n                <h3 id=\"toc\">\n                    <ol start=\"0\">\n                        <li>Table of Contents</li>\n                    </ol>\n                </h3>\n                <div class=\"table-of-contents\">\n                    <ol start=\"0\">\n                        <li><a href=\"#toc\">Table of Contents</a></li>\n                        <li><a href=\"#about-terms\">About These Terms</a></li>\n                        <li><a href=\"#personal-use-only\">Personal Use Only</a></li>\n                        <li>\n                            <a href=\"#about-accessing-and-using-our-services\"\n                                >About Accessing And Using Our Services</a\n                            >\n                        </li>\n                        <li>\n                            <a href=\"#content-permissions\"\n                                >Content Permissions, Restrictions, and Creative Commons\n                                Licensing</a\n                            >\n                        </li>\n                        <li>\n                            <a href=\"#your-risk-in-accessing-user-content\"\n                                >Your Risk In Accessing User Content</a\n                            >\n                        </li>\n                        <li><a href=\"#warranty-disclaimer\">Warranty Disclaimer</a></li>\n                        <li><a href=\"#limitation-of-liability\">Limitation of Liability</a></li>\n                        <li><a href=\"#indemnity\">Indemnity</a></li>\n                        <li><a href=\"#intellectual-property\">Intellectual Property</a></li>\n                        <li><a href=\"#privacy\">Privacy</a></li>\n                        <li><a href=\"#mandatory-arbitration\">Mandatory Arbitration</a></li>\n                        <li><a href=\"#general-terms\">General Terms</a></li>\n                    </ol>\n                </div>\n                <h3 id=\"about-terms\">\n                    <ol start=\"1\">\n                        <li>About These Terms</li>\n                    </ol>\n                </h3>\n                <p>\n                    These Terms of Service pertain to the legal obligations you assume when you access the following websites:\n                </p>\n                <ul>\n                    <li><a href=\"https://ab1.bot\">ab1.bot</a></li>\n                    <li><a href=\"https://alpha.ab1.bot\">alpha.ab1.bot</a></li>\n                    <li><a href=\"https://static.ab1.bot\">static.ab1.bot</a></li>\n                    <li><a href=\"https://stable.ab1.bot\">stable.ab1.bot</a></li>\n                    <li><a href=\"https://ab1.link\">ab1.link</a></li>\n                    <li><a href=\"https://casualos.com\">casualos.com</a></li>\n                    <li><a href=\"https://alpha.casualos.com\">alpha.casualos.com</a></li>\n                    <li><a href=\"https://static.casualos.com\">static.casualos.com</a></li>\n                    <li><a href=\"https://stable.casualos.com\">stable.casualos.com</a></li>\n                    <li><a href=\"https://publicos.com\">publicos.com</a></li>\n                    <li><a href=\"https://publicos.link\">publicos.link</a></li>\n                    <li><a href=\"https://auxplayer.com\">auxplayer.com</a></li>\n                    <li><a href=\"https://alpha.auxplayer.com\">alpha.auxplayer.com</a></li>\n                    <li><a href=\"https://static.auxplayer.com\">static.auxplayer.com</a></li>\n                    <li><a href=\"https://stable.auxplayer.com\">stable.auxplayer.com</a></li>\n                    <li><a href=\"https://auxplayer.org\">auxplayer.org</a></li>\n                    <li><a href=\"https://static.auxplayer.org\">static.auxplayer.org</a></li>\n                    <li><a href=\"https://stable.auxplayer.org\">stable.auxplayer.org</a></li>\n                    <li><a href=\"https://auxbackend.com\">auxbackend.com</a></li>\n                    <li><a href=\"https://webhook.auxbackend.com\">webhook.auxbackend.com</a></li>\n                    <li><a href=\"https://websocket.auxbackend.com\">websocket.auxbackend.com</a></li>\n                    <li><a href=\"https://docs.casualos.com\">docs.casualos.com</a></li>\n                    <li><a href=\"https://docs.ab1.bot\">docs.ab1.bot</a></li>\n                </ul>\n                <p>\n                    These Terms of Service further relate to any access points, endpoints,\n                    webhooks, or any other services provided at the below above listed domains\n                    (\"Services\") and create a legal agreement between you\n                    (\"you\" or \"your\") and Casual Simulation, Inc, a 501(c)(3) not-for-profit company\n                    registered in Michigan whose address is\n                    879 4 Mile RD NE, Grand Rapids, MI, 49525 (\"Casual Simulation,\" \"we,\" \"us,\" or  \"our\").\n                </p>\n                <p>\n                    If you are using the Services on behalf\n                    of you personally, \"you\" means you individually; if you represent an\n                    organization, \"you\" means your organization. You agree that by accessing our\n                    Services, you are agreeing to these Terms of Service, our Acceptable Use\n                    Policy, and Privacy Policy. If you do not agree with these Terms of Service\n                    THEN YOU SHOULD NOT ACCESS OUR SERVICES.\n                </p>\n                <p>\n                    PLEASE BE AWARE THAT BY USING THE SERVICES, EXCEPT FOR CERTAIN TYPES OF\n                    DISPUTES DESCRIBED IN THE SECTION TITLED \"MANDATORY ARBITRATION\" BELOW, YOU\n                    AGREE THAT ALL DISPUTES BETWEEN YOU AND US WILL BE RESOLVED BY BINDING,\n                    INDIVIDUAL ARBITRATION AND YOU WAIVE YOUR RIGHT TO PARTICIPATE IN A CLASS\n                    ACTION LAWSUIT OR CLASS-WIDE ARBITRATION.\n                </p>\n                <p>\n                    You must be at least 13 years old to access or use the Services. By\n                    accessing or using the Services in any manner, you represent and warrant\n                    that you are at least 13 years of age. If you are under 13 years old, you\n                    may not, under any circumstances or for any reason, access or use the\n                    Services in any manner, and may not provide any personal information to or\n                    on the Services (including, for example, a name, address, telephone number\n                    or email address).\n                </p>\n                <p>\n                    If you are located within the European Union, you must be at least 16 years\n                    old to access or use the Services. By accessing or using the Services in any\n                    manner, you represent and warrant that you are at least 16 years of age. If\n                    you are under 16 years old, you may not, under any circumstances or for any\n                    reason, access or use the Services in any manner, and may not provide any\n                    personal information to or on the Services (including, for example, a name,\n                    address, telephone number or email address).\n                </p>\n                <p>\n                    These Terms of Service, and any rights and licenses granted hereunder, may\n                    not be transferred or assigned by you, but may be assigned by us without\n                    restriction.\n                </p>\n                <p>\n                    <span>You can access these Terms of Service at any time at </span\n                    ><a href=\"/terms\">{{ origin }}/terms</a>. We can make changes to these Terms\n                    of Service at any time and your continued use of our Services shall confirm\n                    your acceptance of the updated Terms of Service whether you have read them\n                    or not. To reiterate, and for clarity, these Terms of Service apply to all\n                    who access or use the Services, including without limitation users who\n                    contribute or author content, information, and other materials or services,\n                    registered or otherwise, in any way.\n                </p>\n                <h3 id=\"personal-use-only\">\n                    <ol start=\"2\">\n                        <li>Personal Use Only</li>\n                    </ol>\n                </h3>\n                <p>\n                    The Services are made available for your personal use only so that\n                    individuals may practice, learn, and experiment with the Services. You may\n                    not \"scrape\" the Services without written permission by us. ab1.bot is\n                    an implementation of CasualOS (<a\n                        href=\"https://github.com/casual-simulation/casualos\"\n                        >https://github.com/casual-simulation/casualos</a\n                    >) and we grant individuals permission to use the Services to create,\n                    display, copy, and download content for personal, non-commercial, and\n                    commercial use provided that you not remove or alter any copyright or other\n                    proprietary notices contained in the content. If you have any questions or\n                    would like an exception please email us at\n                    <a href=\"mailto:hello@casualsimulation.org\">hello@casualsimulation.org</a>\n                    , and we will respond promptly. Speaking broadly, our desire to maximize the\n                    impact and use of the Services without restriction provided it does not\n                    adversely impact our ability to provide Services to the general public or\n                    burden us with additional liability.\n                </p>\n                <p>\n                    ANY ORGANIZATION THAT WOULD LIKE TO MAKE MAKE USE OF OUR SERVICES MUST\n                    NOTIFY US AND, IF APPLICABLE, ALLOW US TO ENTER INTO A SEPARATE AGREEMENT IN\n                    ADVANCE TO ENSURE GENERAL QUALITY OF SERVICE IS NOT ADVERSELY IMPACTED.\n                </p>\n                <p>\n                    Our Services are intended to be free of charge to the general public,\n                    governments, public institutions, educational institutions, and nonprofits\n                    so long as we have the means and funds to provide said Services. Our\n                    Services as regards commercial entities are intended to cover our costs and\n                    ensure continued development and improvement of our Services. If you\n                    represent an organization (even an organization we intend to provide free\n                    Services to) you must notify us before using our Services on behalf of your\n                    organization so we may ensure we can support your use case(s) without\n                    adversely impacting our Services intended to be provided free of charge to\n                    the general public.\n                </p>\n                <p>\n                    Any organization that would like to make commercial use of our Services must\n                    enter into a separate agreement with us in advance to ensure general quality\n                    of service is not adversely impacted. Please contact us at\n                    <a href=\"mailto:hello@casualsimulation.com\">hello@casualsimulation.com</a>\n                    and we will promptly follow up with you.\n                </p>\n                <h3 id=\"about-accessing-and-using-our-services\">\n                    <ol start=\"3\">\n                        <li>About Accessing And Using Our Services</li>\n                    </ol>\n                </h3>\n                <p>\n                    You are responsible for the internet connection and/or mobile charges that\n                    you may incur for accessing our Services. You should ask your mobile\n                    operator if you are unsure what these charges will be before you access our\n                    Services.\n                </p>\n                <p>\n                    We make no claims that Content (defined in Article 4) created by others\n                    utilizing the Services may be lawfully viewed or downloaded outside of the\n                    United States. Access to Services may not be legal by certain persons or in\n                    certain countries. If you access the Services from outside of the United\n                    States, you do so at your own risk and are responsible for compliance with\n                    the laws of your jurisdiction. These Terms of Service are void where\n                    prohibited by law, and the right to access the Services is revoked in such\n                    jurisdictions.\n                </p>\n                <p>\n                    You may not \"scrape\" the website or Services without our written permission.\n                </p>\n                <p>\n                    While we try to ensure that the information on our Services is complete and\n                    accurate, we do not warrant the accuracy and/or completeness of any\n                    information on our Services nor do we guarantee availability of our\n                    Services. We also make no commitment to keep the information on our Services\n                    up to date. The material on our Services is provided \"as is\" without any\n                    conditions, representations, warranties or other terms of any kind. Under no\n                    circumstances will we be liable in any way for any information on our\n                    Services, including, but not limited to, the Services being unavailable, any\n                    errors or omissions in any information, or any losses or harm of any kind\n                    resulting from the use of any information made available via our Services.\n                </p>\n                <p>\n                    We have the right to withdraw or modify our Services (in whole or in part)\n                    without notice and without liability to you from time to time:\n                </p>\n                <ul>\n                    <li>\n                        for technical reasons (such as technical difficulties experienced by us\n                        or on the internet);\n                    </li>\n                    <li>to allow us to improve the experience;</li>\n                    <li>\n                        where we have legal reasons for doing so (including privacy or other\n                        legal objections to the content or conduct of our Services);\n                    </li>\n                    <li>\n                        because it no longer makes business sense for us to provide the relevant\n                        part of the Services; or\n                    </li>\n                    <li>because we have altered the Services we provide.</li>\n                </ul>\n                <p>\n                    There may also be times when our Services or any part of it is not available\n                    for technical or maintenance related reasons, whether on a scheduled or\n                    unscheduled basis.\n                </p>\n                <h3 id=\"content-permissions\">\n                    <ol start=\"4\">\n                        <li>\n                            Content Permissions, Restrictions, and Creative Commons Licensing\n                        </li>\n                    </ol>\n                </h3>\n                <p>\n                    You agree that any and all Content or forms of media, including without\n                    limitation any and all text, software or source code, procedurally,\n                    manually, or artificially generated data, graphics, logos, tools,\n                    photographs, images, illustrations, audio and video, meshes, animations,\n                    modifications, derivatives, and any related product or service feedback, you\n                    provide to the Services (collectively, User Content), shall perpetually\n                    and irrevocably be dedicated to the public domain according to Creative\n                    Commons licensing terms (CC0 1.0).\n                </p>\n                <p>\n                    This means that you dedicate any and all User Content you lawfully create or\n                    share via our Services irrevocably to the public domain by waiving all\n                    rights to the work worldwide under copyright law, including all related and\n                    neighboring rights, to the extent allowed by law. The CC0 1.0 license terms\n                    are explained in further detail by Creative Commons, and the license terms\n                    applicable to content\n                    <a target=\"_blank\" href=\"https://creativecommons.org/publicdomain/zero/1.0/\"\n                        >are explained in further detail here</a\n                    >.\n                </p>\n                <p>\n                    As stated above, by agreeing to these Terms of Service you also agree to be\n                    bound by the terms and conditions of the Acceptable Use Policy (incorporated\n                    herein, and hereby acknowledge and agree that any and all User Content you\n                    provide to the Services is governed by the Acceptable Use Policy.\n                </p>\n                <p>\n                    If you do not agree to this Article 4 or wish or to reserve the right to\n                    create your own intellectual property, trademarks, or file patents please\n                    review Article 9 of this agreement and you must contact us accordingly\n                    within thirty (30) calendar days.\n                </p>\n                <p>\n                    WE DO NOT SHARE OR SELL YOUR DATA OR USER CONTENT INCLUDING ANONYMOUS DATA\n                    OR USER CONTENT.\n                </p>\n                <p>\n                    We delete all User Content from our system that is not published (as\n                    described below) at set intervals. If you would like to preserve your User\n                    Content or establish a separate relationship with us please email us at\n                    <a href=\"mailto:hello@casualsimulation.org\">hello@casualsimulation.org</a>.\n                </p>\n                <p>PLEASE NOTE!</p>\n                <p>\n                    WE DELETE ALL USER CONTENT EVERY 24 HOURS AT APPROXIMATELY 3 AM EASTERN\n                    STANDARD TIME.\n                </p>\n                <p>\n                    WE DELETE ALL USER CONTENT CREATED VIA UNIVERSALLY UNIQUE AUX BUNDLES EVERY\n                    SUNDAY AT 3 AM EASTERN STANDARD TIME.\n                </p>\n                <p>\n                    Publishing User Content is intended for personal use only. We reserve the\n                    right to limit or suspend any excessive use of publishing User Content\n                    (defined at our sole discretion) that impedes our ability to provide the\n                    Services to as wide an audience as possible or increases our costs beyond\n                    what we can presently support or sustain.\n                </p>\n                <p>\n                    For more information on your data and User Content please review our Privacy\n                    Policy.\n                </p>\n                <p>\n                    You must comply with the laws that apply to you in the location that you\n                    access our Services from. IF THE LAWS APPLICABLE TO YOU RESTRICT OR PROHIBIT\n                    YOU FROM ACCESSING OUR SERVICES, YOU MUST COMPLY WITH THOSE LEGAL\n                    RESTRICTIONS OR, IF APPLICABLE, STOP ACCESSING OUR SERVICES.\n                </p>\n                <p>\n                    You agree not to upload, communicate, transmit, or otherwise make available\n                    any User Content:\n                </p>\n                <ul>\n                    <li>\n                        that is or could reasonably be viewed as unlawful, harmful, harassing,\n                        defamatory, libelous, obscene or otherwise objectionable;\n                    </li>\n                    <li>\n                        that is or could reasonably be viewed as invasive of another's privacy;\n                    </li>\n                    <li>\n                        which you do not have a right to make available lawfully (such as inside\n                        information, information which belongs to someone else, confidential\n                        information, or anything that is copyrighted or trademarked);\n                    </li>\n                    <li>\n                        which infringes any intellectual property right or other proprietary\n                        right of us or any other third party; or\n                    </li>\n                    <li>\n                        which contains software viruses or any other computer code, files, data,\n                        or programs designed to interrupt, destroy, or limit the functionality\n                        of our Services, anyone accessing the Services, or any computer\n                        software, hardware, or telecommunications equipment.\n                    </li>\n                </ul>\n                <p>You agree that you will not:</p>\n                <ul>\n                    <li>\n                        remove, amend or modify any proprietary notices or other ownership\n                        information from our Services;\n                    </li>\n                    <li>\n                        interfere with or disrupt our Services, servers or networks that support\n                        or provide our Services;\n                    </li>\n                    <li>\n                        attempt to defeat or overcome any of our encryption technologies or\n                        security measures or data transmitted, processed or stored by us;\n                    </li>\n                    <li>\n                        collect any information about or regarding other people that use our\n                        Services, including, but not limited to any personal data or analytical\n                        information;\n                    </li>\n                    <li>\n                        use our Services in violation of any applicable law or regulation; or\n                    </li>\n                    <li>\n                        use our Services in any other way not permitted by these Terms of\n                        Service, our Acceptable Use Policy, or our Privacy Policy.\n                    </li>\n                </ul>\n                <h3 id=\"your-risk-in-accessing-user-content\">\n                    <ol start=\"5\">\n                        <li>Your Risk In Accessing User Content</li>\n                    </ol>\n                </h3>\n                <p>\n                    ANY USER CONTENT YOU ACCESS IS AT YOUR OWN RISK. WE STORE PUBLISHED USER\n                    CONTENT IN AUX BUNDLES \"AS IS.\" YOU ACKNOWLEDGE THAT ACCESSING USER CONTENT\n                    THAT CONTAINS MALWARE OR OTHER MALICIOUS CODE IS POSSIBLE AND INHERENTLY\n                    RISKY. YOU SHOULD ONLY ACCESS USER CONTENT CREATED BY SOURCES YOU TRUST AND\n                    SHOULD PROCEED WITH EXTREME CAUTION.\n                </p>\n                <h3 id=\"warranty-disclaimer\">\n                    <ol start=\"6\">\n                        <li>Warranty Disclaimer</li>\n                    </ol>\n                </h3>\n                <p>\n                    THE SERVICES AND THE CONTENT ON THE SERVICES THAT IS MADE AVAILABLE TO YOU\n                    ARE PROVIDED ON AN \"AS IS\" AND &quot;AS AVAILABLE&quot; BASIS, WITHOUT\n                    WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, WITHOUT\n                    LIMITATION, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n                    PURPOSE OR NON-INFRINGEMENT. WE DO NOT WARRANT OR MAKE ANY REPRESENTATIONS\n                    REGARDING THE AVAILABILITY, USE, TIMELINESS, SECURITY, VALIDITY, ACCURACY,\n                    OR RELIABILITY OF, OR THE RESULTS OF THE USE OF, OR OTHERWISE RESPECTING,\n                    THE SERVICES. ANY MATERIAL, CONTENT, OR USER CONTENT DOWNLOADED OR OTHERWISE\n                    OBTAINED THROUGH THE USE OF THE SERVICES IS DONE AT YOUR OWN DISCRETION AND\n                    RISK AND YOU ARE SOLELY RESPONSIBLE FOR ANY DAMAGE TO YOUR COMPUTER SYSTEM\n                    OR LOSS OF DATA THAT RESULTS FROM THE DOWNLOAD OF ANY SUCH MATERIAL, OR USE\n                    OF THE SERVICES INCLUDING ANY LEGAL LIABILITY YOU MAY ASSUME BY CREATING,\n                    DOWNLOADING, OR OTHERWISE INTERACTING WITH USER CONTENT TO THE FULLEST\n                    EXTENT BY LAW. SOME JURISDICTIONS DO NOT ALLOW THE EXCLUSIONS OR LIMITATIONS\n                    ON HOW LONG AN IMPLIED WARRANTY LASTS, SO THE ABOVE LIMITATIONS OR\n                    EXCLUSIONS MAY NOT APPLY. NO ADVICE OR INFORMATION, WHETHER ORAL OR WRITTEN,\n                    OBTAINED BY YOU FROM US SHALL BE DEEMED TO ALTER THIS DISCLAIMER OF\n                    WARRANTY, OR TO CREATE ANY WARRANTY.\n                </p>\n                <h3 id=\"limitation-of-liability\">\n                    <ol start=\"7\">\n                        <li>Limitation of Liability</li>\n                    </ol>\n                </h3>\n                <p>\n                    IN NO EVENT SHALL WE, OUR OFFICERS, DIRECTORS, EMPLOYEES, OR AGENTS, BE\n                    LIABLE TO YOU FOR ANY (I) INDIRECT, INCIDENTAL, SPECIAL, PUNITIVE, OR\n                    CONSEQUENTIAL DAMAGES WHATSOEVER RESULTING FROM ANY (A) ERRORS, MISTAKES, OR\n                    INACCURACIES OF CONTENT, (B) PERSONAL INJURY OR PROPERTY DAMAGE, OF ANY\n                    NATURE WHATSOEVER, RESULTING FROM YOUR ACCESS TO AND USE OF OUR SERVICES;\n                    (II) UNAUTHORIZED ACCESS TO OR USE OF OUR SECURE SERVERS AND/OR ANY AND ALL\n                    PERSONAL INFORMATION AND/OR FINANCIAL INFORMATION STORED THEREIN, (III)\n                    INTERRUPTION OR CESSATION OF TRANSMISSION TO OR FROM OUR SERVICES, (IV)\n                    BUGS, VIRUSES, TROJAN HORSES, OR THE LIKE, WHICH MAY BE TRANSMITTED TO OR\n                    THROUGH OUR SERVICES BY ANY THIRD PARTY, (V) ERRORS OR OMISSIONS IN ANY\n                    CONTENT OR FOR ANY LOSS OR DAMAGE OF ANY KIND INCURRED AS A RESULT OF YOUR\n                    USE OF ANY CONTENT POSTED, EMAILED, TRANSMITTED, OR OTHERWISE MADE AVAILABLE\n                    VIA THE SERVICES, WHETHER BASED ON WARRANTY, CONTRACT, TORT, OR ANY OTHER\n                    LEGAL THEORY, OR (VI) DIRECT DAMAGES IN EXCESS OF $100; WHETHER OR NOT WE\n                    ARE ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. SOME STATES DO NOT ALLOW THE\n                    EXCLUSION OR LIMITATION OF INCIDENTAL OR CONSEQUENTIAL DAMAGES; THE\n                    FOREGOING LIMITATION OF LIABILITY SHALL APPLY TO THE FULLEST EXTENT\n                    PERMITTED BY LAW IN THE APPLICABLE JURISDICTION.\n                </p>\n                <h3 id=\"indemnity\">\n                    <ol start=\"8\">\n                        <li>Indemnity</li>\n                    </ol>\n                </h3>\n                <p>\n                    You agree to defend, indemnify, and hold harmless us, our officers,\n                    directors, employees, agents, affiliates, parents and subsidiaries from and\n                    against any and all claims, damages, obligations, losses, liabilities, costs\n                    or debt, and expenses (including but not limited to attorney&rsquo;s fees)\n                    arising from: (i) your use of and access to the Services; or (ii) your\n                    violation of any term of these Terms of Service. This defense and\n                    indemnification obligation will survive these Terms of Service and your use\n                    of the Services. For clarification, you agree to compensate us, according to\n                    law, for all losses, harm, claims and expenses that may arise from any\n                    breach of these terms by you.\n                </p>\n                <h3 id=\"intellectual-property\">\n                    <ol start=\"9\">\n                        <li>Intellectual Property</li>\n                    </ol>\n                </h3>\n                <p>\n                    EXCEPT AS PERTAINING TO USER CONTENT, YOU ACKNOWLEDGE THAT ALL COPYRIGHT,\n                    TRADEMARKS, AND OTHER INTELLECTUAL PROPERTY RIGHTS IN AND RELATING TO OUR\n                    SERVICES ARE OWNED BY OR LICENSED TO US. YOU SHALL NOT TAKE ANY ACTION TO\n                    JEOPARDIZE, LIMIT, OR INTERFERE WITH ANY OF OUR INTELLECTUAL PROPERTY RIGHTS\n                    NOW OR IN THE FUTURE, INCLUDING WITHOUT LIMITATION TRADEMARKING, PATENTING,\n                    OR CREATING ANY WORK OR INTELLECTUAL PROPERTY THAT WOULD PRECLUDE US OR\n                    OTHERS FROM FULLY UTILIZING THE SERVICES. BY USING THE SERVICES YOU\n                    ACKNOWLEDGE AND AGREE THESE TERMS.\n                </p>\n                <p>\n                    IF YOU DO NOT AGREE TO THESE TERMS YOU MUST CONTACT US IN WRITING WITH\n                    THIRTY (30) CALENDAR DAYS OF USING THE SERVICES AT\n                    <a href=\"mailto:hello@casualsimulation.org\">hello@casualsimulation.org</a>\n                    TO NOTIFY US OF YOUR DESIRE TO RESERVE THE RIGHT TO TRADEMARK OR PATENT ANY\n                    USER CONTENT CREATED IN WHOLE AND PART BY USE OF THE SERVICES SO THAT WE MAY\n                    ENTER INTO A SEPARATE AGREEMENT WITH YOU AS ANY USER CONTENT YOU CREATE\n                    SHALL CREATIVE COMMONS (see Article 5).\n                </p>\n                <p>\n                    While you are in compliance with these terms, our Acceptable Use Policy, and\n                    our Privacy Policy, we grant you a non-exclusive, non-transferable,\n                    personal, revocable limited license to access and use our Services, in each\n                    case provided that such use is in accordance with these terms. You agree not\n                    to use our Services, or any elements thereof, for anything else.\n                </p>\n                <p>\n                    We appreciate your feedback and suggestions. Our goal is to provide high\n                    quality products and services. Our ability to freely evaluate and, if\n                    appropriate, implement ideas and information improves the online experience\n                    for all users. Therefore, any information, feedback, data, questions,\n                    comments, suggestions, or any other material or proposals, submitted to us,\n                    whether solicited or unsolicited, regarding its services or web site shall\n                    be deemed non-confidential unless mutually agreed between us and you in\n                    writing. By providing any such material, you hereby grant us an\n                    unrestricted, irrevocable, royalty-free and perpetual right to freely,\n                    reproduce, use, disclose, modify, perform, publish, translate, create\n                    derivative works from, distribute and display any such information you send\n                    us, without limitation, for any and all commercial and non-commercial\n                    purposes. We are free to use any ideas, concepts or techniques contained in\n                    this response for any purpose whatsoever including, but not limited to,\n                    developing, manufacturing, and marketing products incorporating such ideas,\n                    concepts or techniques.\n                </p>\n                <h3 id=\"privacy\">\n                    <ol start=\"10\">\n                        <li>Privacy</li>\n                    </ol>\n                </h3>\n                <p>\n                    We will only collect, process, use, and share your personal information in\n                    accordance with our Privacy Policy and as set out in these Terms of Service.\n                    IF YOU DO NOT AGREE TO OUR PRIVACY POLICY, YOU SHOULD NOT CONTINUE TO ACCESS\n                    OUR SERVICES.\n                </p>\n                <p>\n                    We may use cookies to store certain types of information each time you use\n                    our Services. They may for example be used to help us recognize what kind of\n                    device you are using. You can find out more about how we use cookies by\n                    reading our Privacy Policy.\n                </p>\n                <h3 id=\"mandatory-arbitration\">\n                    <ol start=\"11\">\n                        <li>\n                            <h4>Mandatory Arbitration</h4>\n                        </li>\n                    </ol>\n                </h3>\n                <p>\n                    YOU AGREE THAT WITH RESPECT TO ALL DISPUTES BETWEEN YOU AND US OR OUR\n                    AFFILIATES, OFFICERS, DIRECTORS, OR EMPLOYEES (WHETHER OR NOT SUCH DISPUTE\n                    INVOLVES A THIRD PARTY) WITH REGARD TO YOUR RELATIONSHIP WITH US, INCLUDING\n                    WITHOUT LIMITATION DISPUTES RELATING TO THESE TERMS OF SERVICE, YOUR USE OF\n                    THE SERVICES, AND/OR RIGHTS OF PRIVACY AND/OR PUBLICITY, YOU AND US SHALL\n                    FIRST CONSULT WITH EACH OTHER TO ATTEMPT TO RESOLVE SUCH DISPUTE IN A MANNER\n                    SATISFACTORY TO BOTH PARTIES, AND THAT IF A RESOLUTION IS NOT REACHED WITHIN\n                    ONE HUNDRED EIGHTY (180) DAYS, THEN THE DISPUTE SHALL BE REFERRED TO AND\n                    RESOLVED BY BINDING ARBITRATION UNDER JAMS, INC.&rsquo;S RULES FOR\n                    ARBITRATION OF CONSUMER-RELATED DISPUTES AND YOU AND WE HEREBY EXPRESSLY\n                    WAIVE TRIAL BY JURY; PROVIDED, HOWEVER, THAT TO THE EXTENT THAT YOU HAVE IN\n                    ANY MANNER VIOLATED OR THREATENED TO VIOLATE OUR INTELLECTUAL PROPERTY\n                    RIGHTS, WE MAY SEEK INJUNCTIVE OR OTHER APPROPRIATE RELIEF IN ANY STATE OR\n                    FEDERAL COURT IN THE STATE OF MICHIGAN. DISCOVERY AND RIGHTS TO APPEAL IN\n                    ARBITRATION ARE GENERALLY MORE LIMITED THAN IN A LAWSUIT, AND OTHER RIGHTS\n                    THAT YOU AND WE WOULD HAVE IN COURT MAY NOT BE AVAILABLE IN ARBITRATION.\n                </p>\n                <p>\n                    As an alternative, you may bring your claim in your local \"small claims\"\n                    court, if permitted by that small claims court&rsquo;s rules and if within\n                    such court&rsquo;s jurisdiction, unless such action is transferred, removed,\n                    or appealed to a different court. You may bring claims only on your own\n                    behalf. Neither you nor we will participate in a class action or class-wide\n                    arbitration for any claims covered by this agreement to arbitrate.\n                </p>\n                <p>\n                    YOU ARE GIVING UP YOUR RIGHT TO PARTICIPATE AS A CLASS REPRESENTATIVE OR\n                    CLASS MEMBER ON ANY CLASS CLAIM YOU MAY HAVE AGAINST US INCLUDING ANY RIGHT\n                    TO CLASS ARBITRATION OR ANY CONSOLIDATION OF INDIVIDUAL ARBITRATIONS.\n                </p>\n                <p>\n                    You also agree not to participate in claims brought in a private or\n                    representative capacity, or consolidated claims involving another\n                    person&rsquo;s account, if we are a party to the proceeding. This dispute\n                    resolution provision will be governed by the Federal Arbitration Act and not\n                    by any state law concerning arbitration. In the event JAMS, INC. is\n                    unwilling or unable to set a hearing date within one hundred and sixty (160)\n                    days of filing the case, then either we or you can elect to have the\n                    arbitration administered instead by the American Arbitration Association.\n                    Judgment on the award rendered by the arbitrator may be entered in any court\n                    having competent jurisdiction. Any provision of applicable law\n                    notwithstanding, the arbitrator will not have authority to award damages,\n                    remedies, or awards that conflict with these Terms of Service. You agree\n                    that regardless of any statute or law to the contrary, any claim or cause of\n                    action arising out of, related to or connected with the use of the Services\n                    must be filed within one (1) year after such claim of action arose or be\n                    forever banned.\n                </p>\n                <p>\n                    You agree that, notwithstanding anything in the foregoing, any arbitration\n                    proceeding between you and us will be conducted in Kent County, Grand\n                    Rapids, Michigan, and that the language of the arbitration shall be in\n                    English, and that all arbitration proceedings shall be considered\n                    confidential in nature.\n                </p>\n                <p>\n                    If you don&rsquo;t want to be bound by the arbitration and class-action\n                    waiver provisions in this section, you must notify us in writing within\n                    thirty (30) days of the date that you first accept these Terms of Service\n                    (unless a longer period is required by applicable law), and then you must\n                    litigate any disputes against us in accordance with the \"Assignment and\n                    Jurisdiction\" section below.\n                </p>\n                <p>\n                    Your written notification must be mailed to us at Casual Simulation Inc.,\n                    Attn: Legal Department, 879 4 Mile RD NE, Grand Rapids, MI 49525 or by email\n                    notification at\n                    <a href=\"mailto:hello@casualsimulation.org\">hello@casualsimulation.org</a>.\n                    If you do not notify us in accordance with this paragraph, you agree to be\n                    bound by the terms of this section, including, without limitation, the\n                    arbitration and class-action waiver provisions, and also including such\n                    provisions in any modifications we make to these Terms of Service after the\n                    date of your first acceptance. Such notification must include: (i) your\n                    name; (ii) your email address and mailing address; and (iii) a statement\n                    that you do not wish to resolve disputes with us through arbitration or\n                    waive your ability to participate in a class action. If we make any changes\n                    to this section (other than a change to the address at which we will receive\n                    notices or rejections of future changes to this section), you may reject any\n                    such change by sending us written notice, within thirty (30) days of the\n                    change, to the address set out in the \"Notices\" section. It is not necessary\n                    to send us a rejection of a future change to this section if you had\n                    properly opted out within the first thirty (30) days after you first\n                    accepted the provisions in this section. If you have not properly opted out,\n                    then by rejecting a future change, you are agreeing that you will arbitrate\n                    any dispute between us in accordance with the language of this section, as\n                    modified by any changes you did not reject. A notification sent pursuant to\n                    this paragraph solely affects these Terms of Service; if you previously\n                    entered into other arbitration or dispute resolution agreements with us or\n                    enter into other such agreements in the future, your notification that you\n                    are opting out of the provisions in this section shall not affect the other\n                    arbitration agreements between you and us.\n                </p>\n                <h3 id=\"general-terms\">\n                    <ol start=\"12\">\n                        <li>General Terms</li>\n                    </ol>\n                </h3>\n                <p>\n                    If any part of these terms is held to be invalid or unenforceable under any\n                    applicable local laws or by an applicable court, that part shall be\n                    interpreted in a manner consistent with applicable law to reflect as nearly\n                    as possible our original intentions and the remainder of these terms shall\n                    remain valid and enforceable.\n                </p>\n                <p>\n                    Our failure to exercise or enforce any of our rights under these terms does\n                    not waive our right to enforce such right. Any waiver of such rights shall\n                    only be effective if it is in writing and signed by us.\n                </p>\n                <p>\n                    No agency, partnership, joint venture, or employment is created as a result\n                    of these Terms of Service and you do not have any authority of any kind to\n                    bind us in any respect whatsoever.\n                </p>\n                <p>\n                    The sections entitled \"About These Terms\", \"Personal Use Only \", \"About\n                    Accessing And Using Our Services\", \"User Conduct and Content\", \"Your Breach\n                    of These Terms\", \"Warranty Disclaimer \", \"Limitation of Liability\",\n                    \"Indemnity\", \"Intellectual Property\", \"Privacy\", \"Mandatory Arbitration\",\n                    and \"General Terms\" shall survive any termination or expiration of these\n                    Terms of Service.\n                </p>\n                <p>\n                    These Terms of Service shall be governed by the laws of the Kent County of\n                    the State of Michigan, without respect to its conflict of laws principles.\n                    Any claim or dispute between you and us that arises in whole or in part from\n                    the Site shall be decided exclusively by a court of competent jurisdiction\n                    located in Kent County, Michigan. These Terms of Service, together with our\n                    Privacy Policy, constitute the entire agreement between you and us\n                    concerning your access to and use of the Services.\n                </p>\n            </div>\n        </md-card-content>\n    </md-card>\n</div>\n","import Vue from 'vue';\nimport Component from 'vue-class-component';\nimport { Prop, Provide, Watch } from 'vue-property-decorator';\n\n@Component({\n    components: {},\n})\nexport default class AuthTerms extends Vue {\n    get origin() {\n        return location.origin;\n    }\n\n    get hostname() {\n        return location.hostname;\n    }\n}\n","\n<div class=\"privacy-policy-container\">\n    <md-card>\n        <md-card-header>\n            <h1 class=\"md-title\">{{ hostname }} Privacy Policy</h1>\n        </md-card-header>\n        <md-card-content>\n            <p><em>Last updated on April 6th, 2022</em></p>\n            <p>\n                You can find a plain-text version of this privacy policy\n                <a href=\"/privacy-policy.txt\">here</a>.\n            </p>\n\n            <p>\n                By using our products or services, you agree to this Privacy Policy as well as our \n                <a href=\"/acceptable-use-policy\">Acceptable Use Policy</a> and <a href=\"/terms\">Terms of Service</a>.\n            </p>\n\n            <div class=\"privacy-policy-content\">\n                <h3 id=\"toc\">\n                    <ol start=\"0\">\n                        <li>Table of Contents</li>\n                    </ol>\n                </h3>\n                <div class=\"table-of-contents\">\n                    <ol start=\"0\">\n                        <li><a href=\"#toc\">Table of Contents</a></li>\n                        <li><a href=\"#introduction\">Introduction</a></li>\n                        <li><a href=\"#personal-information\">Personal Information</a></li>\n                        <li><a href=\"#cached-data\">Cached Data</a></li>\n                        <li><a href=\"#links-from-our-services\">Links From Our Services</a></li>\n                    </ol>\n                </div>\n\n                <h3 id=\"introduction\">\n                    <ol start=\"1\">\n                        <li>Introduction</li>\n                    </ol>\n                </h3>\n                <p>\n                    Casual Simulation offers tools for authoring open source experiences.\n                    We at Casual Simulation Inc. strive to respect the privacy of everyone to the best of our ability.\n                    This document describes how we collect, process, and store personal data.\n                </p>\n                <p>\n                    To that end, we provide you with this Privacy Policy to advise you of how your data may be collected or used when you access the following websites:\n                </p>\n                <ul>\n                    <li><a href=\"https://ab1.bot\">ab1.bot</a></li>\n                    <li><a href=\"https://alpha.ab1.bot\">alpha.ab1.bot</a></li>\n                    <li><a href=\"https://static.ab1.bot\">static.ab1.bot</a></li>\n                    <li><a href=\"https://stable.ab1.bot\">stable.ab1.bot</a></li>\n                    <li><a href=\"https://ab1.link\">ab1.link</a></li>\n                    <li><a href=\"https://casualos.com\">casualos.com</a></li>\n                    <li><a href=\"https://alpha.casualos.com\">alpha.casualos.com</a></li>\n                    <li><a href=\"https://static.casualos.com\">static.casualos.com</a></li>\n                    <li><a href=\"https://stable.casualos.com\">stable.casualos.com</a></li>\n                    <li><a href=\"https://publicos.com\">publicos.com</a></li>\n                    <li><a href=\"https://publicos.link\">publicos.link</a></li>\n                    <li><a href=\"https://auxplayer.com\">auxplayer.com</a></li>\n                    <li><a href=\"https://alpha.auxplayer.com\">alpha.auxplayer.com</a></li>\n                    <li><a href=\"https://static.auxplayer.com\">static.auxplayer.com</a></li>\n                    <li><a href=\"https://stable.auxplayer.com\">stable.auxplayer.com</a></li>\n                    <li><a href=\"https://auxplayer.org\">auxplayer.org</a></li>\n                    <li><a href=\"https://static.auxplayer.org\">static.auxplayer.org</a></li>\n                    <li><a href=\"https://stable.auxplayer.org\">stable.auxplayer.org</a></li>\n                    <li><a href=\"https://auxbackend.com\">auxbackend.com</a></li>\n                    <li><a href=\"https://webhook.auxbackend.com\">webhook.auxbackend.com</a></li>\n                    <li><a href=\"https://websocket.auxbackend.com\">websocket.auxbackend.com</a></li>\n                    <li><a href=\"https://docs.casualos.com\">docs.casualos.com</a></li>\n                    <li><a href=\"https://docs.ab1.bot\">docs.ab1.bot</a></li>\n                </ul>\n                <p>\n                    This Privacy Policy further relates to access points, endpoints, webhooks, or any other services provided by this or the above listed websites (&ldquo;Services&rdquo;).\n                    This Privacy Policy creates a legal agreement between you (&ldquo;you&rdquo; or &ldquo;your&rdquo;) and\n                    Casual Simulation, Inc, a 501(c)(3) not-for-profit company registered in Michigan\n                    whose address is 879 4 Mile RD NE, Grand Rapids, MI, 49525 (&ldquo;Casual Simulation,&rdquo; &ldquo;we,&rdquo; &ldquo;us,&rdquo; or  &ldquo;our&rdquo;). \n                </p>\n                <p>\n                    If you are using the Services on\n                    behalf of you personally, &ldquo;you&rdquo; means you individually; if you\n                    represent an organization, &ldquo;you&rdquo; means your organization. You\n                    agree that by accessing our Services, you are agreeing to these terms. If\n                    you do not agree with these terms THEN YOU SHOULD NOT ACCESS OUR SERVICES.\n                </p>\n                <h3 id=\"personal-information\">\n                    <ol start=\"2\">\n                        <li>Personal Information</li>\n                    </ol>\n                </h3>\n                <p>\n                    WE DO NOT SHARE OR SELL YOUR DATA OR USER CONTENT INCLUDING ANONYMOUS DATA\n                    OR USER CONTENT.\n                </p>\n                <p>\n                    If you wish to use the Services anonymously and free of charge simply launch\n                    any instance at <a target=\"_blank\" href=\"https://ab1.bot\">ab1.bot</a> (a new instance is automatically created when you visit the website), create any User Content, and then download your\n                    User Content.\n                </p>\n                <p>\n                    If you access the Services at all we reserve the collect anonymous usage data regarding your use\n                    of the Services for debugging purposes and to improve the Services.\n                    We post publicly available analytics of our website traffic at <a target=\"_blank\" href=\"https://simpleanalytics.com/ab1.bot\">https://simpleanalytics.com/ab1.bot</a>.\n                    WE DO NOT SHARE OR SELL THIS DATA other than described in this paragraph.\n                </p>\n                <p>\n                    You must create an account and login to publish User Content via aux bundles\n                    that are not deleted every 24 hours. If you create an account we collect\n                    your name and email address and provide your name and email address the\n                    following affiliates:\n                </p>\n                <p>\n                    <strong>Magic.link</strong>: we use\n                    <a target=\"_blank\" href=\"https://magic.link/\">magic.link</a> for\n                    authentication and only provide them your email. Please review\n                    magic.link&rsquo;s Terms of Service (<a\n                        target=\"_blank\"\n                        href=\"https://magic.link/legal/user-terms\"\n                        >https://magic.link/legal/user-terms</a\n                    >) for more information on how\n                    <a target=\"_blank\" href=\"https://magic.link/\">magic.link</a> may use your\n                    data.\n                </p>\n                <p>\n                    <strong>Readyplayer.me</strong>: we use\n                    <a target=\"_blank\" href=\"https://readyplayer.me\">readyplayer.me</a>&rsquo;s\n                    avatar services to create avatars for your use. We provide readyplayer.me\n                    your name and email to do so.\n                    <br />\n                    Please review\n                    <a target=\"_blank\" href=\"https://readyplayer.me\">readyplayer.me</a>'s Terms\n                    of Service (<a\n                        href=\"https://drive.google.com/file/d/1ER3gBvx1UwXMDiOaZk8akzPmO6LAFfTp/view\"\n                        >https://drive.google.com/file/d/1ER3gBvx1UwXMDiOaZk8akzPmO6LAFfTp/view</a\n                    >) for more information on how\n                    <a target=\"_blank\" href=\"https://readyplayer.me\">readyplayer.me</a> may use\n                    your data.\n                </p>\n                <p>\n                    After creating an account and logging in, your User Content you publish via\n                    aux bundles are stored &ldquo;as is&rdquo; by use of public <a target=\"_blank\" href=\"https://docs.casualos.com/docs/glossary#record\">CasualOS Records</a>.\n                    This means any unencrypted data you publish is publically available and\n                    can be accessed by anyone who discovers it. ANY ENCRYPTED DATA YOU PUBLISHED\n                    IS STORED &ldquo;AS IS&rdquo; AND WE DO NOT HAVE THE MEANS TO UNENCRYPT IT\n                    NOR WILL WE ATTEMPT TO.\n                </p>\n                <p>\n                    We reserve the right to provide any of your data or User Content to a\n                    government or government&rsquo;s lawful authorities only when mandated or\n                    compelled by law, and we may or may not notify you of this as may be\n                    required by law.\n                </p>\n                <h3 id=\"cached-data\">\n                    <ol start=\"3\">\n                        <li>Cached Data</li>\n                    </ol>\n                </h3>\n                <p>\n                    We sometimes create and utilize cached data on your device as may be\n                    necessary, at times, to use our Services or otherwise make our Services\n                    easier to use. Cached data is similar to Cookies in that data is stored\n                    locally on your device depending upon what portions of the Services you use.\n                </p>\n                <p>We will NOT use cached data or similar technologies to:</p>\n                <ul>\n                    <li>identify your IP address or track you</li>\n                    <li>\n                        store any personally identifiable information except as may be\n                        temporarily necessary to facilitate a transaction.\n                    </li>\n                </ul>\n                <p>\n                    We or those who use are Services may use cached data and similar\n                    technologies:\n                </p>\n                <ul>\n                    <li>\n                        to provide you with a better experience via reduced loading times and\n                        allow for offline capability\n                    </li>\n                    <li>\n                        to store local data on your device related to a specific experience\n                        contained within our Services\n                    </li>\n                    <li>\n                        to allow our Services to interact with a third party social network or\n                        platform;\n                    </li>\n                    <li>to allow a payment processor to process your payment instructions;</li>\n                    <li>\n                        to provide you with more customized Services, for example to provide our\n                        Services in the correct language;\n                    </li>\n                    <li>\n                        to obtain data which will allow us to understand how people are using\n                        our Services so that we can improve them.\n                    </li>\n                </ul>\n                <p>\n                    By accessing or using our Services you consent to our use of cached data in\n                    accordance with this Privacy Policy. You can clear cached data by deleting\n                    it from your device.\n                </p>\n                <p>\n                    YOU ACCESS USER CREATED CONTENT AT YOUR OWN RISK AND USER CREATED CONTENT\n                    MAY TRACK YOU, PUT ANY KIND OF CASHED DATA ON YOUR DEVICE (INCLUDING\n                    MALICIOUS CODE) OR USE YOUR DATA IN OTHER WAYS WE CANNOT FORESEE OR PREVENT.\n                </p>\n                <h3 id=\"links-from-our-services\">\n                    <ol start=\"4\">\n                        <li>Links from our Services</li>\n                    </ol>\n                </h3>\n                <p>\n                    We may provide links to third party websites or services from our Services.\n                    You understand that when you click on these links any data which you provide\n                    thereafter is subject to such a third party&#39;s privacy policy and not\n                    ours. Although we will endeavor only to link to reputable Services, we take\n                    no responsibility for the content, safety, or security of any third party\n                    Services.\n                </p>\n            </div>\n        </md-card-content>\n    </md-card>\n</div>\n","import Vue from 'vue';\nimport Component from 'vue-class-component';\nimport { Prop, Provide, Watch } from 'vue-property-decorator';\n\n@Component({\n    components: {},\n})\nexport default class AuthTerms extends Vue {\n    get origin() {\n        return location.origin;\n    }\n\n    get hostname() {\n        return location.hostname;\n    }\n}\n","\n<div class=\"acceptable-use-policy-container\">\n    <md-card>\n        <md-card-header>\n            <h1 class=\"md-title\">Casual Simulation Web Services Acceptable Use Policy</h1>\n        </md-card-header>\n        <md-card-content>\n            <p><em>Last updated on April 6th, 2022</em></p>\n            <p>\n                You can find a plain-text version of this acceptable use policy\n                <a href=\"/acceptable-use-policy.txt\">here</a>.\n            </p>\n            <p>\n                By using our products or services, you agree to this Acceptable Use Policy as\n                well as our <a href=\"/terms\">Terms of Service</a> and <a href=\"/privacy-policy\">Privacy Policy</a>.\n            </p>\n            <div class=\"acceptable-use-policy-content\">\n                <h3 id=\"toc\">\n                    <ol start=\"0\">\n                        <li>Table of Contents</li>\n                    </ol>\n                </h3>\n                <div class=\"table-of-contents\">\n                    <ol start=\"0\">\n                        <li><a href=\"#toc\">Table of Contents</a></li>\n                        <li><a href=\"#about-policy\">About this Acceptable Use Policy</a></li>\n                        <li><a href=\"#illegal-use\">Illegal Use</a></li>\n                        <li><a href=\"#spam\">Spam</a></li>\n                        <li>\n                            <a href=\"#identity-theft-and-privacy\">Identity Theft and Privacy</a>\n                        </li>\n                        <li><a href=\"#hate-content\">Hate Content, Defamation, and Libel</a></li>\n                        <li>\n                            <a href=\"#disruptions-and-exploits\">Disruptions and Exploits</a>\n                        </li>\n                        <li><a href=\"#copyright\">Copyright</a></li>\n                        <li>\n                            <a href=\"#mass-registration\">Mass Registration and Automation</a>\n                        </li>\n                        <li>\n                            <a href=\"#sexually-explicit-material\">Sexually Explicit Material</a>\n                        </li>\n                    </ol>\n                </div>\n                <h3 id=\"about-policy\">\n                    <ol start=\"1\">\n                        <li>About this Acceptable Use Policy</li>\n                    </ol>\n                </h3>\n                <p>\n                    This Acceptable Use Policy pertains to the legal obligations you assume when you access the following websites:\n                </p>\n                <ul>\n                    <li><a href=\"https://ab1.bot\">ab1.bot</a></li>\n                    <li><a href=\"https://alpha.ab1.bot\">alpha.ab1.bot</a></li>\n                    <li><a href=\"https://static.ab1.bot\">static.ab1.bot</a></li>\n                    <li><a href=\"https://stable.ab1.bot\">stable.ab1.bot</a></li>\n                    <li><a href=\"https://ab1.link\">ab1.link</a></li>\n                    <li><a href=\"https://casualos.com\">casualos.com</a></li>\n                    <li><a href=\"https://alpha.casualos.com\">alpha.casualos.com</a></li>\n                    <li><a href=\"https://static.casualos.com\">static.casualos.com</a></li>\n                    <li><a href=\"https://stable.casualos.com\">stable.casualos.com</a></li>\n                    <li><a href=\"https://publicos.com\">publicos.com</a></li>\n                    <li><a href=\"https://publicos.link\">publicos.link</a></li>\n                    <li><a href=\"https://auxplayer.com\">auxplayer.com</a></li>\n                    <li><a href=\"https://alpha.auxplayer.com\">alpha.auxplayer.com</a></li>\n                    <li><a href=\"https://static.auxplayer.com\">static.auxplayer.com</a></li>\n                    <li><a href=\"https://stable.auxplayer.com\">stable.auxplayer.com</a></li>\n                    <li><a href=\"https://auxplayer.org\">auxplayer.org</a></li>\n                    <li><a href=\"https://static.auxplayer.org\">static.auxplayer.org</a></li>\n                    <li><a href=\"https://stable.auxplayer.org\">stable.auxplayer.org</a></li>\n                    <li><a href=\"https://auxbackend.com\">auxbackend.com</a></li>\n                    <li><a href=\"https://webhook.auxbackend.com\">webhook.auxbackend.com</a></li>\n                    <li><a href=\"https://websocket.auxbackend.com\">websocket.auxbackend.com</a></li>\n                    <li><a href=\"https://docs.casualos.com\">docs.casualos.com</a></li>\n                    <li><a href=\"https://docs.ab1.bot\">docs.ab1.bot</a></li>\n                </ul>\n                <p>\n                    This Acceptable Use Policy further relates to any access points, endpoints, webhooks, \n                    or any other services provided at the below above listed domains (&ldquo;Services&rdquo;)\n                    and create a legal agreement between you (&ldquo;you&rdquo; or &ldquo;your&rdquo;) and Casual Simulation, Inc, a 501(c)(3) not-for-profit\n                    company registered in Michigan whose address is \n                    879 4 Mile RD NE, Grand Rapids, MI, 49525 (&ldquo;Casual Simulation,&rdquo; &ldquo;we,&rdquo; &ldquo;us,&rdquo; or  &ldquo;our&rdquo;).\n                </p>\n                <p>\n                    If you are using the Site on behalf of you\n                    personally, &ldquo;you&rdquo; means you individually; if you represent an\n                    organization, &ldquo;you&rdquo; means your organization. You agree that by\n                    accessing our Services, you are agreeing to this Acceptable Use Policy, our\n                    Terms of Service, and our Privacy Policy. If you do not agree with these\n                    terms THEN YOU SHOULD NOT ACCESS OUR SERVICES.\n                </p>\n                <p>\n                    The intent of this document is to clarify what we consider to be acceptable\n                    use of the Services.\n                </p>\n                <p>\n                    If you are found to be in violation of any of the below policies, you will\n                    receive a notice via the most expedient means we have to contact you at our\n                    discretion including email. Unless you explain or correct your behavior\n                    within 72 hours your content will be deleted and your access will be\n                    suspended or otherwise limited to our Services at our sole discretion. We\n                    will do our best to work with you and ensure a fair outcome in all cases. We\n                    reserve the right to immediately suspend, without notice, any content,\n                    account, or IP address which we determine to be submitting spam or other\n                    potentially damaging or disruptive content to the Services.\n                </p>\n                <p>\n                    If we have no means of identifying or reaching you we will immediately\n                    suspend, without notice, any content, account, IP address, auxBundle, or\n                    source which we determine to be submitting spam or other potentially\n                    damaging or disruptive content to the Services. We further reserve the right\n                    to suspend or block any source or means of access to the Services we suspect\n                    to be damaging and disruptive in any form.\n                </p>\n                <p>\n                    If your access or content has been blocked, suspended, or hindered without\n                    notice you may reach us at\n                    <a class=\"c9\" href=\"mailto:hello@casualsimulation.org\"\n                        >hello@casualsimulation.org</a\n                    >\n                    to discuss the specifics of your situation. When your account or access is\n                    suspended, public access to content contributed by you may be blocked or\n                    removed, and your access may be suspended or deleted at our discretion.\n                    Access to other functionality or information within the Services may also be\n                    blocked or disabled.\n                </p>\n                <h3 id=\"illegal-use\">\n                    <ol start=\"2\">\n                        <li>Illegal Use</li>\n                    </ol>\n                </h3>\n                <p>\n                    The Services may not be used for illegal purposes. Examples of this include\n                    using the Services for fraudulent purposes or operating a phishing site\n                    (used to obtain account and password information).\n                </p>\n                <h3 id=\"spam\">\n                    <ol start=\"2\">\n                        <li>Spam</li>\n                    </ol>\n                </h3>\n                <p>\n                    Users that do not publish meaningful content, use deceptive means to\n                    generate revenue or traffic, or whose primary purpose is affiliate\n                    marketing, will be suspended or their access impeded or otherwise blocked.\n                </p>\n                <h3 id=\"identity-theft-and-privacy\">\n                    <ol start=\"3\">\n                        <li>Identity Theft and Privacy</li>\n                    </ol>\n                </h3>\n                <p>\n                    Users that misleadingly appropriate the identity of another person are not\n                    permitted. Users may not post other people&#39;s personally identifying or\n                    confidential information, including but not limited to credit card numbers,\n                    Social Security Numbers, and driver&#39;s and other license numbers. You may\n                    not post information such as other people&#39;s passwords, usernames, phone\n                    numbers, addresses and e-mail addresses unless already publicly accessible\n                    on the Web.\n                </p>\n                <h3 id=\"hate-content\">\n                    <ol start=\"4\">\n                        <li>Hate Content, Defamation, and Libel</li>\n                    </ol>\n                </h3>\n                <p>\n                    Hate speech and other objectionable content that is unlawful, defamatory,\n                    and fraudulent. Note that an allegation of defamatory expression, in and of\n                    itself, does not establish defamation. The truth or falsehood of a bit of\n                    expression is a key element in establishing defamation, and we are not in a\n                    position to make that sort of fact-based judgment. That said, if we have\n                    reason to believe that a particular form of media is defamatory (a court\n                    order, for example), we will remove that media.\n                </p>\n                <h3 id=\"disruptions-and-exploits\">\n                    <ol start=\"5\">\n                        <li>Disruptions and Exploits</li>\n                    </ol>\n                </h3>\n                <p>\n                    We will terminate accounts and block addresses of those who attempt\n                    unauthorized use of the Services.\n                </p>\n                <h3 id=\"copyright\">\n                    <ol start=\"6\">\n                        <li>Copyright</li>\n                    </ol>\n                </h3>\n                <p>\n                    Using copyrighted material does not constitute infringement in all cases. In\n                    general, however, users should be careful when using copyrighted content\n                    without the permission of those who created it.\n                </p>\n                <h3 id=\"mass-registration\">\n                    <ol start=\"7\">\n                        <li>Mass Registration and Automation</li>\n                    </ol>\n                </h3>\n                <p>\n                    Accounts that are registered automatically or systematically will be removed\n                    and access will be permanently suspended.\n                </p>\n                <h3 id=\"sexually-explicit-material\">\n                    <ol start=\"8\">\n                        <li>Sexually Explicit Material</li>\n                    </ol>\n                </h3>\n                <p>\n                    Accounts or media that use Services to post sexually explicit or\n                    pornographic material, or links to it, will be terminated or suspended.\n                </p>\n            </div>\n        </md-card-content>\n    </md-card>\n</div>\n","\n       if (typeof window !== 'undefined') {\n         function loadSvg() {\n           var body = document.body;\n           var svgDom = document.getElementById('__svg__icons__dom__');\n           if(!svgDom) {\n             svgDom = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n             svgDom.style.position = 'absolute';\n             svgDom.style.width = '0';\n             svgDom.style.height = '0';\n             svgDom.id = '__svg__icons__dom__';\n             svgDom.setAttribute('xmlns','http://www.w3.org/2000/svg');\n             svgDom.setAttribute('xmlns:link','http://www.w3.org/1999/xlink');\n           }\n           svgDom.innerHTML = \"<symbol  viewBox=\\\"0 0 100 100\\\" id=\\\"icon-Cube\\\"><path d=\\\"M93.25,27.15a3.72,3.72,0,0,0-.08-.57,1.36,1.36,0,0,0,0-.17,2.56,2.56,0,0,0-.27-.64v0a.18.18,0,0,0,0-.07,3.33,3.33,0,0,0-.39-.5L92.26,25a2.61,2.61,0,0,0-.46-.34l-.09-.07L51.44,2.53a3,3,0,0,0-2.88,0L8.29,24.63l-.09.07a2.61,2.61,0,0,0-.46.34l-.15.14a3.33,3.33,0,0,0-.39.5.18.18,0,0,0,0,.07v0a2.56,2.56,0,0,0-.27.64,1.36,1.36,0,0,0,0,.17,3.72,3.72,0,0,0-.08.57s0,.07,0,.11v45.8A3,3,0,0,0,8.3,75.69L48.56,97.75l.1,0a2.53,2.53,0,0,0,.48.19l.18.06a3,3,0,0,0,.68.08,2.61,2.61,0,0,0,.69-.09l.18,0a2.55,2.55,0,0,0,.48-.2l.11,0L91.72,75.32a3,3,0,0,0,1.54-2.62V27.26S93.25,27.19,93.25,27.15ZM50,8.58,84.14,27.32,50,47,15.86,27.32ZM12.74,32.45,47,52.16v37.9L12.74,71.28ZM53,90V52.16L87.26,32.45V70.93Z\\\" /></symbol><symbol  viewBox=\\\"0 0 100 100\\\" id=\\\"icon-Egg\\\"><path d=\\\"M88.62,59.38a38.62,38.62,0,0,1-77.24,0C11.38,38.05,28.67,2,50,2S88.62,38.05,88.62,59.38Z\\\" /></symbol><symbol  viewBox=\\\"0 0 100 100\\\" id=\\\"icon-Helix\\\"><path d=\\\"M62,68.91c5.48-3.48,10-8.84,10-18.91h0v0c0-.57,0-1.12,0-1.66,0-.17,0-.33,0-.49,0-.38-.06-.76-.1-1.12l-.06-.49c0-.41-.12-.8-.19-1.19,0-.09,0-.19,0-.29-.1-.47-.2-.94-.32-1.39,0-.1-.05-.2-.08-.3q-.15-.52-.3-1c0-.13-.09-.26-.13-.39-.11-.31-.23-.63-.36-.93l-.11-.3c-.17-.4-.35-.79-.54-1.16l0,0c-.18-.36-.37-.71-.58-1L69,37.91c-.17-.27-.34-.54-.52-.8l-.15-.23A21.26,21.26,0,0,0,66.81,35l-.09-.1L66,34.16,65.84,34c-.27-.26-.54-.51-.82-.75l0,0a22.66,22.66,0,0,0-1.91-1.48l-.06,0-1-.65h0a57.5,57.5,0,0,0-9.33-4.47C45.1,23.54,38.8,21,36.69,12.49H63.3a17.42,17.42,0,0,1-1.5,4H41.14a16,16,0,0,0,6.09,5H57.49a26.94,26.94,0,0,1-4.35,2.61l.51.2a69.25,69.25,0,0,1,8.29,3.82C67.61,24,72.06,17.48,72.06,5.53a4,4,0,0,0-8,0c0,.68,0,1.33,0,2H36c0-.63-.05-1.28-.05-2a4,4,0,1,0-8,0C27.94,25.22,40,30.11,49.71,34c1.26.51,2.44,1,3.55,1.49s2.25,1,3.25,1.58l.36.2.67.4L58,38l.58.4.45.32.52.4.42.37c.16.14.31.27.46.42l.41.43c.13.14.26.27.38.41s.41.52.61.8.19.3.28.45.27.42.39.64.15.31.22.46.2.43.29.65.13.34.19.51.16.47.22.71.1.36.15.54.12.54.17.81.07.37.1.56.05.41.07.62H36.09a14.19,14.19,0,0,1,1-4h23c-1.25-2.13-3.34-3.57-6.36-5H41.28a30.58,30.58,0,0,1,5.47-3A53,53,0,0,1,38,31.09c-5.48,3.48-10,8.84-10,18.91h0v.19c0,.48,0,1,0,1.43,0,.23,0,.46.05.68s.05.57.08.85.05.5.09.75.07.47.11.7c.08.51.18,1,.29,1.47,0,.15.06.31.1.46s.14.52.22.77.09.34.14.5.17.49.25.74.12.3.17.45l.29.72.15.32c.2.44.41.86.63,1.27l.22.41.36.57.27.43.36.52c.11.16.23.31.34.46l.48.6c.17.21.35.42.53.62l.34.36.46.47.33.32.56.51.26.23c.28.24.57.47.86.7l.13.09c.26.2.53.39.8.58l.21.15.8.53.09.06h0a57.5,57.5,0,0,0,9.33,4.47c7.29,3,13.39,5.43,15.73,13.11H37a16.35,16.35,0,0,1,1.23-3H58.84a15.91,15.91,0,0,0-6.13-5H42.55a26.19,26.19,0,0,1,4.31-2.59l-.51-.2a69.25,69.25,0,0,1-8.29-3.82C32.39,76,27.94,82.52,27.94,94.47a4,4,0,1,0,8,0c0-1.06.05-2,.13-3H63.94c.08.93.12,1.92.12,3a4,4,0,0,0,8,0C72.06,74.78,60,69.89,50.29,66c-1.28-.51-2.47-1-3.59-1.51s-2.14-1-3.09-1.5l-.5-.27-.57-.35L42,62l-.49-.34c-.19-.13-.38-.26-.56-.4l-.42-.32L40,60.44l-.32-.3c-.23-.21-.44-.44-.64-.66l-.16-.18a10.63,10.63,0,0,1-1.35-2l-.09-.19a8.92,8.92,0,0,1-.42-.94c0-.09-.07-.19-.11-.28-.11-.31-.21-.64-.31-1,0-.11-.06-.21-.08-.32-.09-.35-.16-.71-.23-1.08l-.06-.32c0-.23,0-.47-.08-.71H63.91a14.64,14.64,0,0,1-1,4h-23c1.25,2.12,3.32,3.56,6.32,5H58.76a30.57,30.57,0,0,1-5.5,3A53.26,53.26,0,0,1,62,68.91Z\\\" /></symbol><symbol  xmlns:svg=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 24 24\\\" id=\\\"icon-PersonPinCircle\\\">\\n <g class=\\\"layer\\\">\\n  <title>Layer 1</title>\\n  <path d=\\\"m11.76,3.8c1.26,0 4.18,7.75 4.18,8.99l1.48,0.46c-0.92,1.05 -3.83,6.24 -5.35,6.24s-2.8,-5.5 -3.72,-6.54l-2.88,-4.52c0,-1.24 5.02,-4.63 6.28,-4.63zm0.39,6.19c-1.04,0 -1.9,-0.84 -1.9,-1.87s0.85,-1.87 1.9,-1.87s1.9,0.84 1.9,1.87s-0.85,1.87 -1.9,1.87zm-0.53,-4.41c0,-3.39 3.71,-1.2 0.53,-1.2s-5.69,2.4 -5.69,5.79c0,2.19 -1.96,-5.79 1.88,-2.34c3.84,-3.46 3.28,-0.07 3.28,-2.26zm0.53,-3.07c3.98,0 7.59,3.01 7.59,7.66c0,3.1 -2.53,6.77 -7.59,11.03c-5.06,-4.25 -7.59,-7.92 -7.59,-11.03c0,-4.65 3.61,-7.66 7.59,-7.66z\\\" fill=\\\"#ffffff\\\" id=\\\"icon-PersonPinCircle_svg_2\\\" />\\n  <path d=\\\"m12,11c1.33,0 4,0.67 4,2l0,0.16c-0.97,1.12 -2.4,1.84 -4,1.84s-3.03,-0.72 -4,-1.84l0,-0.16c0,-1.33 2.67,-2 4,-2zm0,-1c-1.1,0 -2,-0.9 -2,-2s0.9,-2 2,-2s2,0.9 2,2s-0.9,2 -2,2zm6,0.2c0,-3.63 -2.65,-6.2 -6,-6.2s-6,2.57 -6,6.2c0,2.34 1.95,5.44 6,9.14c4.05,-3.7 6,-6.8 6,-9.14zm-6,-8.2c4.2,0 8,3.22 8,8.2c0,3.32 -2.67,7.25 -8,11.8c-5.33,-4.55 -8,-8.48 -8,-11.8c0,-4.98 3.8,-8.2 8,-8.2z\\\" fill=\\\"#000000\\\" id=\\\"icon-PersonPinCircle_svg_1\\\" transform=\\\"matrix(1 0 0 1 0 0)\\\" />\\n  <path id=\\\"icon-PersonPinCircle_svg_4\\\" />\\n </g>\\n</symbol>\";\n           body.insertBefore(svgDom, body.lastChild);\n         }\n         if(document.readyState === 'loading') {\n           document.addEventListener('DOMContentLoaded', loadSvg);\n         } else {\n           loadSvg()\n         }\n      }\n        \nexport default {}","/**\n * MIT License\n *\n * Copyright (c) 2019 Casual Simulation, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n * @license MIT\n */\n\nimport Vue from 'vue';\nimport VueRouter, { RouteConfig } from 'vue-router';\nimport {\n    MdButton,\n    MdContent,\n    MdApp,\n    MdCard,\n    MdToolbar,\n    MdField,\n    MdProgress,\n    MdDrawer,\n    MdList,\n    MdMenu,\n    MdDialog,\n    MdDialogConfirm,\n    MdDialogAlert,\n    MdDatepicker,\n    MdTabs,\n    MdCheckbox,\n    MdTooltip,\n    MdSnackbar,\n    MdSwitch,\n    MdBadge,\n    MdDialogPrompt,\n    MdTable,\n} from 'vue-material/dist/components';\nimport 'vue-material/dist/vue-material.min.css';\nimport 'vue-material/dist/theme/default.css';\n\nimport '@casual-simulation/aux-components/fonts/MaterialIcons/MaterialIcons.css';\nimport '@casual-simulation/aux-components/fonts/Roboto/Roboto.css';\nimport '@casual-simulation/aux-components/fonts/NotoSansKR/NotoSansKR.css';\n\nimport '@casual-simulation/aux-components/SVGPolyfill';\nimport AuthApp from './AuthApp/AuthApp';\nimport AuthHome from './AuthHome/AuthHome';\nimport AuthLogin from './AuthLogin/AuthLogin';\nimport AuthEnterCode from './AuthEnterCode/AuthEnterCode';\nimport { authManager } from '../shared/index';\nimport AuthLoading from './AuthLoading/AuthLoading';\nimport { EventBus } from '@casual-simulation/aux-components';\nimport {\n    listenForChannel,\n    setupChannel,\n} from '@casual-simulation/aux-vm-browser/html/IFrameHelpers';\nimport { skip } from 'rxjs/operators';\nimport AuthTerms from './AuthTerms/AuthTerms';\nimport AuthPrivacyPolicy from './AuthPrivacyPolicy/AuthPrivacyPolicy';\nimport AuthAcceptableUsePolicy from './AuthAcceptableUsePolicy/AuthAcceptableUsePolicy';\n\nimport 'virtual:svg-icons-register';\n\nVue.use(VueRouter);\nVue.use(MdButton);\nVue.use(MdCheckbox);\nVue.use(MdContent);\nVue.use(MdApp);\nVue.use(MdCard);\nVue.use(MdToolbar);\nVue.use(MdField);\nVue.use(MdProgress);\nVue.use(MdDrawer);\nVue.use(MdList);\nVue.use(MdMenu);\nVue.use(MdDialog);\nVue.use(MdDialogConfirm);\nVue.use(MdDialogAlert);\nVue.use(MdTabs);\nVue.use(MdTooltip);\nVue.use(MdTable);\nVue.use(MdSnackbar);\nVue.use(MdSwitch);\nVue.use(MdBadge);\nVue.use(MdDialogPrompt);\nVue.use(MdDatepicker);\n\nconst routes: RouteConfig[] = [\n    {\n        path: '/login',\n        name: 'login',\n        component: AuthLogin,\n        props: (route) => ({\n            after: route.query['after'],\n        }),\n    },\n    {\n        path: '/enter-code',\n        name: 'code',\n        component: AuthEnterCode,\n        props: (route) => ({\n            after: route.query['after'],\n            userId: route.query['userId'],\n            requestId: route.query['requestId'],\n            address: route.query['address'],\n            addressTypeToCheck: route.query['addressTypeToCheck'],\n        }),\n    },\n    {\n        path: '/terms',\n        name: 'terms',\n        component: AuthTerms,\n    },\n    {\n        path: '/privacy-policy',\n        name: 'privacy-policy',\n        component: AuthPrivacyPolicy,\n    },\n    {\n        path: '/acceptable-use-policy',\n        name: 'acceptable-use-policy',\n        component: AuthAcceptableUsePolicy,\n    },\n    {\n        path: '/',\n        name: 'home',\n        component: AuthHome,\n    },\n];\n\nconst router = new VueRouter({\n    mode: 'history',\n    routes,\n});\n\nconst manager = authManager;\nlet messagePort: MessagePort;\n\nif (window.opener) {\n    console.log(\n        '[auth-aux/site/index] Opened by another tab. Setting up channel.'\n    );\n    const channel = setupChannel(window.opener);\n\n    messagePort = channel.port1;\n\n    messagePort.addEventListener('message', (message) => {\n        if (message.data.type === 'close') {\n            window.close();\n        }\n    });\n\n    window.addEventListener('close', () => {\n        if (messagePort) {\n            messagePort.postMessage({\n                type: 'close',\n            });\n        }\n    });\n\n    authManager.loginState.pipe(skip(1)).subscribe((loggedIn) => {\n        if (messagePort) {\n            if (loggedIn) {\n                console.log('[auth-aux/site/index] Sending login event.');\n                messagePort.postMessage({\n                    type: 'login',\n                    userId: authManager.userId,\n                });\n            }\n        }\n    });\n}\n\nlet loading: Vue;\n\nrouter.beforeEach((to, from, next) => {\n    EventBus.$emit('startLoading');\n    next();\n});\n\nconst publicPages = new Set([\n    'login',\n    'code',\n    'terms',\n    'privacy-policy',\n    'acceptable-use-policy',\n]);\n\nrouter.beforeEach(async (to, from, next) => {\n    try {\n        const loggedIn = manager.isLoggedIn();\n\n        if (messagePort && loggedIn) {\n            if (!manager.userInfoLoaded) {\n                await manager.loadUserInfo();\n            }\n\n            messagePort.postMessage({\n                type: 'login',\n                userId: authManager.userId,\n            });\n\n            next();\n            return;\n        }\n\n        if (loggedIn && !manager.userInfoLoaded) {\n            try {\n                await manager.loadUserInfo();\n\n                if (to.name === 'login' || to.name === 'code') {\n                    console.log(\n                        '[index] Already logged in. Redirecting to home.'\n                    );\n\n                    next({ name: 'home' });\n                } else {\n                    next();\n                }\n                return;\n            } catch (err) {\n                console.error('[index] Could not load User info.', err);\n                next();\n            }\n        }\n\n        if (!publicPages.has(to.name) && !loggedIn) {\n            console.log('[index] Not Logged In and. Redirecting to Login.');\n            next({ name: 'login' });\n            return;\n        } else {\n            next();\n            return;\n        }\n    } catch (err) {\n        next();\n        return;\n    }\n});\n\nrouter.afterEach((to, from) => {\n    EventBus.$emit('stopLoading');\n});\n\nasync function start() {\n    loading = new Vue({\n        render: (createEle) => createEle(AuthLoading),\n    }).$mount('#loading');\n\n    const app = new Vue({\n        router,\n        render: (createEle) => createEle(AuthApp),\n    }).$mount('#app');\n}\n\nstart();\n"],"names":["secretbox","GENERATOR","SPACE","serialize","test","plugin","style","IS_KEYED_SENTINEL","IS_ORDERED_SENTINEL","IS_SET_SENTINEL","AsymmetricMatcher","ConvertAnsi","DOMCollection","DOMElement","Immutable","ReactTestComponent","prettyFormatPlugins","PLUGINS","prettyFormat","diffDefault","isExpand","matchers","createThrowMatcher","matcherUtils.RECEIVED_COLOR","matcherUtils.matcherErrorMessage","matcherUtils.matcherHint","matcherUtils.printWithType","matcherUtils.printReceived","matcherUtils.stringify","toThrowMatchers","expect","cloneDeep","Tagline","Component","render","staticRenderFns","__decorateClass","Loading","SvgIcon","AuthApp","SessionLocation","RelativeTime","sortBy","debounce","AuthHome","AuthLogin","AuthLoading","AuthTerms","MdButton","MdCheckbox","MdContent","MdApp","MdCard","MdToolbar","MdField","MdProgress","MdDrawer","MdList","MdMenu","MdDialog","MdDialogConfirm","MdDialogAlert","MdTabs","MdTooltip","MdTable","MdSnackbar","MdSwitch","MdBadge","MdDialogPrompt","MdDatepicker"],"mappings":"qpBACA,GAAI,CAAC,WAAW,WAAY,SAChB,KACJ,2FAEyB,QAAQ,aAC1B,WAAkB,OCLpB,IAAW,GAAI,eC4EN,EAAe,EAAa,EAAqB,OAC5D,MAAK,IAAI,EAAK,KAAK,IAAI,EAAK,gBA8EH,EAAwB,OAGjD,AADW,gBACD,KAAK,eAQO,EAAuB,IAChD,GAAM,EAAM,OAAO,QAAQ,UAAW,UAErC,GAIA,GAAI,WAAW,OACZ,EAAI,OAAS,KAGP,IAAM,EACL,EAAI,OAAS,IACd,KAAO,IAEP,QAAU,GAIjB,GAfI,UClIF,IAAuB,OAAO,iBC7BjBA,qBAAU,kBCTf,CAwBjB,YAAY,EAAY,EAAG,EAAY,EAAG,MACjC,EAAI,OACJ,EAAI,SACF,OAAO,YAWX,kBAAiB,EAAW,EAAW,MACpC,GAAS,KAAK,KAAK,EAAI,EAAI,EAAI,SAC9B,IAAI,IAAQ,EAAI,EAAQ,EAAI,SAqBhC,cAAa,EAAgB,EAAyB,MACnD,GAAM,EAAM,IAAI,GAChB,EAAK,EAAM,SACX,EAAK,EAAO,eACX,MAAK,KAAK,KAAY,UAe1B,iBAAgB,EAAgB,EAAyB,OAErD,AADW,GAAO,SAAS,GACjB,eAwBd,qBACH,EACA,EACA,EACF,MAEQ,GAAO,AADD,EAAO,SAAS,GACX,eAAe,SACzB,GAAM,IAAI,SAoBd,sBACH,EACA,EACA,EACF,OACS,IAAQ,oBAAoB,EAAO,EAAQ,GAAQ,YAc9D,IAAI,EAAyB,OAClB,IAAI,IAAQ,KAAK,EAAI,EAAM,EAAG,KAAK,EAAI,EAAM,GAsBxD,SAAS,EAAyB,OACvB,IAAI,IAAQ,KAAK,EAAI,EAAM,EAAG,KAAK,EAAI,EAAM,GAYxD,eAAe,EAAwB,OAC5B,IAAI,IAAQ,KAAK,EAAI,EAAO,KAAK,EAAI,GAchD,SAAS,EAAyB,OACvB,IAAI,IAAQ,KAAK,EAAI,EAAM,EAAG,KAAK,EAAI,EAAM,GAuBxD,IAAI,EAAwB,OACjB,MAAK,EAAI,EAAM,EAAI,KAAK,EAAI,EAAM,EAY7C,QAAiB,OACN,MAAK,KAAK,KAAK,EAAI,KAAK,EAAI,KAAK,EAAI,KAAK,GAcrD,cAAuB,OACZ,MAAK,EAAI,KAAK,EAAI,KAAK,EAAI,KAAK,EAe3C,WAAqB,MACX,GAAS,KAAK,eACb,IAAI,IAAQ,KAAK,EAAI,EAAQ,KAAK,EAAI,GAYjD,QAAkB,OACP,IAAI,IAAQ,CAAC,KAAK,EAAG,CAAC,KAAK,GAYtC,UAAmB,OACR,WAAW,KAAK,MAAM,KAAK,KActC,OAAO,EAAyB,OACrB,MAAK,IAAM,EAAM,GAAK,KAAK,IAAM,EAAM,UCvTjC,IAmBb,KAAK,OACE,IAAI,IAAQ,KAAK,EAAG,KAAK,MAMhC,KAAK,OACE,IAAI,IAAQ,KAAK,EAAG,KAAK,MAMhC,KAAK,OACE,IAAI,IAAQ,KAAK,EAAG,KAAK,GAiBpC,YAAY,EAAY,EAAG,EAAY,EAAG,EAAY,EAAG,MAChD,EAAI,OACJ,EAAI,OACJ,EAAI,SACF,OAAO,YAYX,kBAAiB,EAAW,EAAW,EAAW,MAC/C,GAAS,KAAK,KAAK,EAAI,EAAI,EAAI,EAAI,EAAI,SACtC,IAAI,GAAQ,EAAI,EAAQ,EAAI,EAAQ,EAAI,SAuB5C,cAAa,EAAgB,EAAyB,MACnD,GAAM,EAAM,IAAI,GAChB,EAAK,EAAM,SACX,EAAK,EAAO,SACZ,EAAM,KAAY,SACpB,IAAO,GAAK,GAAO,GACZ,KAAK,KAAK,GAGV,KAAK,KAAK,GAAM,EAAK,GAAI,UAgBjC,iBAAgB,EAAgB,EAAyB,OAErD,AADW,GAAO,SAAS,GACjB,eAwBd,qBACH,EACA,EACA,EACF,MAEQ,GAAO,AADD,EAAO,SAAS,GACX,eAAe,SACzB,GAAM,IAAI,SAoBd,sBACH,EACA,EACA,EACF,OACS,GAAQ,oBAAoB,EAAO,EAAQ,GAAQ,YAc9D,IAAI,EAAyB,OAClB,IAAI,GACP,KAAK,EAAI,EAAM,EACf,KAAK,EAAI,EAAM,EACf,KAAK,EAAI,EAAM,GAuBvB,SAAS,EAAyB,OACvB,IAAI,GACP,KAAK,EAAI,EAAM,EACf,KAAK,EAAI,EAAM,EACf,KAAK,EAAI,EAAM,GAavB,eAAe,EAAwB,OAC5B,IAAI,GAAQ,KAAK,EAAI,EAAO,KAAK,EAAI,EAAO,KAAK,EAAI,GAchE,SAAS,EAAyB,OACvB,IAAI,GACP,KAAK,EAAI,EAAM,EACf,KAAK,EAAI,EAAM,EACf,KAAK,EAAI,EAAM,GAwBvB,IAAI,EAAwB,OACjB,MAAK,EAAI,EAAM,EAAI,KAAK,EAAI,EAAM,EAAI,KAAK,EAAI,EAAM,EAgBhE,MAAM,EAAyB,OACpB,IAAI,GACP,KAAK,EAAI,EAAM,EAAI,EAAM,EAAI,KAAK,EAClC,KAAK,EAAI,EAAM,EAAI,EAAM,EAAI,KAAK,EAClC,KAAK,EAAI,EAAM,EAAI,EAAM,EAAI,KAAK,GAa1C,QAAiB,OACN,MAAK,KAAK,KAAK,EAAI,KAAK,EAAI,KAAK,EAAI,KAAK,EAAI,KAAK,EAAI,KAAK,GAcvE,cAAuB,OACZ,MAAK,EAAI,KAAK,EAAI,KAAK,EAAI,KAAK,EAAI,KAAK,EAAI,KAAK,EAe7D,WAAqB,MACX,GAAS,KAAK,eAChB,KAAW,EACJ,KAEJ,GAAI,GAAQ,KAAK,EAAI,EAAQ,KAAK,EAAI,EAAQ,KAAK,EAAI,GAYlE,QAAkB,OACP,IAAI,GAAQ,CAAC,KAAK,EAAG,CAAC,KAAK,EAAG,CAAC,KAAK,GAY/C,UAAmB,OACR,WAAW,KAAK,MAAM,KAAK,MAAM,KAAK,KAcjD,OAAO,EAAyB,OACrB,MAAK,IAAM,EAAM,GAAK,KAAK,IAAM,EAAM,GAAK,KAAK,IAAM,EAAM,GAOxD,GAAI,GAKL,GAAI,GAAQ,EAAG,EAAG,GAKd,GAAI,GAAQ,EAAG,EAAG,GAKrB,GAAI,GAAQ,EAAG,GAAI,GAKlB,GAAI,GAAQ,EAAG,EAAG,GAKnB,GAAI,GAAQ,GAAI,EAAG,GAKrB,GAAI,GAAQ,EAAG,EAAG,GAKhB,GAAI,GAAQ,EAAG,EAAG,WC7Zd,CA4BpB,YAAY,EAAY,EAAG,EAAY,EAAG,EAAY,EAAG,EAAY,EAAG,MAC/D,EAAI,OACJ,EAAI,OACJ,EAAI,OACJ,EAAI,SACF,OAAO,MAclB,SAAS,EAA+B,MAE9B,GACF,KAAK,EAAI,EAAM,EACf,KAAK,EAAI,EAAM,EACf,KAAK,EAAI,EAAM,EACf,KAAK,EAAI,EAAM,EACb,EACF,KAAK,EAAI,EAAM,EACf,KAAK,EAAI,EAAM,EACf,KAAK,EAAI,EAAM,EACf,KAAK,EAAI,EAAM,EACb,EACF,KAAK,EAAI,EAAM,EACf,KAAK,EAAI,EAAM,EACf,KAAK,EAAI,EAAM,EACf,KAAK,EAAI,EAAM,EACb,EACF,KAAK,EAAI,EAAM,EACf,KAAK,EAAI,EAAM,EACf,KAAK,EAAI,EAAM,EACf,KAAK,EAAI,EAAM,QACZ,IAAI,GAAW,EAAG,EAAG,EAAG,GAQnC,QAAqB,OACV,IAAI,GAAW,CAAC,KAAK,EAAG,CAAC,KAAK,EAAG,CAAC,KAAK,EAAG,KAAK,GAM1D,QAAiB,OACN,MAAK,KACR,KAAK,EAAI,KAAK,EACV,KAAK,EAAI,KAAK,EACd,KAAK,EAAI,KAAK,EACd,KAAK,EAAI,KAAK,GAS1B,cAAuB,OAEf,MAAK,EAAI,KAAK,EACd,KAAK,EAAI,KAAK,EACd,KAAK,EAAI,KAAK,EACd,KAAK,EAAI,KAAK,EAUtB,WAAwB,MACd,GAAS,KAAK,eACb,IAAI,GACP,KAAK,EAAI,EACT,KAAK,EAAI,EACT,KAAK,EAAI,EACT,KAAK,EAAI,GAIjB,UAAmB,OACR,cAAc,KAAK,MAAM,KAAK,MAAM,KAAK,MAAM,KAAK,KAO/D,OAAO,EAA4B,OAC1B,GAKD,KAAK,IAAM,EAAM,GACjB,KAAK,IAAM,EAAM,GACjB,KAAK,IAAM,EAAM,GACjB,KAAK,IAAM,EAAM,EAPV,IAeK,GAAI,GAAW,EAAG,EAAG,EAAG,UCnK1B,IAMd,aAAa,OACN,MAAK,GAgChB,YACI,EAQF,YACM,CAAC,OACI,GAAK,GAAI,GAAW,EAAG,EAAG,EAAG,WAC3B,QAAU,QACZ,GAAK,EAAS,2BAA2B,WACvC,QAAU,QACZ,GAAK,EAAS,iBAAiB,WAC7B,cAAgB,GAAU,MAC3B,GAAI,EAAS,gBACd,GAAK,GAAI,GAAW,EAAE,EAAG,EAAE,EAAG,EAAE,EAAG,EAAE,GAAG,oBACtC,YAAc,GAAU,IAC3B,GAAI,GAAI,GAAW,EAAG,EAAG,EAAG,UACvB,KAAK,GAAS,WACf,EAAE,WAAW,SAAS,QAEzB,GAAK,UACH,SAAW,GAAU,IAKnB,GAAT,SAAiB,EAAe,EAAsB,OAC9C,GACO,EAAS,SAAS,GAElB,EAAE,SAAS,IARtB,EAAI,GAAI,GAAW,EAAG,EAAG,EAAG,GAC5B,EAAQ,KAAS,MAAM,QAAf,OAAwB,MAChC,EAAY,KAAS,MAAM,YAAf,OAA4B,UAUnC,KAAQ,GACT,IAAS,KAAO,IAAS,MACrB,EACA,EACA,EAAS,2BAA2B,CAChC,KAAM,GAAI,GAAQ,EAAG,EAAG,GACxB,MAAO,EAAS,MAAM,KAGvB,IAAS,KAAO,IAAS,MAC5B,EACA,EACA,EAAS,2BAA2B,CAChC,KAAM,GAAI,GAAQ,EAAG,EAAG,GACxB,MAAO,EAAS,MAAM,KAGvB,KAAS,KAAO,IAAS,SAC5B,EACA,EACA,EAAS,2BAA2B,CAChC,KAAM,GAAI,GAAQ,EAAG,EAAG,GACxB,MAAO,EAAS,MAAM,WAKjC,GAAK,MACH,aAAe,QACjB,GAAK,EAAS,eAAe,GAC3B,YAAoB,QACtB,GAAK,EAAS,iBAEd,GAAK,GAAI,GAAW,EAAG,EAAG,EAAG,SAQnC,4BAA2B,EAAwC,MAChE,GAAiB,EAAa,KAAK,YACnC,EAAW,KAAK,IAAI,EAAa,MAAQ,GACzC,EAAW,KAAK,IAAI,EAAa,MAAQ,SACxC,IAAI,GACP,EAAe,EAAI,EACnB,EAAe,EAAI,EACnB,EAAe,EAAI,EACnB,SASD,kBAAiB,EAA4C,MAC1D,GAAiB,EAAe,KAAK,YACrC,EAAe,EAAe,GAAG,YAEjC,EAAQ,EAAe,MAAM,GAC7B,EAAQ,EAAQ,aAAa,EAAgB,SAE5C,GAAS,2BAA2B,CACvC,KAAM,EACN,gBAQD,gBAAe,EAAgC,IAC9C,EAAK,gBAAkB,SAAW,EAAK,gBAAkB,aACnD,IAAI,OACN,gHAIJ,EAAK,UAAU,eAAiB,WACzB,IAAI,MAGX,GAAY,EAAK,UAAU,YAC3B,EAAK,EAAK,QAAQ,iBAChB,GAAY,EAAU,IAAI,MAC5B,EAAK,gBAAkB,QAAS,IAC5B,EAAY,WACN,IAAI,OACN;AAAA,kJAEG,EAAY,YACb,IAAI,OACN;AAAA,mJAIJ,MAAK,IAAI,EAAG,KAAO,IACP,GAAI,GACZ,EAAU,EACV,EAAU,EAAI,KACd,EAAU,KAGF,GAAI,GACZ,EAAU,EAAI,KACd,EAAU,EACV,EAAU,QAQhB,GAAI,EAAU,YACd,EAAI,EAAE,MAAM,GAAI,YAEhB,EAAI,EAAE,MAAM,GAEZ,EAAM,EAAE,EACR,EAAM,EAAE,EACR,EAAM,EAAE,EACR,EAAM,EAAE,EACR,EAAM,EAAE,EACR,EAAM,EAAE,EACR,EAAM,EAAE,EACR,EAAM,EAAE,EACR,EAAM,EAAE,EAGR,EAAK,KAAK,KAAK,KAAK,IAAI,EAAG,EAAI,EAAM,EAAM,IAAQ,KACrD,GAAK,GACL,EAAM,EACN,KAAK,KAAK,KAAK,IAAI,EAAG,EAAI,EAAM,EAAM,IAAQ,GAE9C,EAAK,GACL,EAAM,EACN,KAAK,KAAK,KAAK,IAAI,EAAG,EAAI,EAAM,EAAM,IAAQ,GAE9C,EAAK,GACL,EAAM,EACN,KAAK,KAAK,KAAK,IAAI,EAAG,EAAI,EAAM,EAAM,IAAQ,SAG3C,IAAI,GAAW,EAAI,EAAI,EAAI,SAQ/B,cAAa,EAAiB,EAA0B,MACrD,GAAQ,EAAM,WAAW,SAAS,SAAS,EAAO,kBACjD,GAAI,KAAK,KAAK,EAAM,SAUxB,aACH,EACA,EACA,EACQ,MACF,GAAK,EAAM,WACX,EAAK,EAAO,WAEZ,EACF,EAAG,EAAI,EAAG,EAAI,EAAG,EAAI,EAAG,EAAI,EAAG,EAAI,EAAG,EAAI,EAAG,EAAI,EAAG,KAGpD,GAAgB,GAAK,GAAgB,SAC9B,IAAI,GAAS,GAAI,GAAW,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,SAEtD,GAAe,KAAK,KAAK,EAAI,EAAe,MAG9C,KAAK,IAAI,IAAiB,WACnB,IAAI,GACP,GAAI,GACA,EAAG,EAAI,GAAM,EAAG,EAAI,GACpB,EAAG,EAAI,GAAM,EAAG,EAAI,GACpB,EAAG,EAAI,GAAM,EAAG,EAAI,GACpB,EAAG,EAAI,GAAM,EAAG,EAAI,UAK1B,GAAY,KAAK,KAAK,GACtB,EAAS,KAAK,OAAS,GAAU,GAAa,EAC9C,EAAS,KAAK,IAAI,EAAS,GAAa,QAEvC,IAAI,GACP,GAAI,GACA,EAAG,EAAI,EAAS,EAAG,EAAI,EACvB,EAAG,EAAI,EAAS,EAAG,EAAI,EACvB,EAAG,EAAI,EAAS,EAAG,EAAI,EACvB,EAAG,EAAI,EAAS,EAAG,EAAI,IAmBnC,cAAc,EAA0B,MAE9B,GAAI,KAAK,iBACR,IAAI,GACP,EAAE,EAAI,EAAE,EAAI,EAAO,EACf,EAAI,EAAE,EAAI,EAAE,EAAI,EAAO,EACvB,EAAI,EAAE,EAAI,EAAE,EAAI,EAAO,EACvB,EAAE,EAAI,EAAE,EAAI,EAAO,EACnB,EAAI,EAAE,EAAI,EAAE,EAAI,EAAO,EACvB,EAAI,EAAE,EAAI,EAAE,EAAI,EAAO,EACvB,EAAE,EAAI,EAAE,EAAI,EAAO,EACnB,EAAE,EAAI,EAAE,EAAI,EAAO,EACvB,EAAI,EAAE,EAAI,EAAE,EAAI,EAAO,EACnB,EAAE,EAAI,EAAE,EAAI,EAAO,EACnB,EAAI,EAAE,EAAI,EAAE,EAAI,EAAO,EACvB,EAAI,EAAE,EAAI,EAAE,EAAI,EAAO,EACvB,EAAE,EAAI,EAAE,EAAI,EAAO,EACnB,EAAE,EAAI,EAAE,EAAI,EAAO,EACnB,EAAI,EAAE,EAAI,EAAE,EAAI,EAAO,EACvB,EAAE,EAAI,EAAE,EAAI,EAAO,EACvB,EAAI,EAAE,EAAI,EAAE,EAAI,EAAO,EACnB,EAAI,EAAE,EAAI,EAAE,EAAI,EAAO,EACvB,EAAE,EAAI,EAAE,EAAI,EAAO,EACnB,EAAI,EAAE,EAAI,EAAE,EAAI,EAAO,EACvB,EAAE,EAAI,EAAE,EAAI,EAAO,EACnB,EAAI,EAAE,EAAI,EAAE,EAAI,EAAO,EACvB,EAAE,EAAI,EAAE,EAAI,EAAO,EACnB,EAAE,EAAI,EAAE,EAAI,EAAO,GAmB/B,cAAc,EAA0B,OAC7B,MAAK,cAAc,GAAI,GAAQ,EAAO,EAAG,EAAO,IAqB3D,YAAY,EAA2B,OAC5B,IAAI,GAAS,EAAM,WAAW,SAAS,KAAK,aAiBvD,QAAmB,OACR,IAAI,GAAS,KAAK,GAAG,UAMhC,cAA6B,MACnB,GAAY,KAAK,KAAK,KAAK,WAAW,GACtC,EAAe,KAAK,IAAI,GACxB,EAAI,KAAK,WAAW,EAAI,EACxB,EAAI,KAAK,WAAW,EAAI,EACxB,EAAI,KAAK,WAAW,EAAI,EACxB,EAAQ,EAAY,QAEnB,CACH,KAAM,GAAI,GAAQ,EAAG,EAAG,GACxB,SAQR,OAAO,EAA0B,OACtB,MAAK,GAAG,OAAO,iBAAO,IAejC,UAAmB,MACT,CAAE,OAAM,SAAU,KAAK,eACvB,EAAiB,EAAQ,KAAK,SAChC,KAAU,EACH,qBAEJ,kBAAkB,uBAA0B,MAuHpB,GAAI,GAAS,CAChD,KAAM,GAAI,GAAQ,EAAG,EAAG,GACxB,MAAO,CAAC,KAAK,GAAK,gBAQG,EAAmB,EAA2B,OAC/D,MAAK,KAAK,KAAe,KAAK,KAAK,GAC5B,EAEA,EAAY,eC5bF,EAAgB,OAC9B,MAAY,MAAQ,MAAO,IAAU,aAAe,IAAU,gBAmR5C,EAA6B,OAClD,CAAC,CAAC,GAAO,MAAO,IAAQ,SAEpB,CAAC,CAAC,EAAI,IACN,MAAO,GAAI,MAAS,UACpB,MAAO,GAAI,KAAQ,UACnB,MAAO,GAAI,OAAU,UACrB,MAAO,GAAI,KAAK,QAAW,YAC3B,MAAO,GAAI,WAAc,UACzB,MAAO,GAAI,SAAY,UACvB,MAAO,GAAI,aAAgB,SAG5B,MC5ZC,IAAL,UAAK,EAAL,UACI,GAAP,eACM,GAAN,cACM,GAAN,gBACQ,GAAR,mBACS,GAAT,oBACS,GAAT,yBACc,GAAd,6BACa,GAAb,2BACY,GAAZ,wBACU,GAAV,YAVQ,gBCmtBA,IAAL,UAAK,EAAL,UAII,GAAP,qBAMY,GAAZ,wBAOU,GAAV,YAjBQ,aCrtBR,GAAiB,UAUyD,GAAI,KAC9E,CACI,CAAC,SAAU,GAAiB,WAC5B,CAAC,QAAS,GAAiB,WAC3B,CAAC,YAAa,GAAiB,WAC/B,CAAC,UAAW,GAAiB,SAC7B,CAAC,QAAS,GAAiB,SAC3B,CAAC,YAAa,GAAiB,MAC/B,CAAC,YAAa,GAAiB,QCxBvC,AAAK,WAAW,MACR,OAAO,UAAY,qBACX,KACJ,qFAGF,WAAY,KAAO,KAAM,CAI3B,YAAY,EAAc,EAAc,MAC/B,MAAQ,EAAM,aACd,KAAO,iBAAS,UAGnB,cAAoC,IAClC,GAAQ,QACN,GAAU,GAAI,sBACT,KAAQ,MAAK,SAChB,MAAO,IAAS,SAAU,MACpB,GAAU,EAAQ,OAAO,KACzB,KAAK,GAAG,WACP,YAAgB,eACjB,KAAK,GAAG,GAAI,YAAW,YACtB,YAAY,OAAO,KACpB,KAAK,GAAG,GAAI,YAAW,EAAK,iBAC3B,YAAgB,MAAM,MACvB,GAAS,KAAM,GAAK,gBACpB,KAAK,GAAG,GAAI,YAAW,UAK9B,AADM,IAAI,YAAW,GAChB,UCgCF,OAAO,OAAO,GAAIC,GAAW,CAC/C,iBAAkB,SAAU,EAAW,EAAY,GACzC,MAAM,gBACP,EAAK,OAAO,MAAM,EAAK,OAAQ,KAC9B,MAAM,QCrEpB,AAAK,WAAW,yBACD,YAAc,CACrB,KAAM,OACK,MAAK,SCCxB,AAAK,MAAM,UAAU,cACV,eAAe,MAAM,UAAW,QAAS,CAC5C,MAAO,UAAW,IAEV,MAAQ,UACF,IAAI,WAAU,oCAGpB,GAAI,OAAO,MAGX,EAAM,EAAE,SAAW,KAGnB,EAAM,QAEC,GAAE,IAMjB,aAAc,GACd,SAAU,KCvBlB,AAAK,MAAM,UAAU,aACV,eAAe,MAAM,UAAW,OAAQ,CAC3C,MAAO,UAAW,IAEV,MAAQ,UACF,IAAI,WAAU,oCAGpB,GAAI,OAAO,MAGX,EAAM,EAAE,SAAW,KAGnB,EAAM,QAEC,GAAE,EAAM,IAMvB,aAAc,GACd,SAAU,KCoKlB,KAAM,IAAyB,GAEzB,GACF,CAAC,EAAS,IACV,AAAC,GACG,KAAU,EAAO,KAEnB,GACF,CAAC,EAAS,IACV,AAAC,GACG,KAAU,GAAK,OAAY,KAE7B,GACF,CAAC,EAAS,IACV,CAAC,EAAa,EAAe,IACzB,KAAU,GAAK,OAAY,KAAO,KAAS,KAEnD,aAAsC,MAC5B,GAAQ,GAAI,KACZ,EAAS,CACX,SAAU,CACN,MAAO,CAAC,EAAG,GAEX,KAAM,CAAC,EAAG,IACV,IAAK,CAAC,EAAG,IACT,OAAQ,CAAC,EAAG,IACZ,UAAW,CAAC,EAAG,IACf,SAAU,CAAC,GAAI,IACf,QAAS,CAAC,EAAG,IACb,OAAQ,CAAC,EAAG,IACZ,cAAe,CAAC,EAAG,KAEvB,MAAO,CACH,MAAO,CAAC,GAAI,IACZ,IAAK,CAAC,GAAI,IACV,MAAO,CAAC,GAAI,IACZ,OAAQ,CAAC,GAAI,IACb,KAAM,CAAC,GAAI,IACX,QAAS,CAAC,GAAI,IACd,KAAM,CAAC,GAAI,IACX,MAAO,CAAC,GAAI,IAGZ,YAAa,CAAC,GAAI,IAClB,UAAW,CAAC,GAAI,IAChB,YAAa,CAAC,GAAI,IAClB,aAAc,CAAC,GAAI,IACnB,WAAY,CAAC,GAAI,IACjB,cAAe,CAAC,GAAI,IACpB,WAAY,CAAC,GAAI,IACjB,YAAa,CAAC,GAAI,KAEtB,QAAS,CACL,QAAS,CAAC,GAAI,IACd,MAAO,CAAC,GAAI,IACZ,QAAS,CAAC,GAAI,IACd,SAAU,CAAC,GAAI,IACf,OAAQ,CAAC,GAAI,IACb,UAAW,CAAC,GAAI,IAChB,OAAQ,CAAC,GAAI,IACb,QAAS,CAAC,GAAI,IAGd,cAAe,CAAC,IAAK,IACrB,YAAa,CAAC,IAAK,IACnB,cAAe,CAAC,IAAK,IACrB,eAAgB,CAAC,IAAK,IACtB,aAAc,CAAC,IAAK,IACpB,gBAAiB,CAAC,IAAK,IACvB,aAAc,CAAC,IAAK,IACpB,cAAe,CAAC,IAAK,QAKtB,MAAM,KAAO,EAAO,MAAM,cAC1B,QAAQ,OAAS,EAAO,QAAQ,gBAChC,MAAM,KAAO,EAAO,MAAM,cAC1B,QAAQ,OAAS,EAAO,QAAQ,uBAE5B,CAAC,EAAW,IAAU,QAAO,QAAa,GAAS,UAC/C,CAAC,EAAW,IAAU,QAAO,QAAa,KAC1C,GAAa,CAChB,KAAM,KAAU,EAAM,MACtB,MAAO,KAAU,EAAM,SAGrB,GAAa,EAAO,KAEpB,IAAI,EAAM,GAAI,EAAM,WAGvB,eAAe,EAAQ,EAAW,CACrC,MAAO,EACP,WAAY,mBAIb,eAAe,EAAQ,QAAS,CACnC,MAAO,EACP,WAAY,OAGT,MAAM,MAAQ,UACd,QAAQ,MAAQ,UAEhB,MAAM,KAAO,OACb,MAAM,QAAU,OAChB,MAAM,QAAU,OAChB,QAAQ,KAAO,GAAW,MAC1B,QAAQ,QAAU,GAAY,MAC9B,QAAQ,QAAU,GAAY,WAG9B,iBAAiB,EAAQ,CAC5B,aAAc,CACV,MAAO,CAAC,EAAa,EAAe,IAG5B,IAAQ,GAAS,IAAU,EACvB,EAAM,EACC,GAGP,EAAM,IACC,IAGJ,KAAK,SAAc,GAAK,IAAO,IAAM,IAI5C,GACA,GAAK,KAAK,MAAO,EAAM,IAAO,GAC9B,EAAI,KAAK,MAAO,EAAQ,IAAO,GAC/B,KAAK,MAAO,EAAO,IAAO,GAGlC,WAAY,IAEhB,SAAU,CACN,MAAO,AAAC,GAAyB,MACvB,GAAU,yCAAyC,KACrD,EAAI,SAAS,QAEb,CAAC,QACM,CAAC,EAAG,EAAG,MAGd,CAAE,eAAgB,EAAQ,OAE1B,EAAY,SAAW,MACT,EACT,MAAM,IACN,IAAI,AAAC,GAAc,EAAY,GAC/B,KAAK,UAGR,GAAU,OAAO,SAAS,EAAa,UAEtC,CACF,GAAW,GAAM,IACjB,GAAW,EAAK,IACjB,EAAU,MAGlB,WAAY,IAEhB,aAAc,CACV,MAAO,AAAC,GACJ,EAAO,aAAa,GAAG,EAAO,SAAS,IAC3C,WAAY,IAEhB,cAAe,CACX,MAAO,AAAC,GAAiB,IACjB,EAAO,QACA,IAAK,KAGZ,EAAO,SACA,OAAa,MAGpB,GACA,EACA,KAEA,GAAQ,UACO,KAAO,GAAK,GAAK,MACxB,IACD,MACJ,IACK,QAEF,GAAY,EAAO,KAEnB,KAAK,MAAM,EAAO,IAAM,IACtB,KAAK,MAAM,EAAY,GAAK,IAC5B,EAAY,EAAK,OAGvB,GAAQ,KAAK,IAAI,EAAK,EAAO,GAAQ,KAEvC,IAAU,QACH,OAGP,GACA,SACO,MAAM,IAAS,EACjB,KAAK,MAAM,IAAU,EACtB,KAAK,MAAM,UAEf,KAAU,OACA,IAGP,GAEX,WAAY,IAEhB,UAAW,CACP,MAAO,CAAC,EAAa,EAAe,IAChC,EAAO,cAAc,EAAO,aAAa,EAAK,EAAO,IACzD,WAAY,IAEhB,UAAW,CACP,MAAO,AAAC,GACJ,EAAO,cAAc,EAAO,aAAa,IAC7C,WAAY,MAIb,EAGX,KAAM,GAAa,iBC1af,EACA,EACA,EACF,IACM,GAAQ,EAAO,QAAQ,MACvB,IAAU,SACH,QAGL,GAAkB,EAAU,UAC9B,GAAW,EACX,EAAc,SAGV,EAAO,OAAO,EAAU,EAAQ,GAAY,EAAY,IACjD,EAAQ,IACX,EAAO,QAAQ,EAAW,SAC7B,IAAU,cAEJ,EAAO,MAAM,GACrB,cAIP,EACA,EACA,EACA,EACF,IACM,GAAW,EACX,EAAc,KACf,MACO,GAAQ,EAAO,EAAQ,KAAO,QAEhC,EAAO,OAAO,KAAmB,EAAQ,EAAI,GAAS,GACtD,KACS;AAAA,EAAS;AAAA,GAClB,IACO,EAAQ,IACX,EAAO,QAAQ;AAAA,EAAM,SACxB,IAAU,cAEJ,EAAO,MAAM,GACrB,ECzCX,KAAM,IAAY,OAAO,aACnB,GAAS,OAAO,UAChB,GAAW,OAAO,YAGlB,GAAe,CAAC,OAAQ,OAAQ,UAAW,WAE3C,GAAS,OAAO,OAAO,MAmVvB,GAAe,CAAC,EAAa,EAAmB,KAAO,IAErD,EAAQ,OACR,SACW,UAAU,EAAQ,QACzB,EAAQ,OAAS,GACjB,EAAQ,OAAS,QAGf,IAAI,OAAM,4DAId,GAAa,IACZ,MAAQ,EAAQ,QAAU,OAAY,EAAa,EAAQ,OAUhE,GAAe,AAAC,GAAqB,MACjC,GAAQ,IAAI,IAAsB,EAAQ,KAAK,eACxC,EAAO,UAEb,eAAe,EAAO,GAAY,WAElC,GAGX,YAAqB,EAAkC,OAC5C,IAAa,GAGxB,OAAO,eAAe,GAAY,UAAW,SAAS,WAEtD,SAAW,CAAC,EAAW,IAAU,QAAO,QAAQ,MACrC,GAAa,CAChB,KAAM,MACI,GAAU,GACZ,KACA,GAAa,EAAM,KAAM,EAAM,MAAO,KAAK,KAC3C,KAAK,mBAEF,eAAe,KAAM,EAAW,CAAE,MAAO,IACzC,IAKnB,GAAO,QAAU,CACb,KAAM,MACI,GAAU,GAAc,KAAM,KAAK,IAAS,kBAC3C,eAAe,KAAM,UAAW,CAAE,MAAO,IACzC,IAIf,KAAM,IAAe,CACjB,EACA,EACA,KACG,IAEC,IAAU,MACN,IAAU,UAEH,EAAW,GAAM,QAAQ,GAAG,GAGnC,IAAU,UAEH,EAAW,GAAM,QAEpB,EAAW,aAAa,GAAG,IAK5B,EAAW,GAAM,KAAK,EAAW,UAAU,GAAG,IAGrD,IAAU,MACH,GACH,MACA,EACA,EAEA,GAAG,EAAW,SAAS,GAAG,IAK3B,EAAW,GAAM,GAAO,GAAG,GAGhC,GAAa,CAAC,MAAO,MAAO,WAElC,SAAW,KAAS,IAAY,IACrB,GAAS,CACZ,KAAM,MACI,CAAE,SAAU,WACX,aAAa,EAAmB,MAC7B,GAAS,GACX,GACI,EACA,GAAa,GACb,QACA,GAAG,GAEP,EAAW,MAAM,MACjB,KAAK,WAEF,IAAc,KAAM,EAAQ,KAAK,aAK9C,GAAU,KAAO,EAAM,GAAG,cAAgB,EAAM,MAAM,MACrD,GAAW,CACd,KAAM,MACI,CAAE,SAAU,WACX,aAAa,EAAmB,MAC7B,GAAS,GACX,GACI,EACA,GAAa,GACb,UACA,GAAG,GAEP,EAAW,QAAQ,MACnB,KAAK,WAEF,IAAc,KAAM,EAAQ,KAAK,QAMxD,KAAM,IAAQ,OAAO,iBAAiB,IAAM,GAAI,SACzC,IADyC,CAE5C,MAAO,CACH,WAAY,GACZ,KAAM,OACK,MAAK,IAAW,OAE3B,IAAI,EAAO,MACF,IAAW,MAAQ,OAK9B,GAAe,CAAC,EAAW,EAAY,IAAgB,IACrD,GACA,QACA,KAAW,UACD,IACC,MAED,EAAO,QAAU,IAChB,EAAQ,EAAO,UAGvB,CACH,OACA,QACA,UACA,WACA,WAIF,GAAgB,CAAC,EAAW,EAAc,IAAkB,MAGxD,GAAe,IAAI,IACrB,GACI,EACA,EAAW,SAAW,EAAI,GAAK,EAAW,GAAK,EAAW,KAAK,oBAKhE,eAAe,EAAS,MAEvB,IAAa,IACb,IAAU,IACV,IAAY,EAEb,GAGL,GAAa,CAAC,EAAW,IAAmB,IAC1C,EAAK,OAAS,GAAK,CAAC,QACb,GAAK,IAAY,GAAK,KAG7B,GAAS,EAAK,OAEd,IAAW,aACJ,QAGL,CAAE,UAAS,YAAa,KAC1B,EAAO,SAAS,UACT,IAAW,UAIL,GAAiB,EAAQ,EAAO,MAAO,EAAO,QAE9C,EAAO,YAOlB,GAAU,EAAO,QAAQ;AAAA,SAC3B,KAAY,OACH,GACL,EACA,EACA,EACA,IAID,EAAU,EAAS,GAG9B,OAAO,iBAAiB,GAAY,UAAW,IAE/C,KAAM,GAAQ,KACa,GAAY,CAAE,MAAO,eCjjBxB,EAA2B,IAC3C,IAAU,aACH,eACA,IAAU,WACV,UACA,MAAM,QAAQ,SACd,WACA,MAAO,IAAU,gBACjB,aACA,MAAO,IAAU,iBACjB,cACA,MAAO,IAAU,eACjB,YACA,MAAO,IAAU,eACjB,YACA,MAAO,IAAU,eACjB,YACA,MAAO,IAAU,SAAU,IAC9B,GAAS,KAAM,IACX,EAAM,cAAgB,aACf,YACA,EAAM,cAAgB,UACtB,SACA,EAAM,cAAgB,UACtB,SACA,EAAM,cAAgB,WACtB,aAGR,iBACA,MAAO,IAAU,eACjB,cAGL,IAAI,OAAM,0BAA0B,UAGjC,IAAc,AAAC,GAA4B,OAAO,KAAW,ECpDpE,GAAgC,CAClC,EACA,IACC,MACK,GAA+B,OAAO,KAAK,GAAQ,KAAK,SAE1D,QAAO,8BACA,sBAAsB,GAAQ,QAAQ,AAAC,GAAW,CACjD,OAAO,yBAAyB,EAAQ,GAAS,cAC5C,KAAK,KAKf,eASP,EACA,EACA,EACA,EACA,EACA,EAIA,EAAoB,KACd,IACF,GAAS,GACT,EAAU,EAAS,UAEnB,CAAC,EAAQ,KAAM,IACL,EAAO,kBAEX,GAAkB,EAAc,EAAO,YAEtC,CAAC,EAAQ,MAAM,MACZ,GAAO,EACT,EAAQ,MAAM,GACd,EACA,EACA,EACA,GAEE,EAAQ,EACV,EAAQ,MAAM,GACd,EACA,EACA,EACA,MAGM,EAAkB,EAAO,EAAY,IAErC,EAAS,OAEd,EAAQ,KAED,EAAO,SACL,QAFA,IAAM,EAAO,gBAMrB,EAAO,aAAe,QAG7B,eASP,EACA,EACA,EACA,EACA,EACA,EACM,IACF,GAAS,GACT,EAAU,EAAS,UAEnB,CAAC,EAAQ,KAAM,IACL,EAAO,kBAEX,GAAkB,EAAc,EAAO,YAEtC,CAAC,EAAQ,SAER,EACA,EAAQ,EAAQ,MAAO,EAAQ,EAAiB,EAAO,KAEjD,EAAS,OAEd,EAAQ,KAED,EAAO,SACL,QAFA,IAAM,EAAO,gBAMrB,EAAO,aAAe,QAG7B,eASP,EACA,EACA,EACA,EACA,EACA,EACM,IACF,GAAS,MAET,EAAK,OAAQ,IACH,EAAO,kBAEX,GAAkB,EAAc,EAAO,cAEpC,GAAI,EAAG,EAAI,EAAK,OAAQ,OACnB,EAEN,IAAK,QACK,EACN,EAAK,GACL,EACA,EACA,EACA,IAIJ,EAAI,EAAK,OAAS,KACR,IAAM,EAAO,aACf,EAAO,SACL,QAIR,EAAO,aAAe,QAG7B,eASP,EACA,EACA,EACA,EACA,EACA,EACM,IACF,GAAS,QACP,GAAO,GAA8B,EAAK,EAAO,gBAEnD,EAAK,OAAQ,IACH,EAAO,kBAEX,GAAkB,EAAc,EAAO,cAEpC,GAAI,EAAG,EAAI,EAAK,OAAQ,IAAK,MAC5B,GAAM,EAAK,GACX,EAAO,EAAQ,EAAK,EAAQ,EAAiB,EAAO,GACpD,EAAQ,EACV,EAAI,GACJ,EACA,EACA,EACA,MAGM,EAAkB,EAAO,KAAO,EAEtC,EAAI,EAAK,OAAS,KACR,IAAM,EAAO,aACf,EAAO,SACL,QAIR,EAAO,aAAe,QAG7B,GC9MX,KAAM,IACF,MAAO,SAAW,YAAc,OAAO,IACjC,OAAO,IAAI,0BACX,QACJC,GAAQ,IAEDC,GAAoC,CAC7C,EACA,EACA,EACA,EACA,EACA,IACC,MACK,GAAgB,EAAI,iBAGtB,KAAkB,mBAClB,IAAkB,qBAEd,EAAE,EAAQ,EAAO,SACV,IAAM,EAAgB,IAG7B,EACAD,GACA,IACA,GACI,EAAI,OACJ,EACA,EACA,EACA,EACA,GAEJ,IAKJ,IAAkB,oBAClB,IAAkB,sBAEd,EAAE,EAAQ,EAAO,SACV,IAAM,EAAgB,IAG7B,EACAA,GACA,IACA,GACI,EAAI,OACJ,EACA,EACA,EACA,EACA,GAEJ,IAKJ,IAAkB,kBAClB,IAAkB,qBAUlB,IAAkB,oBAClB,IAAkB,sBAGd,EACAA,GACA,EAAQ,EAAI,OAAQ,EAAQ,EAAa,EAAO,GAIjD,EAAI,uBAGFE,GAA0B,AAAC,GACpC,GAAO,EAAI,WAAa,GAEtBC,GAAoB,WAAEF,QAAWC,gBCnFL,CAAE,YAAY,IAAU,GAAY,MAC5D,GAAU,CACZ,+HACA,4DACF,KAAK,WAEA,IAAI,QAAO,EAAS,EAAY,OAAY,KCZvD,KAAM,IAAsB,AAAC,GACzB,EAAK,QAAQ,KAAa,AAAC,GAAU,QACzB,OACCE,GAAM,IAAI,UACVA,GAAM,MAAM,UACZA,GAAM,KAAK,UACXA,GAAM,KAAK,UACXA,GAAM,MAAM,UACZA,GAAM,OAAO,UACbA,GAAM,MAAM,UACZA,GAAM,QAAQ,UACdA,GAAM,SAAS,UACfA,GAAM,QAAQ,UACdA,GAAM,IAAI,UACVA,GAAM,KAAK,UACXA,GAAM,MAAM,SACZA,GAAM,MAAM,YACN,UACNA,GAAM,IAAI,WACJ,YACNA,GAAM,MAAM,WACN,cACNA,GAAM,KAAK,WACL,aACNA,GAAM,KAAK,WACL,aACNA,GAAM,MAAM,WACN,cACNA,GAAM,OAAO,WACP,eACNA,GAAM,MAAM,WACN,cACNA,GAAM,QAAQ,WACR,gBACNA,GAAM,SAAS,WACT,iBACNA,GAAM,QAAQ,WACR,gBACNA,GAAM,IAAI,WACJ,YACNA,GAAM,KAAK,WACL,uBAEA,MAIVF,GAA0B,AAAC,GACpC,MAAO,IAAQ,UAAY,CAAC,CAAC,EAAI,MAAM,MAE9BD,GAAoC,CAC7C,EACA,EACA,EACA,EACA,EACA,IACC,EAAQ,GAAoB,GAAM,EAAQ,EAAa,EAAO,GAE7DE,GAAoB,WAAEF,QAAWC,IC1DjCF,GAAQ,IAER,GAAe,CAAC,eAAgB,gBAChC,GAAe,iCAEf,GAAW,AAAC,GACd,GAAa,QAAQ,KAAU,IAAM,GAAa,KAAK,GAE9CE,GAA0B,AAAC,GACpC,GACA,EAAI,aACJ,CAAC,CAAC,EAAI,YAAY,MAClB,GAAS,EAAI,YAAY,MAEvB,GAAiB,AAAC,GACpB,EAAW,YAAY,OAAS,eAEvBD,GAAoC,CAC7C,EACA,EACA,EACA,EACA,EACA,IACC,MACK,GAAO,EAAW,YAAY,WAChC,EAAE,EAAQ,EAAO,SACV,IAAM,EAAO,OAIZ,IAAM,GAAK,EAAOD,QACZ,QAAQ,KAAU,GAC1B,IACA,GACI,GAAe,GACT,MAAM,KAAK,GAAY,OACnB,CAAC,EAAO,OACE,EAAU,MAAQ,EAAU,MAC3B,GAEX,IAEJ,MAAK,GACX,EACA,EACA,EACA,EACA,GAEJ,IACA,IACA,GACI,MAAM,KAAK,GACX,EACA,EACA,EACA,EACA,GAEJ,MAIRG,GAAoB,WAAEF,QAAWC,gBCrEJ,EAAqB,OAC7C,GAAI,QAAQ,KAAM,QAAQ,QAAQ,KAAM,aCGtC,IAAa,CACtB,EACA,EACA,EACA,EACA,EACA,EACA,IACS,MACH,GAAkB,EAAc,EAAO,OACvC,EAAS,EAAO,aACf,GACF,IAAI,AAAC,GAAQ,MACJ,GAAQ,EAAM,MAChB,GAAU,EAAQ,EAAO,EAAQ,EAAiB,EAAO,SAEzD,OAAO,IAAU,UACb,GAAQ,QAAQ;AAAA,KAAU,OAEtB,EAAO,aACP,EACA,EACA,EAAO,aACP,KAEE,IAAM,EAAU,KAI1B,EAAO,aACP,EACA,EAAO,KAAK,KACZ,EACA,EAAO,KAAK,MACZ,IACA,EAAO,MAAM,KACb,EACA,EAAO,MAAM,QAGpB,KAAK,KAID,GAAgB,CACzB,EACA,EACA,EACA,EACA,EACA,IAEA,EACK,IACG,AAAC,GACG,EAAO,aACP,SACQ,IAAU,SACZ,GAAU,EAAO,GACjB,EAAQ,EAAO,EAAQ,EAAa,EAAO,KAExD,KAAK,IAED,GAAY,CAAC,EAAc,IAA2B,MACzD,GAAe,EAAO,OAAO,cAC5B,GAAa,KAAO,GAAW,GAAQ,EAAa,OAGlD,GAAe,CAAC,EAAiB,IAA2B,MAC/D,GAAe,EAAO,OAAO,cAE/B,GAAa,KACb,OACA,GAAW,GACX,MACA,EAAa,OAQR,GAAe,CACxB,EACA,EACA,EACA,EACA,IACS,MACH,GAAW,EAAO,OAAO,UAE3B,GAAS,KACT,IACA,MAEI,EAAS,MACL,EACA,EAAO,aACP,EACA,EAAS,SAEX,IACA,EAAS,MACT,EACA,EAAO,aACP,EACA,EAAS,KACT,KACA,MACiB,CAAC,EAAO,IAAM,GAAK,KAAO,KACjD,IACA,EAAS,OAIJ,GAAqB,CAAC,EAAc,IAA2B,MAClE,GAAW,EAAO,OAAO,UAE3B,GAAS,KACT,IACA,EACA,EAAS,MACT,UACA,EAAS,KACT,MACA,EAAS,OCxHX,GAAe,EACf,GAAY,EACZ,GAAe,EACf,GAAgB,GAEhB,GAAiB,4BAEjB,GAAmB,AAAC,GAAa,IAC/B,OACO,OAAO,GAAI,cAAiB,YAAc,EAAI,aAAa,kBAE3D,KAIT,GAAW,AAAC,GAAa,MACrB,GAAkB,EAAI,YAAY,KAClC,CAAE,WAAU,WAAY,EACxB,EACD,MAAO,IAAY,UAAY,EAAQ,SAAS,MACjD,GAAiB,SAGhB,KAAa,QACM,KAAK,IAAoB,IAC5C,IAAa,IAAa,IAAoB,QAC9C,IAAa,IAAgB,IAAoB,WACjD,IAAa,IAAiB,IAAoB,oBAI9CA,GAA0B,AAAC,UACpC,2BAAK,cAAL,cAAkB,OAAQ,GAAS,IAIvC,YAAoB,EAAiC,OAC1C,GAAK,WAAa,GAG7B,YAAuB,EAAoC,OAChD,GAAK,WAAa,GAG7B,YAAwB,EAA6C,OAC1D,GAAK,WAAa,QAGhBD,IAAoC,CAC7C,EACA,EACA,EACA,EACA,EACA,IACC,IACG,GAAW,SACJ,IAAU,EAAK,KAAM,MAG5B,GAAc,SACP,IAAa,EAAK,KAAM,QAG7B,GAAO,GAAe,GACtB,mBACA,EAAK,QAAQ,oBAEf,EAAE,EAAQ,EAAO,SACV,GAAmB,EAAM,GAG7B,GACH,EACA,GACI,GAAe,GACT,GACA,MAAM,KAAK,EAAK,YACX,IAAI,AAAC,GAAS,EAAK,MACnB,OACX,GAAe,GACT,GACA,MAAM,KAAK,EAAK,YAAY,OACxB,CAAC,EAAO,OACE,EAAU,MAAQ,EAAU,MAC3B,GAEX,IAEV,EACA,EAAc,EAAO,OACrB,EACA,EACA,GAEJ,GACI,MAAM,UAAU,MAAM,KAAK,EAAK,YAAc,EAAK,UACnD,EACA,EAAc,EAAO,OACrB,EACA,EACA,GAEJ,EACA,IAIFE,GAAoB,WAAEF,QAAWC,IClHjC,GAAuB,6BACvB,GAAmB,yBACnBG,GAAoB,0BACpB,GAAkB,wBAClBC,GAAsB,4BACtB,GAAqB,2BACrB,GAAkB,wBAClBC,GAAkB,wBAClB,GAAoB,0BAEpB,GAAmB,AAAC,GAAiB,aAAe,EACpD,GAAc,AAAC,GAAiB,IAAM,EAAO,IAC7C,GAAQ,IACR,GAAO,SAEP,GAAwB,CAC1B,EACA,EACA,EACA,EACA,EACA,EACA,IAEA,EAAE,EAAQ,EAAO,SACX,GAAY,GAAiB,IAC7B,GAAiB,GACjB,GACA,IACA,GACI,EAAI,UACJ,EACA,EACA,EACA,EACA,GAEJ,IAIV,YAA0B,EAAyB,IAC3C,GAAI,QACD,CACH,MAAO,IACC,EAAI,EAAI,MAAM,OAAQ,MAChB,GAAM,EAAI,MAAM,WACf,CAAE,KAAM,GAAO,MAAO,CAAC,EAAK,EAAI,IAAI,WAExC,CAAE,KAAM,GAAM,MAAO,UAKxC,KAAM,IAAuB,CACzB,EACA,EACA,EACA,EACA,EACA,IACS,MAGH,GAAO,GAAiB,EAAI,OAAS,gBACpC,EAAE,EAAQ,EAAO,SAClB,GAAY,GACZ,EACI,GACA,IACA,GACI,GAAiB,GACjB,EACA,EACA,EACA,EACA,GAEJ,KAGR,GAAoB,CACtB,EACA,EACA,EACA,EACA,EACA,IACS,MACH,GAAO,GAAiB,aAE1B,EAAE,EAAQ,EAAO,SACV,GAAY,GAGnB,EAAIF,IAEA,EACA,GACA,OAEK,OAAS,EAAI,QACZ,GACI,EAAI,UACJ,EACA,EACA,EACA,EACA,GAEJ,IACN,IAKJ,EACA,GACA,OACK,OACL,EAAI,QACJ,EAAI,aACJ,EAAI,UACE,GACI,EAAI,SACJ,EACA,EACA,EACA,EACA,GAEJ,IACN,KAIF,GAAuB,CACzB,EACA,EACA,EACA,EACA,EACA,EACA,IAEA,EAAE,EAAQ,EAAO,SACX,GAAY,GAAiB,IAC7B,GAAiB,GACjB,GACA,IACA,GACI,EAAI,SACJ,EACA,EACA,EACA,EACA,GAEJ,IAEGJ,GAAoC,CAC7C,EACA,EACA,EACA,EACA,EACA,IAEI,EAAI,IACG,GACH,EACA,EACA,EACA,EACA,EACA,EACA,EAAIK,IAAuB,aAAe,OAI9C,EAAI,IACG,GACH,EACA,EACA,EACA,EACA,EACA,EACA,QAGJ,EAAIC,IACG,GACH,EACA,EACA,EACA,EACA,EACA,EACA,EAAID,IAAuB,aAAe,OAG9C,EAAI,IACG,GACH,EACA,EACA,EACA,EACA,EACA,EACA,SAIJ,EAAI,IACG,GACH,EACA,EACA,EACA,EACA,EACA,GAKD,GAAqB,EAAK,EAAQ,EAAa,EAAO,EAAM,GAK1DJ,GAA0B,AAAC,GACpC,MACK,MAA0B,IAAQ,EAAI,MAAwB,IAEjEC,GAAoB,WAAEF,QAAWC,IC7NjC,GACF,MAAO,SAAW,YAAc,OAAO,IACjC,OAAO,IAAI,mBACX,UAEJ,GAAc,AAAC,GAA4B,MACvC,CAAE,SAAU,QAEX,GACD,OAAO,KAAK,GACP,OAAO,AAAC,GAAQ,EAAM,KAAS,QAC/B,OACL,IAGG,GAAoC,CAC7C,EACA,EACA,EACA,EACA,EACA,IAEA,EAAE,EAAQ,EAAO,SACX,GAAmB,EAAO,KAAM,GAChC,GACI,EAAO,KACP,EAAO,MACD,GACI,GAAY,GACZ,EAAO,MACP,EACA,EAAc,EAAO,OACrB,EACA,EACA,GAEJ,GACN,EAAO,SACD,GACI,EAAO,SACP,EACA,EAAc,EAAO,OACrB,EACA,EACA,GAEJ,GACN,EACA,GAGD,GAA0B,AAAC,GACpC,GAAO,EAAI,WAAa,GAEtB,GAAoB,CAAE,aAAW,SC9BjC,GAAW,OAAO,UAAU,SAC5B,GAAc,KAAK,UAAU,YAC7B,GAAgB,MAAM,UAAU,SAChC,GAAiB,OAAO,UAAU,SAMlC,GAAqB,AAAC,GACvB,MAAO,GAAI,aAAgB,YAAc,EAAI,YAAY,MAAS,SAIjE,GAAW,AAAC,GACd,MAAO,SAAW,aAAe,IAAQ,OAEvC,GAAgB,uBAChB,GAAiB,OAEvB,gBAAsC,MAAM,CACxC,YAAY,EAAiB,EAAe,OAClC,QACD,MAAQ,OACR,KAAO,KAAK,YAAY,MAIrC,YAA+B,EAA6B,OAEpD,KAAe,kBACf,IAAe,wBACf,IAAe,qBACf,IAAe,yBACf,IAAe,yBACf,IAAe,sBACf,IAAe,uBACf,IAAe,uBACf,IAAe,uBACf,IAAe,8BACf,IAAe,wBACf,IAAe,uBAIvB,YAAqB,EAAqB,OAC/B,QAAO,GAAG,EAAK,IAAM,KAAO,OAAO,GAG9C,YAAqB,EAAqB,OAC/B,QAAO,GAAG,MAGrB,YAAuB,EAAe,EAAoC,OACjE,GAGE,gBAAoB,MAAQ,aAAe,IAFvC,aAKf,YAAqB,EAAqB,OAC/B,QAAO,GAAK,QAAQ,GAAe,cAG9C,YAAoB,EAAoB,OAC7B,IAAM,GAAc,KAAK,GAAO,IAO3C,YACI,EACA,EACA,EACA,EACa,IACT,IAAQ,IAAQ,IAAQ,SACjB,GAAK,KAEZ,IAAQ,aACD,eAEP,IAAQ,WACD,YAGL,GAAS,MAAO,MAElB,IAAW,eACJ,IAAY,MAEnB,IAAW,eACJ,IAAY,MAEnB,IAAW,eACP,GACO,IAAM,EAAI,QAAQ,QAAS,QAAU,IAEzC,IAAM,EAAM,OAEnB,IAAW,iBACJ,IAAc,EAAK,MAE1B,IAAW,eACJ,IAAY,QAGjB,GAAa,GAAS,KAAK,SAE7B,KAAe,mBACR,aAEP,IAAe,mBACR,aAGP,IAAe,qBACf,IAAe,6BAER,GAAc,EAAK,GAE1B,IAAe,kBACR,GAAY,GAEnB,IAAe,gBACR,MAAM,CAAC,GAAO,eAAiB,GAAY,KAAK,GAEvD,IAAe,iBACR,GAAW,GAElB,IAAe,kBACX,EAEO,GACF,KAAK,GACL,QAAQ,sBAAuB,QAEjC,GAAe,KAAK,GAG3B,YAAe,OACR,GAAW,GAGf,KAOX,YACI,EACA,EACA,EACA,EACA,EACA,EACM,IACF,EAAK,QAAQ,KAAS,SACf,eAEJ,EAAK,UACP,KAAK,QAEJ,GAAc,EAAE,EAAQ,EAAO,SAC/B,EAAM,EAAO,OAGf,EAAO,YACP,CAAC,GACD,EAAI,QACJ,MAAO,GAAI,QAAW,YACtB,CAAC,QAEM,IAAQ,EAAI,SAAU,EAAQ,EAAa,EAAO,EAAM,SAG7D,GAAa,GAAS,KAAK,SAC7B,KAAe,qBACR,EACD,iBACO,GAAK,cACR,IACA,GACI,EACA,EACA,EACA,EACA,EACA,IAEJ,IAEV,GAAsB,GACf,EACD,IAAM,EAAI,YAAY,KAAO,QAGvB,CAAC,EAAO,qBACR,EAAI,YAAY,OAAS,QAFzB,GAIA,EAAI,YAAY,KAAO,KACzB,IACA,GACI,EACA,EACA,EACA,EACA,EACA,IAEJ,IAEV,IAAe,eACR,EACD,QACA,QACI,GACI,EAAI,UACJ,EACA,EACA,EACA,EACA,GACA,QAEJ,IAEV,IAAe,eACR,EACD,QACA,QACI,GACI,EAAI,SACJ,EACA,EACA,EACA,EACA,IAEJ,IAKP,GAAe,GAAS,GACzB,IAAM,GAAmB,GAAO,QAG1B,CAAC,EAAO,qBACR,GAAmB,KAAS,SAF5B,GAIA,GAAmB,GAAO,KAC5B,IACA,GACI,EACA,EACA,EACA,EACA,EACA,IAEJ,IAGd,YAAqB,EAAqC,OAC9C,GAAqB,WAAa,KAG9C,YACI,EACA,EACA,EACA,EACA,EACA,EACM,IACF,MAEA,GACU,GAAY,GAChB,EAAO,UAAU,EAAK,EAAQ,EAAa,EAAO,EAAM,IACxD,EAAO,MACH,EACA,AAAC,GACG,GAAQ,EAAU,EAAQ,EAAa,EAAO,GAClD,AAAC,GAAQ,MACC,GAAkB,EAAc,EAAO,aAEzC,GACA,EAAI,QAAQ,GAAgB;AAAA,EAAO,IAG3C,CACI,YAAa,EAAO,aACpB,IAAK,EAAO,IACZ,QAAS,EAAO,cAEpB,EAAO,cAEZ,QACC,IAAI,IAAwB,EAAM,QAAS,EAAM,UAEvD,MAAO,IAAY,cACb,IAAI,OACN,yEAAyE,MAAO,cAGjF,GAGX,YAAoB,EAAkB,EAAc,QACvC,GAAI,EAAG,EAAI,EAAQ,OAAQ,OAC5B,IACI,EAAQ,GAAG,KAAK,SACT,GAAQ,SAEd,QACC,IAAI,IAAwB,EAAM,QAAS,EAAM,aAIxD,MAGX,YACI,EACA,EACA,EACA,EACA,EACA,EACM,MACA,GAAS,GAAW,EAAO,QAAS,MACtC,IAAW,WACJ,IAAY,EAAQ,EAAK,EAAQ,EAAa,EAAO,QAG1D,GAAc,GAChB,EACA,EAAO,kBACP,EAAO,YACP,EAAO,oBAEP,KAAgB,KACT,EAGJ,GACH,EACA,EACA,EACA,EACA,EACA,GAIR,KAAM,IAAuB,CACzB,QAAS,OACT,QAAS,QACT,KAAM,SACN,IAAK,OACL,MAAO,SAGL,GAAqB,OAAO,KAAK,IAI1B,GAA2B,CACpC,WAAY,GACZ,YAAa,OACb,YAAa,GACb,aAAc,GACd,UAAW,GACX,OAAQ,EACR,SAAU,IACV,IAAK,GACL,QAAS,GACT,oBAAqB,GACrB,kBAAmB,GACnB,MAAO,IAGX,YAAyB,EAA0B,WACxC,KAAK,GAAS,QAAQ,AAAC,GAAQ,IAC9B,CAAC,GAAgB,eAAe,QAC1B,IAAI,OAAM,kCAAkC,SAItD,EAAQ,KAAO,EAAQ,SAAW,QAAa,EAAQ,SAAW,OAC5D,IAAI,OACN,yEAIJ,EAAQ,QAAU,OAAW,IACzB,EAAQ,QAAU,UACZ,IAAI,OAAM,sDAGhB,MAAO,GAAQ,OAAU,cACnB,IAAI,OACN,gFAAgF,MAAO,GAAQ,YAM/G,KAAM,IAAqB,AAAC,GACxB,GAAmB,OAAO,CAAC,EAAQ,IAAQ,MACjC,GACF,EAAQ,OAAS,EAAQ,MAAM,KAAS,OAClC,EAAQ,MAAM,GACd,GAAc,GAClB,EAAQ,GAAUE,EAAc,MAElC,GACA,MAAO,GAAM,OAAU,UACvB,MAAO,GAAM,MAAS,WAEf,GAAO,YAER,IAAI,OACN,4CAA4C,mBAAqB,yCAGlE,IACR,OAAO,OAAO,OAEf,GAAiB,IACnB,GAAmB,OAAO,CAAC,EAAQ,OACxB,GAAO,CAAE,MAAO,GAAI,KAAM,IAC1B,GACR,OAAO,OAAO,OAEf,GAAuB,AAAC,GAC1B,GAAW,EAAQ,oBAAsB,OACnC,EAAQ,kBACR,GAAgB,kBAEpB,GAAiB,AAAC,GACpB,GAAW,EAAQ,cAAgB,OAC7B,EAAQ,YACR,GAAgB,YAEpB,GAAkB,AAAC,GACrB,GAAW,EAAQ,eAAiB,OAC9B,EAAQ,aACR,GAAgB,aAEpB,GAAY,AAAC,iBACf,WACI,GAAW,EAAQ,aAAe,OAC5B,EAAQ,WACR,GAAgB,WAC1B,OACI,GAAW,EAAQ,UACb,GAAmB,GACnB,KACV,YACI,GAAW,MAAO,GAAQ,aAAgB,WACpC,EAAQ,YACR,GAAgB,YAC1B,YAAa,GAAe,GAC5B,aAAc,GAAgB,GAC9B,OACI,GAAW,EAAQ,IACb,GACA,GACI,GAAW,EAAQ,SAAW,OACxB,EAAQ,OACR,GAAgB,QAEpC,SACI,GAAW,EAAQ,WAAa,OAC1B,EAAQ,SACR,GAAgB,SAC1B,IACI,GAAW,EAAQ,MAAQ,OACrB,EAAQ,IACR,GAAgB,IAC1B,QACI,GAAW,EAAQ,UAAY,OACzB,EAAQ,QACR,GAAgB,QAC1B,oBAAqB,oBAAS,sBAAT,OAAgC,GACrD,kBAAmB,GAAqB,GACxC,aAAc,GAAW,EAAQ,IAAM,IAAM;AAAA,EAC7C,aAAc,GAAW,EAAQ,IAAM,GAAK;AAAA,IAGhD,YAAsB,EAAwB,OACnC,IAAI,OAAM,EAAS,GAAG,KAAK,iBAQf,EAAc,EAAmC,IAChE,OACgB,GACZ,EAAQ,SAAS,MACX,GAAS,GAAW,EAAQ,QAAS,MACvC,IAAW,WACJ,IAAY,EAAQ,EAAK,GAAU,GAAU,GAAI,EAAG,SAKjE,GAAc,GAChB,EACA,GAAqB,GACrB,GAAe,GACf,GAAgB,UAEhB,KAAgB,KACT,EAGJ,GAAkB,EAAK,GAAU,GAAU,GAAI,EAAG,SAGhD,IAAU,mBACnBI,eACAC,iBACAC,cACAC,aACAC,sBACAC,ICniBJ,GAAI,GAAc,GACd,EAAc,EACd,EAAa,EASjB,OAAW,CAIP,YAAY,EAAY,EAAc,MAC7B,GAAK,OACL,GAAK,GAWlB,GAAI,IAAoB,SAAU,EAAe,EAAuB,IAEhE,CAAC,GAAS,CAAC,GAAS,EAAM,OAAO,IAAM,EAAM,OAAO,SAC7C,UAIP,GAAa,EACb,EAAa,KAAK,IAAI,EAAM,OAAQ,EAAM,QAC1C,EAAa,EACb,EAAe,EACZ,EAAa,GAEZ,EAAM,UAAU,EAAc,IAC9B,EAAM,UAAU,EAAc,MAEjB,IACE,KAEF,IAEJ,KAAK,SAAoB,GAAc,EAAI,SAErD,IASP,GAAoB,SAAU,EAAe,EAAuB,IAGhE,CAAC,GACD,CAAC,GACD,EAAM,OAAO,EAAM,OAAS,IAAM,EAAM,OAAO,EAAM,OAAS,SAEvD,UAIP,GAAa,EACb,EAAa,KAAK,IAAI,EAAM,OAAQ,EAAM,QAC1C,EAAa,EACb,EAAa,EACV,EAAa,GAEZ,EAAM,UACF,EAAM,OAAS,EACf,EAAM,OAAS,IAEnB,EAAM,UACF,EAAM,OAAS,EACf,EAAM,OAAS,MAGN,IACA,KAEA,IAEJ,KAAK,SAAoB,GAAc,EAAI,SAErD,IAWP,GAAsB,SAAU,EAAe,EAAuB,IAElE,GAAe,EAAM,OACrB,EAAe,EAAM,UAErB,GAAgB,GAAK,GAAgB,QAC9B,GAGP,EAAe,IACP,EAAM,UAAU,EAAe,GAChC,EAAe,MACd,EAAM,UAAU,EAAG,OAE3B,GAAc,KAAK,IAAI,EAAc,MAErC,GAAS,QACF,UAMP,GAAO,EACP,EAAS,IACA,IACL,GAAU,EAAM,UAAU,EAAc,GACxC,EAAQ,EAAM,QAAQ,MACtB,GAAS,SACF,MAED,EAEN,IAAS,GACT,EAAM,UAAU,EAAc,IAAW,EAAM,UAAU,EAAG,QAErD,SAUf,GAAuB,SAAU,EAAoB,QACjD,GAAU,GACV,EAAa,GACb,EAAmB,EAEnB,EAAe,KAEf,EAAU,EAEV,EAAqB,EACrB,EAAoB,EAEpB,EAAqB,EACrB,EAAoB,EACjB,EAAU,EAAM,QACf,EAAM,GAAS,IAAM,KAEV,KAAsB,IACZ,IACD,IACC,IACD,IACL,EAAM,GAAS,KAG1B,EAAM,GAAS,IAAM,KACC,EAAM,GAAS,GAAG,UAEnB,EAAM,GAAS,GAAG,OAKvC,GACA,EAAa,QACT,KAAK,IAAI,EAAoB,IACjC,EAAa,QACT,KAAK,IAAI,EAAoB,OAG3B,OACF,EAAW,EAAmB,GAC9B,EACA,GAAI,GAAK,EAAa,MAGpB,EAAW,EAAmB,GAAK,GAAG,GAAK,YAM7C,EAAmB,EACb,EAAW,EAAmB,GAC9B,KACW,IACD,IACC,IACD,IACL,OACL,aAOlB,MACkB,MAEO,KAQnB,EACH,EAAU,EAAM,QAAQ,IAEvB,EAAM,EAAU,GAAG,IAAM,GACzB,EAAM,GAAS,IAAM,EACvB,IACM,GAAW,EAAM,EAAU,GAAG,GAC9B,EAAY,EAAM,GAAS,GAC3B,EAAkB,GAAoB,EAAU,GAChD,EAAkB,GAAoB,EAAW,GACjD,GAAmB,EAEf,IAAmB,EAAS,OAAS,GACrC,GAAmB,EAAU,OAAS,OAGhC,OACF,EACA,EACA,GAAI,GACA,EACA,EAAU,UAAU,EAAG,OAGzB,EAAU,GAAG,GAAK,EAAS,UAC7B,EACA,EAAS,OAAS,KAEhB,EAAU,GAAG,GACf,EAAU,UAAU,QAKxB,IAAmB,EAAS,OAAS,GACrC,GAAmB,EAAU,OAAS,OAIhC,OACF,EACA,EACA,GAAI,GACA,EACA,EAAS,UAAU,EAAG,OAGxB,EAAU,GAAG,GAAK,IAClB,EAAU,GAAG,GAAK,EAAU,UAC9B,EACA,EAAU,OAAS,KAEjB,EAAU,GAAG,GAAK,IAClB,EAAU,GAAG,GAAK,EAAS,UAAU,kBAgB3D,GAA+B,SAAU,EAAoB,YAWzB,EAAa,EAAqB,IAC9D,CAAC,GAAO,CAAC,QAEF,MAQP,GAAQ,EAAI,OAAO,EAAI,OAAS,GAChC,EAAQ,EAAI,OAAO,GACnB,EAAmB,EAAM,MAAM,IAC/B,EAAmB,EAAM,MAAM,IAC/B,EAAc,GAAoB,EAAM,MAAM,IAC9C,EAAc,GAAoB,EAAM,MAAM,IAC9C,EAAa,GAAe,EAAM,MAAM,IACxC,EAAa,GAAe,EAAM,MAAM,IACxC,EAAa,GAAc,EAAI,MAAM,IACrC,EAAa,GAAc,EAAI,MAAM,UAErC,IAAc,EAEP,EACA,GAAc,EAEd,EACA,GAAoB,CAAC,GAAe,EAEpC,EACA,GAAe,EAEf,EACA,GAAoB,EAEpB,EAEJ,SAGP,GAAU,EAEP,EAAU,EAAM,OAAS,GAAG,IAE3B,EAAM,EAAU,GAAG,IAAM,GACzB,EAAM,EAAU,GAAG,IAAM,EAC3B,IAEM,GAAY,EAAM,EAAU,GAAG,GAC/B,EAAO,EAAM,GAAS,GACtB,EAAY,EAAM,EAAU,GAAG,GAG/B,EAAe,GAAkB,EAAW,MAC5C,EAAc,IACV,GAAe,EAAK,UAAU,EAAK,OAAS,KACpC,EAAU,UAClB,EACA,EAAU,OAAS,KAGnB,EACA,EAAK,UAAU,EAAG,EAAK,OAAS,KACxB,EAAe,SAI3B,GAAgB,EAChB,EAAW,EACX,EAAgB,EAChB,EACA,EAA2B,EAAW,GACtC,EAA2B,EAAM,GAC9B,EAAK,OAAO,KAAO,EAAU,OAAO,IAAI,IAC9B,EAAK,OAAO,KAClB,EAAK,UAAU,GAAK,EAAU,OAAO,KAChC,EAAU,UAAU,MAC5B,GACA,EAA2B,EAAW,GACtC,EAA2B,EAAM,GAEjC,GAAS,MACG,IACI,IACL,IACK,GAIpB,EAAM,EAAU,GAAG,IAAM,IAErB,IACM,EAAU,GAAG,GAAK,KAElB,OAAO,EAAU,EAAG,UAGxB,GAAS,GAAK,EAChB,IACM,EAAU,GAAG,GAAK,KAElB,OAAO,EAAU,EAAG,eAU1C,GAAwB,eACxB,GAAmB,KACnB,GAAkB,SAClB,GAAqB,WACrB,GAAuB,cAOvB,GAAoB,SAAU,EAAoB,GAE5C,KAAK,GAAI,GAAK,EAAY,YAC5B,GAAU,EACV,EAAe,EACf,EAAe,EACf,EAAc,GACd,EAAc,GACd,EACG,EAAU,EAAM,eACX,EAAM,GAAS,QACd,UAEc,EAAM,GAAS,iBAG7B,UAEc,EAAM,GAAS,iBAG7B,GAEG,EAAe,EAAe,EAC1B,KAAiB,GAAK,IAAiB,MAExB,GACX,EACA,GAEA,IAAiB,IAEb,EAAU,EAAe,EAAe,GACxC,EACI,EAAU,EAAe,EAAe,GAC1C,IAAM,IAGJ,EAAU,EAAe,EAAe,GAC1C,IAAM,EAAY,UAAU,EAAG,MAE3B,OACF,EACA,EACA,GAAI,GACA,EACA,EAAY,UAAU,EAAG,YAKvB,EAAY,UAAU,KACtB,EAAY,UAAU,MAGzB,GACX,EACA,GAEA,IAAiB,MACX,GAAS,GACX,EAAY,UACR,EAAY,OAAS,GACrB,EAAM,GAAS,KACT,EAAY,UACtB,EACA,EAAY,OAAS,KAEX,EAAY,UACtB,EACA,EAAY,OAAS,QAKtB,EAAe,IACpB,OAAO,EAAS,EAAe,GACjC,EAAY,WACN,OACF,EACA,EACA,GAAI,GAAK,EAAa,SAI1B,EAAY,WACN,OACF,EACA,EACA,GAAI,GAAK,EAAa,cAM9B,IAAY,GACZ,EAAM,EAAU,GAAG,IAAM,KAGnB,EAAU,GAAG,IAAM,EAAM,GAAS,KAClC,OAAO,EAAS,UAIX,IACA,IACD,KACA,SAItB,EAAM,EAAM,OAAS,GAAG,KAAO,MACzB,SAMN,GAAU,SACJ,EAEH,EAAU,EAAM,OAAS,GAExB,EAAM,EAAU,GAAG,IAAM,GACzB,EAAM,EAAU,GAAG,IAAM,IAIrB,EAAM,GAAS,GAAG,UACd,EAAM,GAAS,GAAG,OAAS,EAAM,EAAU,GAAG,GAAG,SAChD,EAAM,EAAU,GAAG,MAGlB,GAAS,GACX,EAAM,EAAU,GAAG,GACnB,EAAM,GAAS,GAAG,UACd,EACA,EAAM,GAAS,GAAG,OAAS,EAAM,EAAU,GAAG,GAAG,UAEnD,EAAU,GAAG,GACf,EAAM,EAAU,GAAG,GAAK,EAAM,EAAU,GAAG,KACzC,OAAO,EAAU,EAAG,KAChB,IAEV,EAAM,GAAS,GAAG,UAAU,EAAG,EAAM,EAAU,GAAG,GAAG,SACrD,EAAM,EAAU,GAAG,OAGb,EAAU,GAAG,IAAM,EAAM,EAAU,GAAG,KACtC,GAAS,GACX,EAAM,GAAS,GAAG,UAAU,EAAM,EAAU,GAAG,GAAG,QAClD,EAAM,EAAU,GAAG,KACjB,OAAO,EAAU,EAAG,KAChB,SAMlB,MACkB,SC/mBb,IAAkB,6CAElB,GACT,yHC4FE,GAAM,iBACN,EAAc,EAId,GAAoB,CACtB,EACA,EACA,EACA,EACA,IACC,IACG,GAAU,OACP,EAAS,GAAQ,EAAS,GAAQ,EAAS,EAAQ,OAC5C,KACA,KACC,QAER,IAKL,GAAoB,CACtB,EACA,EACA,EACA,EACA,IACC,IACG,GAAU,OACP,GAAU,GAAU,GAAU,GAAU,EAAS,EAAQ,OAClD,KACA,KACC,QAER,IAKL,GAAe,CACjB,EACA,EACA,EACA,EACA,EACA,EACA,IACS,IAEL,GAAK,EACL,EAAK,CAAC,EACN,EAAS,EAAU,GACnB,EAAc,IACR,IAAO,GACb,EAAS,EACT,EACA,EAAK,EAAS,EAAK,EACnB,EACA,QAIE,GAAK,EAAI,EAAQ,EAAI,MAGtB,GAAM,EAAG,GAAM,EAAG,GAAM,EAAI,GAAM,EAAG,GAAM,EAAG,IAI3C,IAAO,GAAK,EAAc,EAAU,KAC3B,EAAU,aAEV,EAAc,EAEnB,GAAQ,QAED,GAAK,IAKN,EAAU,KACd,GACN,EACA,GACI,EAAS,EACT,EACA,EAAK,EAAS,EAAK,EACnB,EACA,SAIL,IAKL,GAAe,CACjB,EACA,EACA,EACA,EACA,EACA,EACA,IACS,IAEL,GAAK,EACL,EAAK,EACL,EAAS,EAAU,GACnB,EAAc,IACR,IAAO,GACb,EACA,EAAS,EACT,EACA,EAAK,EAAS,EAAK,EACnB,QAIE,GAAK,EAAI,EAAQ,EAAI,MAGtB,GAAM,EAAG,GAAM,EAAG,GAAM,EAAI,GAAM,EAAG,GAAM,EAAG,IAI3C,IAAO,GAAK,EAAU,GAAM,IACnB,EAAU,aAEV,EAAc,EAEnB,EAAS,QAEF,GAAK,IAKN,EAAU,KACd,GACN,EACA,GACI,EACA,EAAS,EACT,EACA,EAAK,EAAS,EAAK,EACnB,SAIL,IAKL,GAA2B,CAC7B,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IACU,MACJ,GAAK,EAAS,EACd,EAAU,EAAO,EAEjB,EAAgB,AADN,EAAO,EACS,EAG1B,EAAe,CAAC,KAAqB,GACrC,EAAe,CAAC,KAAqB,MAEvC,GAAc,OAGZ,GAAK,EAAI,EAAQ,EAAI,SAGlB,GAAK,EAAG,EAAK,CAAC,EAAG,GAAM,EAAI,GAAM,EAAG,GAAM,EAAG,MAK5C,GAAS,IAAO,GAAM,IAAO,GAAK,EAAc,EAAU,GAC1D,EAAY,EAAS,EAAU,GAAM,EACrC,EAAS,EACT,EACA,EAAY,EAGZ,EAAS,EAAK,EAAS,EACvB,GAAW,GACb,EAAS,EACT,EACA,EAAS,EACT,EACA,GAEE,GAAQ,EAAS,QAET,EAAU,KACd,GAAM,GAEZ,GAAgB,GAAM,GAAM,EAAc,MAIpC,OAAU,KAAU,IAAkB,KAIxC,IAAM,GAAS,EAAU,IAAM,GAAK,GAAO,MAIrC,IAAY,EAAK,KAAsB,EAAK,EAAI,EAAK,GAKrD,GAAW,GACb,EACA,EACA,EACA,GACA,GAGE,GAAkB,EAAY,GAC9B,GAAkB,GAAY,GAE9B,GAAgB,GAAkB,EAClC,GAAgB,GAAkB,IAE/B,iBAAmB,EAAI,EAC5B,EAAI,GAAM,GAAgB,GAAgB,EAAS,KAI1C,cAAgB,IAChB,cAAgB,MAEhB,cAAgB,KAChB,cAAgB,MAGpB,iBAAmB,GACxB,KAAa,MACJ,iBAAmB,KACnB,iBAAmB,MAGvB,iBAAmB,GACxB,KAAa,MACJ,iBAAmB,EAAS,IAC5B,iBAAmB,EAAS,QAGnC,IAAkB,GAAQ,EAC1B,GAAkB,EAAS,GAAW,WAEnC,iBAAmB,EAAI,EAC5B,EAAI,GAAM,EAAO,EAAO,GAAkB,MAIjC,gBAAkB,IAClB,gBAAkB,MAElB,gBAAkB,KAClB,gBAAkB,IAGxB,WAKZ,IAKL,GAA2B,CAC7B,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IACU,MACJ,GAAK,EAAO,EACZ,EAAU,EAAO,EAEjB,EAAgB,AADN,EAAO,EACS,EAG1B,EAAe,EAAgB,EAC/B,EAAe,EAAgB,KAEjC,GAAc,OAGZ,GAAK,EAAI,EAAQ,EAAI,SAGlB,GAAK,EAAG,EAAK,EAAG,GAAM,EAAI,GAAM,EAAG,GAAM,EAAG,MAK3C,GAAS,IAAO,GAAM,IAAO,GAAK,EAAU,GAAM,EAClD,EAAY,EAAS,EAAU,GAAM,EACrC,EAAS,EACT,EACA,EAAY,EAGZ,EAAS,EAAK,EAAS,EACvB,GAAW,GACb,EACA,EAAS,EACT,EACA,EAAS,EACT,GAEE,GAAQ,EAAS,QAET,EAAU,KACd,GAAM,GAEZ,GAAgB,GAAM,GAAM,EAAc,MAIpC,UAAgB,IAAkB,KAIpC,IAAM,GAAS,GAAQ,GAAK,EAAU,IAAK,MACrC,IAAQ,EAAS,QAEd,iBAAmB,EACxB,IAAM,GAAQ,GAAQ,EAAS,KAItB,cAAgB,IAChB,cAAgB,MAEhB,cAAgB,KAChB,cAAgB,MAGpB,iBAAmB,GACxB,KAAa,MAEJ,iBAAmB,KACnB,iBAAmB,MAGvB,iBAAmB,EAAI,EAC5B,IAAM,IAEG,iBAAmB,IACnB,gBAAkB,IAClB,gBAAkB,MACxB,MAIG,IACF,EAAK,KAAsB,EAAK,EAAI,EAAK,GAKvC,GAAW,GACb,EACA,EACA,GACA,EACA,KAGK,iBAAmB,GACxB,KAAa,MAEJ,iBAAmB,IACnB,iBAAmB,SAG1B,IAAkB,EAAY,GAC9B,GAAkB,GAAY,GAGhC,EAAI,GACJ,EAAO,EAAO,GAAkB,MAKvB,gBAAkB,IAClB,gBAAkB,MAElB,gBAAkB,KAClB,gBAAkB,UAI5B,WAKZ,IAQL,GAAS,CACX,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IACC,MACK,GAAK,EAAS,EACd,EAAK,EAAO,EACZ,EAAU,EAAO,EACjB,EAAU,EAAO,EAQjB,EAAgB,EAAU,KAG5B,GAAQ,EACR,EAAQ,OAGF,GAAK,EAAS,IACd,GAAK,EAEX,EAAgB,GAAM,EAAG,MAEnB,OAAmB,GAAiB,EACpC,KAAkB,GAAW,SAE1B,GAAI,EAAG,GAAK,EAAM,GAAK,OACpB,GAAa,EAAG,EAAM,EAAM,EAAI,EAAU,EAAW,GAEzD,EAAI,IACI,GACJ,EACA,EACA,EACA,EACA,EACA,EACA,WAKJ,GACI,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,cAMT,MAEG,QAAoB,GAAiB,GAAK,EAC1C,KAAkB,EAAU,GAAK,KAOnC,GAAI,QACA,GAAa,EAAG,EAAM,EAAM,EAAI,EAAU,EAAW,GAExD,GAAK,EAAG,GAAK,EAAM,GAAK,OACjB,GACJ,EAAI,EACJ,EACA,EACA,EACA,EACA,EACA,GAGA,EAAI,IACI,GACJ,EACA,EACA,EACA,EACA,EACA,EACA,WAKJ,GACI,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,eASV,IAAI,OACN,GAAG,yBAA0B,UAAe,YAAe,UAAe,MAW5E,GAAmB,CACrB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IACC,IACG,EAAO,EAAS,EAAO,EAAQ,MAGlB,CAAC,EACV,GAAc,EAAU,SAAW,EAAG,MAEhC,CAAE,oBAAkB,aAAa,EAAU,KACvC,GAAK,CACX,iBAAkB,CAAC,GAAS,GAAS,KAAY,IAC5B,GAAS,GAAS,KAEvC,SAAU,CAAC,GAAQ,KAAW,GAAS,GAAQ,UAIjD,GAAS,EACT,GAAO,IACJ,IACF,IACE,IACF,QAEL,CAAE,mBAAkB,YAAa,EAAU,EAAa,EAAI,MAI9D,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,QAEE,CACF,mBACA,gBACA,gBACA,mBACA,mBACA,mBACA,mBACA,mBACA,mBACA,mBACA,kBACA,mBACA,EAGA,EAAS,GAAiB,EAAS,MAG/B,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GAKJ,IAAqB,KACJ,EAAkB,EAAkB,GAErD,IAAqB,KACJ,EAAkB,EAAkB,GAIrD,EAAkB,GAAQ,EAAkB,MAGxC,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IAKN,GAAiB,CAAC,EAAc,IAAiB,IAC/C,MAAO,IAAQ,cACT,IAAI,WACN,GAAG,OAAQ,YAAe,MAAO,yBAGrC,CAAC,OAAO,cAAc,QAChB,IAAI,YACN,GAAG,OAAQ,WAAc,8BAG7B,EAAM,OACA,IAAI,YACN,GAAG,OAAQ,WAAc,4BAK/B,GAAmB,CAAC,EAAc,IAAiB,MAC/C,GAAO,MAAO,MAChB,IAAS,gBACH,IAAI,WAAU,GAAG,OAAQ,YAAe,wBAQtD,OAAe,CACX,EACA,EACA,EACA,IACO,IACQ,UAAW,MACX,UAAW,MACT,WAAY,MACZ,mBAAoB,QAG/B,GAAW,GAAkB,EAAG,EAAS,EAAG,EAAS,MAEvD,IAAa,KACI,EAAU,EAAG,GAK9B,IAAY,GAAY,IAAY,EAAU,MAGxC,GAAS,EACT,EAAS,EAGT,EAAW,GACb,EACA,EAAU,EACV,EACA,EAAU,EACV,GAKE,EAAO,EAAU,EACjB,EAAO,EAAU,EAKjB,EAAY,EAAW,EACzB,IAAY,GAAa,IAAY,MACrB,EA6BZ,EACA,EACA,EACA,EA/Be,GACD,CAAC,CAAE,mBAAkB,aAIrB,CAAC,GAED,CAAC,GAGF,CACb,iBAAkB,EAClB,iBAAkB,EAClB,cAAe,EACf,gBAAiB,EACjB,iBAAkB,EAClB,iBAAkB,EAClB,cAAe,EACf,gBAAiB,EACjB,iBAAkB,EAClB,iBAAkB,EAClB,iBAAkB,EAClB,iBAAkB,IAkBtB,IAAa,KACI,EAAU,EAAM,KC13B7C,KAAM,IAAuB,CACzB,EACA,IACS,EAAK,QAAQ,OAAQ,AAAC,GAAU,EAAuB,IAE9D,GAAgB,CAClB,EACA,EACA,EACA,EACA,EACA,IAEA,EAAK,SAAW,EACV,EACI,EACI,IACA,GAAqB,EAAM,IAEnC,IAAc,IACd,EAAM,GACN,GAAiB,EAAgC,SAAW,EAC5D,EAAM,EAAY,IAAM,GACxB,GAEJ,GAAkB,CACpB,EACA,EACA,CACI,SACA,aACA,+BACA,qCAGJ,GACI,EACA,EACA,EACA,EACA,EACA,GAGF,GAAkB,CACpB,EACA,EACA,CACI,SACA,aACA,+BACA,qCAGJ,GACI,EACA,EACA,EACA,EACA,EACA,GAGF,GAAkB,CACpB,EACA,EACA,CACI,cACA,kBACA,+BACA,qCAGJ,GACI,EACA,EACA,EACA,EACA,EACA,GAIF,GAAkB,CACpB,EACA,EACA,EACA,EACA,CAAE,gBAEF,EACI,OAAO,EAAS,KAAK,EAAO,MAAW,EAAS,KAAK,EAAO,QAOvD,GAA2B,CACpC,EACA,IACS,MACH,GAAU,EAAM,OAChB,EAAgB,EAAQ,aACxB,EAAiB,EAAgB,KAGnC,GAAU,EACV,EAAwB,GACxB,EAA0B,EAC1B,EAAI,OACD,IAAM,GAAS,MACZ,GAAS,OACR,IAAM,GAAW,EAAM,GAAG,KAAO,MAC/B,KAGL,IAAW,KACP,IAAW,EAEP,EAAI,OACO,EAAI,IACS,YAErB,IAAM,EAAS,MAEhB,GAAI,EAAI,EACV,EAAI,OACO,EAAI,IACS,QAEzB,MAEG,GAAI,EAAI,EACV,EAAI,OACO,EAAI,KACY,QAKhC,IAAM,GAAW,EAAM,GAAG,KAAO,MAC/B,OAIP,GAAW,IAA4B,GAAK,EAC9C,IAA4B,KACjB,EAA0B,EAC9B,OACI,QAET,GAAQ,EAAU,EAElB,EAAuB,MAEzB,GAAa,EACb,KACM,KAAK,OAIX,GAAS,EACT,EAAS,EACT,EAAO,EACP,EAAO,OAEL,GAAiB,AAAC,GAAuB,MACrC,GAAI,EAAM,SACV,KAAK,GAAgB,EAAM,IAAM,GAAK,IAAM,EAAO,OACjD,KACA,GAGN,EAAiB,AAAC,GAAuB,MACrC,GAAI,EAAM,SACV,KAAK,GAAgB,EAAM,IAAM,GAAK,IAAM,EAAO,OACjD,GAGN,EAAiB,AAAC,GAAuB,MACrC,GAAI,EAAM,SACV,KAAK,GAAgB,EAAM,IAAM,GAAK,IAAM,EAAO,OACjD,SAIR,EACG,IAAM,GAAS,IACd,GAAS,OACN,IAAM,GAAW,EAAM,GAAG,KAAO,MAC/B,KAGL,IAAW,KACP,IAAW,EAAG,CAEV,EAAI,MACK,EAAI,IACJ,IACA,IACF,IACA,UAGF,GAAU,EAAQ,IAAY,EAAG,GAAW,IAClC,EAAM,GAAS,YAE3B,IAAM,EAAS,MAEhB,GACF,EAAI,EAAS,EAAgB,EAAS,EAAgB,SAEjD,GAAU,EAAQ,IAAY,EAAM,GAAW,IACrC,EAAM,GAAS,QAE/B,MAEG,GAAU,EAAI,KAEhB,EAAU,EAAgB,MACpB,GAAO,EAAS,SAEb,GAAU,EAAQ,IAAY,EAAM,GAAW,IACrC,EAAM,GAAS,MAG5B,GAAc,GAChB,EACA,EACA,EACA,EACA,KAES,EAAM,SACb,KAAK,SAEL,GAAQ,EAAU,IACf,EAAO,IACP,EAAO,IACT,IACA,SAGC,GAAU,EAAI,EAClB,IAAY,EACZ,GAAW,IAEI,EAAM,GAAS,gBAGzB,GAAU,EAAQ,IAAY,EAAG,GAAW,IAClC,EAAM,GAAS,SAMvC,IAAM,GAAW,EAAM,GAAG,KAAO,KACrB,EAAM,GAAG,OACnB,OAGF,IAAM,GAAW,EAAM,GAAG,KAAO,KACrB,EAAM,GAAG,OACnB,QAIT,OACM,GAAc,GAChB,EACA,EACA,EACA,EACA,IAID,EAAM,KAAK;AAAA,IAOT,GAAyB,CAClC,EACA,IAEA,EACK,IAAI,CAAC,EAAY,EAAW,IAA+B,MAClD,GAAO,EAAK,GACZ,EAAgB,IAAM,GAAK,IAAM,EAAM,OAAS,SAE9C,EAAK,QACJ,SACM,IAAgB,EAAM,EAAe,OAE3C,SACM,IAAgB,EAAM,EAAe,iBAGrC,IAAgB,EAAM,EAAe,MAGvD,KAAK;AAAA,GCjTD,GAAU,AAAC,GAA2B,EAE7C,GAAuB,EAEvB,GAAyC,CAC3C,YAAa,WACb,OAAQ,EAAM,MACd,WAAY,IACZ,YAAa,WACb,OAAQ,EAAM,IACd,WAAY,IACZ,YAAa,EAAM,QACnB,6BAA8B,GAC9B,YAAa,EAAM,IACnB,gBAAiB,IACjB,6BAA8B,GAC9B,YAAa,OACb,aAAc,GACd,gCAAiC,GACjC,OAAQ,GACR,oBAAqB,GACrB,oBAAqB,GACrB,WAAY,EAAM,QAGhB,GAAiB,AAAC,GACpB,GAAe,MAAO,IAAgB,WAChC,EACA,GAAgB,YAEpB,GAAkB,AAAC,GACrB,MAAO,IAAiB,UACxB,OAAO,cAAc,IACrB,GAAgB,EACV,EACA,GAGG,GAAuB,CAChC,EAAuB,iBAEpB,IACA,IACH,YAAa,GAAe,EAAQ,aACpC,aAAc,GAAgB,EAAQ,gBCvCpC,GAAgB,AAAC,GACnB,EAAM,SAAW,GAAK,EAAM,GAAG,SAAW,EAOxC,GAAe,AAAC,GAAqC,IACnD,GAAI,EACJ,EAAI,WAEF,QAAQ,AAAC,GAAS,QACZ,EAAK,QACJ,MACI,YAGJ,MACI,WAKV,CAAE,IAAG,MAGV,GAAkB,CACpB,CACI,cACA,SACA,aACA,cACA,SACA,aACA,sBACA,uBAEJ,IACS,IACL,QACO,MAGP,GAAQ,GACR,EAAQ,MAER,EAAqB,MACf,GAAS,OAAO,EAAa,GAC7B,EAAS,OAAO,EAAa,GAG7B,EAAyB,EAAY,OAAS,EAAY,OAC1D,EAAqB,IAAI,OAC3B,KAAK,IAAI,EAAG,IAEV,EAAqB,IAAI,OAC3B,KAAK,IAAI,EAAG,CAAC,IAIX,EAAoB,EAAO,OAAS,EAAO,OAC3C,EAAgB,IAAI,OAAO,KAAK,IAAI,EAAG,IACvC,EAAgB,IAAI,OAAO,KAAK,IAAI,EAAG,CAAC,MAG1C,EACA,KACA,EACA,IACA,EACA,IAEA,EACA,KACA,EACA,IACA,EACA,QAIJ,GAAO,EAAa,IAAM,EAAc,GACxC;AAAA,EACA,EAAO,EAAa,IAAM,EAAc,GACxC;AAAA;AAAA,GAIK,GAAiB,CAC1B,EACA,IAEA,GAAgB,EAAS,GAAa,OAC7B,OACH,GAAuB,EAAO,GAC9B,GAAyB,EAAO,IAG7B,GAAmB,CAC5B,EACA,EACA,IAEA,GACI,GACI,GAAc,GAAU,GAAK,EAC7B,GAAc,GAAU,GAAK,GAEjC,GAAqB,IAMhB,GAAoB,CAC7B,EACA,EACA,EACA,EACA,IACS,IACL,GAAc,IAAkB,GAAc,OAC9B,KACA,IAEhB,GAAc,IAAkB,GAAc,OAC9B,KACA,IAIhB,EAAc,SAAW,EAAc,QACvC,EAAc,SAAW,EAAc,aAGhC,IAAiB,EAAe,EAAe,QAGpD,GAAQ,GAAa,EAAe,MAGtC,GAAS,EACT,EAAS,WACP,QAAQ,AAAC,GAAe,QAClB,EAAK,QACJ,KACI,GAAK,EAAc,MACd,YAGT,KACI,GAAK,EAAc,MACd,kBAIL,GAAK,EAAc,MACd,KACA,KAIf,GAAe,EAAO,GAAqB,KAIzC,GAAe,CACxB,EACA,IACc,MACR,GAAU,EAAO,OACjB,EAAU,EAAO,OAEjB,EAAW,CAAC,EAAgB,IAC9B,EAAO,KAAY,EAAO,GAExB,EAAqB,MACvB,GAAS,EACT,EAAS,SAkBR,EAAS,EAAS,EAhBE,CACrB,EACA,EACA,IACC,MACM,IAAW,EAAS,GAAU,IAC3B,KAAK,GAAI,GAAK,EAAa,EAAO,UAErC,IAAW,EAAS,GAAU,IAC3B,KAAK,GAAI,GAAK,EAAa,EAAO,UAErC,IAAY,EAAG,GAAW,EAAG,GAAU,EAAG,GAAU,IACjD,KAAK,GAAI,GAAK,EAAY,EAAO,OAOxC,IAAW,EAAS,GAAU,IAC3B,KAAK,GAAI,GAAK,EAAa,EAAO,UAErC,IAAW,EAAS,GAAU,IAC3B,KAAK,GAAI,GAAK,EAAa,EAAO,WAGrC,ICrNL,GAAc,CAAC,EAAW,IAA2B,MACjD,GAAW,CAAC,EAAgB,IAC9B,EAAE,KAAY,EAAE,MAEhB,GAAS,EACT,EAAS,OACP,GAAqB,GAErB,EAAmB,CACrB,EACA,EACA,IACC,CACG,IAAW,KACL,KAAK,GAAI,GAAK,EAAa,EAAE,MAAM,EAAQ,KAEjD,IAAW,KACL,KAAK,GAAI,GAAK,EAAa,EAAE,MAAM,EAAQ,OAG5C,EAAU,IACV,EAAU,IACb,KAAK,GAAI,GAAK,EAAY,EAAE,MAAM,EAAS,gBAGvC,EAAE,OAAQ,EAAE,OAAQ,EAAU,GAGxC,IAAW,EAAE,UACP,KAAK,GAAI,GAAK,EAAa,EAAE,MAAM,KAEzC,IAAW,EAAE,UACP,KAAK,GAAI,GAAK,EAAa,EAAE,MAAM,KAGtC,GC/BL,GAA2B,CAC7B,EACA,EACA,IAEA,EAAM,OACF,CAAC,EAAiB,IACd,KACM,KAAO,EACP,EAAK,GACL,EAAK,KAAO,GAAM,EAAK,GAAG,SAAW,EACrC,EAAY,EAAK,IACjB,IACV,IAIR,QAAmB,CAMf,YAAY,EAAY,EAA+B,MAC9C,GAAK,OACL,KAAO,QACP,MAAQ,QACR,YAAc,EAGf,cAAc,EAAyB,MACtC,SAAS,GAAI,GAAK,KAAK,GAAI,IAG5B,UAAiB,MAOhB,MAAM,KACP,KAAK,KAAK,SAAW,EACf,GAAI,GACA,KAAK,GACL,GACI,KAAK,GACL,KAAK,KACL,KAAK,cAGb,KAAK,KAAK,GAAG,KAAO,KAAK,GACzB,KAAK,KAAK,GACV,GAAI,GAAK,KAAK,GAAI,KAAK,KAAK,GAAG,UAEpC,KAAK,OAAS,EAGvB,aAAc,OACH,MAAK,KAAK,SAAW,EAIhC,SAAS,EAAkB,MAClB,KAAK,KAAK,GAInB,MAAM,EAAkB,MACd,GAAS,EAAK,MAEhB,EAAO,SAAS;AAAA,GAAO,MACjB,GAAa,EAAO,MAAM;AAAA,GAC1B,EAAQ,EAAW,OAAS,IACvB,QAAQ,CAAC,EAAW,IAAM,CAC7B,EAAI,QAGC,cAAc,QACd,YACE,EAAU,SAAW,QAIvB,cAAc,eAKtB,SAAS,GAKtB,YAAY,EAA0B,CAC7B,KAAK,oBACD,aAGH,KAAK,GAAG,KAAK,YACd,MAAM,OAAS,GAK5B,QAAmB,CAKf,YAAY,EAA4B,EAA4B,MAC3D,aAAe,OACf,aAAe,OACf,MAAQ,GAGT,mBAAmB,EAAkB,MACpC,MAAM,KAAK,GAGZ,oBAAoB,EAAkB,MACpC,GAAc,EAAK,GAAG,SAAW,EAGnC,EAAC,GAAe,KAAK,aAAa,qBAC7B,aAAa,SAAS,GAE3B,EAAC,GAAe,KAAK,aAAa,qBAC7B,aAAa,SAAS,GAI3B,kBAAyB,MACxB,aAAa,YAAY,KAAK,YAC9B,aAAa,YAAY,KAAK,OAIvC,MAAM,EAAkB,MACd,GAAK,EAAK,GACV,EAAS,EAAK,MAEhB,EAAO,SAAS;AAAA,GAAO,MACjB,GAAa,EAAO,MAAM;AAAA,GAC1B,EAAQ,EAAW,OAAS,IACvB,QAAQ,CAAC,EAAW,IAAM,IAC7B,IAAM,EAAG,MACH,GAAU,GAAI,GAAK,EAAI,GAEzB,KAAK,aAAa,eAClB,KAAK,aAAa,oBAIb,wBACA,mBAAmB,UAInB,oBAAoB,QACpB,wBAEF,GAAI,OAEN,mBAAmB,GAAI,GAAK,EAAI,IAC9B,EAAU,SAAW,QAIvB,oBAAoB,GAAI,GAAK,EAAI,gBAOzC,oBAAoB,GAKjC,UAAwB,aACf,mBACE,KAAK,OAcpB,KAAM,IAAkB,CACpB,EACA,IACc,MACR,GAAe,GAAI,IAAa,EAAa,GAC7C,EAAe,GAAI,IAAa,EAAa,GAC7C,EAAe,GAAI,IAAa,EAAc,YAE9C,QAAQ,AAAC,GAAS,QACZ,EAAK,QACJ,KACY,MAAM,aAGlB,KACY,MAAM,mBAIN,MAAM,MAIxB,EAAa,YC5NlB,GAAgB,CAAC,EAAoB,IAAkC,IACrE,EAAa,MAEP,GAAQ,EAAM,OAAS,QACtB,GAAM,KACT,CAAC,EAAM,IACH,EAAK,KAAO,QAAqB,GAAS,EAAK,KAAO;AAAA,UAI3D,GAAM,KAAK,AAAC,GAAS,EAAK,KAAO,IAK/B,GAAqB,CAC9B,EACA,EACA,IACS,IACL,IAAM,GAAK,EAAE,SAAW,GAAK,EAAE,SAAW,EAAG,MACvC,GAAc,EAAE,SAAS;AAAA,IAAS,EAAE,SAAS;AAAA,GAG7C,EAAQ,GACV,EAAc,EAAI;AAAA,EAAO,EACzB,EAAc,EAAI;AAAA,EAAO,EACzB,OAGA,GAAc,EAAO,GAAc,MAC7B,GAAoB,GAAqB,GACzC,EAAQ,GAAgB,EAAO,EAAkB,mBAChD,IAAe,EAAO,UAK9B,IAAiB,EAAE,MAAM;AAAA,GAAO,EAAE,MAAM;AAAA,GAAO,IAK7C,GAAiB,CAC1B,EACA,EACA,IACc,MACR,GAAQ,GAAY,EAAG,SAEzB,OACgB,GAGb,GCzCL,GAAmB,CAAC,EAAiB,IAA0B,MAC3D,CAAE,eAAgB,GAAqB,SACtC,GAAY,IAGjB,mBACFL,iBACAE,cACAC,aACAC,sBACAC,IACAC,GAEEC,GAAU,CACZF,GACAF,GACAD,GACAE,GACAJ,IAEE,GAAiB,CACnB,QAASO,IAEP,GAA0B,CAC5B,WAAY,GACZ,SAAU,GACV,QAASA,gBAMQ,EAAQ,EAAQ,EAAsC,IACnE,OAAO,GAAG,EAAG,SACN,IAAiB,GAAiB,QAGvC,GAAQ,EAAQ,MAClB,GAAe,EACf,EAAiB,MACjB,IAAU,UAAY,MAAO,GAAE,iBAAoB,WAAY,IAC3D,EAAE,WAAa,OAAO,IAAI,2BAI1B,MAAO,GAAE,iBAAoB,iBAEtB,QAEI,EAAE,oBAGA,IAAiB,YAGlC,IAAiB,EAAQ,SAErB,uDACa,EAAM,MAAM,mBACb,EAAM,IAAI,EAAQ,UAIlC,QACO,aAGH,OACC,eACM,IAAiB,EAAE,MAAM;AAAA,GAAO,EAAE,MAAM;AAAA,GAAO,OACrD,cACA,eACM,IAAiB,EAAG,EAAG,OAC7B,YACM,IAAe,GAAQ,GAAI,GAAQ,GAAI,OAC7C,YACM,IAAe,GAAQ,GAAI,GAAQ,GAAI,iBAEvC,IAAe,EAAG,EAAG,IAIxC,YACI,EACA,EACA,EACF,MACQ,GAAUC,GAAa,EAAG,IAC1B,EAAUA,GAAa,EAAG,UACzB,KAAY,EACb,GAAiB,GAAiB,GAClC,GAAiB,EAAQ,MAAM;AAAA,GAAO,EAAQ,MAAM;AAAA,GAAO,GAGrE,YAAiB,EAA4B,OAClC,IAAI,KAAI,MAAM,KAAK,EAAI,WAAW,QAG7C,YAAiB,EAAmB,OACzB,IAAI,KAAI,MAAM,KAAK,EAAI,UAAU,QAG5C,YACI,EACA,EACA,EACF,IACM,GACA,EAAY,MAEZ,MACM,GAAgB,GAAiB,GAAgB,KAC1C,GAAqB,EAAG,EAAG,EAAe,WAE3C,QAGV,GAAgB,GAAiB,GAAiB,MAGpD,IAAe,QAAa,IAAe,EAAe,MACpD,GAAgB,GAClB,GACA,KAES,GAAqB,EAAG,EAAG,EAAe,GAEnD,IAAe,GAAiB,CAAC,MAE7B,GAAiB,GAAiB,GAClC;AAAA;AAAA,EACA,SAIL,GAGX,YACI,EACA,EACmB,MACb,CAAE,eAAgB,GAAqB,SAEtC,UACA,GADA,CAEH,gBAIR,YACI,EACA,EACA,EACA,EACM,MACA,GAA0B,SAAK,GAAL,CAAoB,OAAQ,IACtD,EAAWA,GAAa,EAAG,GAC3B,EAAWA,GAAa,EAAG,MAE7B,IAAa,QACN,IAAiB,GAAiB,GACtC,MACG,GAAWA,GAAa,EAAG,GAC3B,EAAWA,GAAa,EAAG,SAE1B,IACH,EAAS,MAAM;AAAA,GACf,EAAS,MAAM;AAAA,GACf,EAAS,MAAM;AAAA,GACf,EAAS,MAAM;AAAA,GACf,IC7LZ,KAAM,IAAe,CAAC,MAAO,QAAS,kBASL,CAI7B,YAAY,EAAa,SAChB,OAAS,OACT,KAAO,EAAQ,GAChB,CAAC,GAAa,SAAS,KAAK,WACtB,IAAI,OAAM,QAAQ,KAAK,6CAI9B,eAAc,EAAe,EAAwB,MAClD,GAAW,EAAQ,GACnB,EAAW,EAAQ,SAClB,KAAa,GAAY,GAAa,SAAS,GAG1D,QAAQ,EAAsC,IACtC,KAAK,OAAS,SAAU,MAClB,GAAc,OAAO,0BAA0B,KAAK,SAEtD,GAAG,OAAO,KAAK,GACf,GAAG,OAAO,sBAAsB,IAI/B,OAAO,AAAC,GAAQ,EAAY,GAAK,YACjC,QAAQ,AAAC,GAAQ,GACX,KAAK,OAAO,GAAM,EAAK,KAAK,oBAGlC,OAAO,QAAQ,GAI5B,IAAI,EAAe,OACX,MAAK,OAAS,MACP,KAAK,OAAO,IAAI,GAEpB,KAAK,OAAO,GAGvB,IAAI,EAAU,EAAkB,CACxB,KAAK,OAAS,WACT,OAAO,IAAI,EAAK,QAEhB,OAAO,GAAO,GCxD/B,KAAM,IAAgC,CAClC,MACA,KACA,aACA,aACA,WACA,WACA,UACA,IACA,IACA,OACA,YACA,YACA,WACA,mBAGJ,AAAI,MAAO,SAAW,gBACJ,KAAK,QAGvB,KAAM,IAAkB,AAAC,GACrB,GAAc,SAAS,EAAO,aAE5B,GAAQ,AAAC,GACX,EAAM,cAAgB,gBAGtB,EACA,EAA4B,GAAI,SAC/B,OACG,OAAO,IAAU,UAAY,IAAU,KAChC,EACA,EAAO,IAAI,GACX,EAAO,IAAI,GACX,MAAM,QAAQ,GACd,GAAoB,EAAO,GAC3B,GAAM,GACN,GAAkB,EAAO,GACzB,GAAgB,GAChB,EACA,GAAQ,WAAW,KAAK,GACvB,EAA6B,UAAU,IAExC,GAAqB,EAAO,GAI3C,YAAiC,EAAW,EAAkC,MACpE,GAAY,OAAO,OAAO,OAAO,eAAe,IAChD,EAEF,OAAO,0BAA0B,KAE9B,IAAI,EAAQ,QAEb,GAAiB,CACnB,GAAG,OAAO,KAAK,GACf,GAAG,OAAO,sBAAsB,IAClC,OAGE,CAAC,EAAqD,IAAgB,MAC5D,GAAa,EAAY,GAAK,oBAErB,GAAO,CAClB,aAAc,GACd,aACA,MAAO,GAGF,EAA4C,GAC7C,GAEJ,SAAU,IAEP,GAEX,UAIG,QAAO,iBAAiB,EAAW,GAG9C,YACI,EACA,EACC,MACK,GAAW,WAAY,eAAe,IAAO,YAC/C,EAAM,QAEJ,EAAS,EAAM,SAEd,IAAI,EAAO,UAET,GAAI,EAAG,EAAI,EAAQ,MACf,GAAK,GAA0B,EAAM,GAAI,SAG/C,GAGX,YACI,EACA,EACC,MACK,GAAS,GAAI,cAEZ,IAAI,EAAK,KAEZ,QAAQ,CAAC,EAAO,IAAQ,GACjB,IAAI,EAAK,GAA0B,EAAO,MAG9C,EChGX,KAAM,mBACFR,GACA,iBACA,cACA,aACA,uBACAM,GAEE,GAAU,CACZ,GACA,GACA,GACA,GACAN,IAkBS,EAAiB,EAAM,MACvB,EAAiB,EAAM,IACvB,GAAiB,EAAM,QACvB,GAAc,EAAM,KACpB,GAAY,EAAM,IAEzB,GAAmB,KACnB,GAAe,OAEf,GAAU,CACZ,OACA,MACA,MACA,QACA,OACA,OACA,MACA,QACA,QACA,OACA,MACA,SACA,SACA,YAGS,GAA2B,EAAM,IAC1C,qJAGS,EAAY,CAAC,EAAiB,EAAmB,KAAe,MACnE,GAAa,OACf,MAEA,GACSQ,GAAa,EAAQ,CAC1B,WACA,IAAK,GACL,QAAS,aAGJA,GAAa,EAAQ,CAC1B,WAAY,GACZ,WACA,IAAK,GACL,QAAS,WAIV,GAAO,QAAU,GAAc,EAAW,EAC3C,EAAU,EAAQ,KAAK,MAAM,EAAW,IACxC,GAGG,GAA8B,AAAC,GACxC,EAAK,QAAQ,SAAU,EAAM,QAAQ,OAInC,GAAwB,AAAC,GAC3B,EAAK,QAAQ,SAAU,AAAC,GAAW,GAAa,OAAO,EAAO,SAErD,EAAgB,AAAC,GAC1B,EAAe,GAAsB,EAAU,KACtC,EAAgB,AAAC,GAC1B,EAAe,GAAsB,EAAU,KAEtC,EAAgB,CACzB,EACA,EACA,IACS,MACH,GAAO,EAAQ,GACf,EACF,IAAS,QAAU,IAAS,YACtB,GAAG,gBAAmB;AAAA,EACtB,GACJ,EAAW,GAAG,gBAAmB,EAAM,WACtC,GAAU,GAGR,GAAmB,CAC5B,EACA,EACA,IACO,IACH,MAAO,IAAa,YAAa,MAE3B,MAA2B,GAAK,UAAY,OAC5C,IAAI,OACN,EACI,EAAY,EAAe,OAAW,GAAI,GAG1C,kDACA,EAAc,WAAY,EAAU,OASvC,GAAuB,CAChC,EACA,EACA,IACO,IACH,MAAO,IAAW,UAAY,MAAO,IAAW,SAAU,MAEpD,MAA2B,GAAK,UAAY,OAC5C,IAAI,OACN,EACI,EAAY,EAAe,OAAW,OAAW,GACjD,GAAG,EACC,+CAEJ,EAAc,WAAY,EAAQ,OASrC,GAAyB,CAClC,EACA,EACA,IACO,IACH,MAAO,IAAa,UAAY,MAAO,IAAa,SAAU,MAExD,MAA2B,GAAK,UAAY,OAC5C,IAAI,OACN,EACI,EAAY,EAAe,OAAW,OAAW,GACjD,GAAG,EACC,+CAEJ,EAAc,WAAY,EAAU,OASvC,GAAgB,CACzB,EACA,EACA,EACA,IACO,IACc,EAAQ,EAAa,MACnB,EAAU,EAAa,IAGrC,GAAqC,CAC9C,EACA,EACA,IACO,IAEH,MAAO,IAAa,UACpB,CAAC,OAAO,cAAc,IACtB,EAAW,EACb,MAEQ,MAA2B,GAAK,UAAY,OAC5C,IAAI,OACN,EACI,EAAY,EAAe,OAAW,OAAW,GACjD,GAAG,EACC,mDAEJ,EAAc,WAAY,EAAU,OAW9C,GAAgC,CAClC,EACA,EACA,IAEA,EAAM,OACF,CAAC,EAAiB,IACd,KACM,KAAO,EACP,EAAK,GACL,EAAK,KAAO,EACZ,GACA,EACA,GAAe,EAAK,IACpB,EAAK,IACf,IAGF,GAAiB,CAAC,EAAmB,IAA+B,MAChE,GAAe,EAAQ,GACvB,EAAe,EAAQ,SAEzB,KAAiB,EACV,GAGP,GAAY,GAKR,MAAO,IAAa,UACpB,MAAO,IAAa,UACpB,EAAS,SAAW,GACpB,EAAS,SAAW,OACF,KAAK,IAAa,GAAiB,KAAK,IAK9D,MAAiB,QACjB,IAAiB,YACjB,IAAiB,UAKjB,YAAoB,QAAS,YAAoB,QAKjD,IAAiB,UACjB,MAAQ,GAAiB,iBAAoB,YAM7C,IAAiB,UACjB,MAAQ,GAAiB,iBAAoB,aAQ/C,GAAyB,IAElB,GAAuB,CAChC,EACA,EACA,EACA,EACA,IACS,IAEL,MAAO,IAAa,UACpB,MAAO,IAAa,UACpB,EAAS,SAAW,GACpB,EAAS,SAAW,GACpB,EAAS,QAAU,IACnB,EAAS,QAAU,IACnB,IAAa,EACf,IACM,EAAS,SAAS;AAAA,IAAS,EAAS,SAAS;AAAA,SACtC,IAAmB,EAAU,EAAU,CAC1C,YAAa,EACb,YAAa,EACb,6BAA8B,EAAM,SACpC,6BAA8B,EAAM,SACpC,gCAAiC,SACjC,SACA,oBAAqB,UAIvB,GAAQ,GAAe,EAAU,EAAU,IAC3C,EAAgB,EAAM,KAAK,AAAC,GAAS,EAAK,KAAO,GAEjD,EAAa,GAAgB,EAAe,GAC5C,EACF,EAAW,GACX,EACI,GAA8B,EAAO,EAAa,IAEpD,EACF,EAAW,GACX,EACI,GAA8B,EAAO,EAAa,UAGnD,GAAe;AAAA,EAAO,KAG7B,GAAe,EAAU,GAAW,MAC9B,CAAE,mBAAkB,oBACtB,GACI,GAA0B,GAC1B,GAA0B,GAC1B,GACA,IAEF,EAAaC,GAAY,EAAkB,EAAkB,CAC/D,YAAa,EACb,YAAa,EACb,SACA,oBAAqB,QAIrB,MAAO,IAAe,UACtB,EAAW,SAAS,KAAO,IAC3B,EAAW,SAAS,KAAO,SAEpB,QAIT,GAAa,GAAgB,EAAe,GAC5C,EAAe,EAAW,GAAiB,EAAc,GACzD,EACF,EAAW,MACA,KAAc,EAAU,GAC7B,gCACA,EAAc,UAEjB,GAAe;AAAA,EAAO,GAM3B,GAAkB,CAAC,EAAiB,IAClC,QAAO,IAAW,UAAY,MAAO,IAAa,UAGlD,MAAO,IAAW,UAAY,MAAO,IAAa,UAGlD,MAAO,IAAW,WAAa,MAAO,IAAa,WAM3D,YACI,EACA,EACA,EACA,EACF,IACM,CAAC,GAAY,cAAc,EAAkB,SACtC,CAAE,mBAAkB,uBAI3B,EAAe,SAAS,IACxB,EAAe,SAAS,SAEjB,CAAE,mBAAkB,sBAGhB,KAAK,KACL,KAAK,QAEd,GAAsB,GAAI,IAAY,GACtC,EAAsB,GAAI,IAAY,YAExB,QAAQ,CAAC,EAAwB,IAAiB,MAC5D,GAAgB,EAAoB,IAAI,MAC1C,GAAoB,GAChB,EAAc,gBAAgB,MACV,IAAI,EAAK,WAE1B,GAAoB,GACvB,EAAc,gBAAgB,MACV,IAAI,EAAK,WAE1B,GAAY,cAAc,EAAe,GAAgB,MAC1D,GAAW,GACb,EACA,EACA,EACA,KAEgB,IAAI,EAAK,EAAS,oBAClB,IAAI,EAAK,EAAS,qBAIvC,CACH,iBAAkB,EAAoB,OACtC,iBAAkB,EAAoB,QAQ9C,YAA6B,EAAsC,OAExD,AADM,GAAQ,KACL,UAAY,MAAO,GAAK,iBAAoB,gBAGnD,IAAO,CAChB,EACA,EACA,IACiB,GAAgB,EAAG,GAAKA,GAAY,EAAG,EAAG,GAAW,KAE7D,GAAY,CAAC,EAAc,QAC3B,IAAU,GAAS,IAAM,OAAkB,EAAI,GAAK,KASpD,GAAkB,IAAI,IAAuC,MAChE,GAAY,EAAQ,OACtB,CAAC,EAAK,IAAY,EAAO,OAAS,EAAM,EAAO,OAAS,EACxD,SAEG,AAAC,IACJ,GAAG,MAAW,IAAI,OAAO,EAAY,EAAO,WAGvC,EAAsB,CAC/B,EACA,EACA,IAEA,GAAG;AAAA;AAAA,EAAW,EAAM,KAAK,qBAAqB,IAC1C,MAAO,IAAa,SAAW;AAAA;AAAA,EAAS,EAAW,KAM9C,EAAc,CACvB,EACA,EAAmB,WACnB,EAAmB,WACnB,EAA8B,KACrB,MACH,CACF,UAAU,GACV,gBAAgB,EAChB,qBAAqB,GACrB,QAAQ,GACR,UAAU,GACV,gBAAgB,EAChB,iBAAiB,GACjB,sBAAsB,GACtB,KACA,GAAO,GACP,EAAY,eAEZ,CAAC,GAAsB,IAAa,QAC5B,GAAU,EAAY,KAAO,EAAc,KACvC,KAGZ,IAAY,QACJ,GAAU,EAAY,KAAO,IACzB,IAGZ,OACQ,GAAU,EAAY,KAAO,QACzB,IAGZ,EAAY,SAAS,QAGR,MAGL,GAAU,EAAY,KAAO,IACzB,IAGZ,IAAa,MACA,SAEL,GAAU,EAAY,KAAO,EAAc,GAC/C,OACQ,GAAU,MAAQ,EAAoB,MAEtC,KAGZ,IAAY,QACC,OAAS,GAGtB,IAAc,QACN,GAAU,IAGf,2fChiBP,EACA,EACA,EACA,EACO,UACS,GAAiB,GAC1B,GACH,EACA,EACA,GACA,GACA,EACA,EAAc,GAAS,IAI/B,KAAM,IAAmB,SAAS,UAAU,SAE5C,YAAsB,EAAU,OACrB,CAAC,CAAC,GAAO,GAAI,WAAY,EAAI,iBAGxC,YAAyB,EAAQ,EAAQ,IACjC,GAAc,GAAa,GAC3B,EAAc,GAAa,MAE3B,KAAe,OAIf,QACO,GAAE,gBAAgB,MAGzB,QACO,GAAE,gBAAgB,IAMjC,YACI,EACA,EACA,EACA,EACA,EACA,EACO,IACH,GAAS,GAET,EAAmB,GAAgB,EAAG,MACtC,IAAqB,aACd,UAGF,GAAI,EAAG,EAAI,EAAc,OAAQ,IAAK,IACvC,GAAqB,EAAc,GAAG,EAAG,MACzC,IAAuB,aAChB,MAIX,YAAa,QAAS,YAAa,aAC5B,GAAE,SAAW,EAAE,WAGtB,OAAO,GAAG,EAAG,SACN,MAGP,IAAM,MAAQ,IAAM,WACb,KAAM,KAEb,GAAY,OAAO,UAAU,SAAS,KAAK,MAC3C,GAAa,OAAO,UAAU,SAAS,KAAK,SACrC,UAEH,OACC,uBACA,sBACA,wBACG,OAAO,IAAM,MAAO,GAEb,GACA,MAAO,IAAM,UAAY,MAAO,IAAM,SAEtC,OAAO,GAAG,EAAG,GAGb,OAAO,GAAG,EAAE,UAAW,EAAE,eAEnC,sBAIM,CAAC,GAAK,CAAC,MAEb,wBACM,GAAE,SAAW,EAAE,QAAU,EAAE,QAAU,EAAE,SAElD,MAAO,IAAM,UAAY,MAAO,IAAM,eAC/B,MAIP,GAAU,IAAM,GAAU,SACnB,GAAE,YAAY,UAIrB,GAAS,EAAO,OACb,KAAU,IAKT,EAAO,KAAY,QACZ,GAAO,KAAY,KACnB,EAAO,KAAY,QACnB,QAIR,KAAK,KACL,KAAK,GAGR,GAAa,kBAAoB,EAAE,SAAW,EAAE,aACzC,MAIP,GAAQ,GAAK,EAAG,GAChB,EACA,EAAO,EAAM,UAGb,GAAK,EAAG,GAAQ,SAAW,QACpB,QAGJ,UACG,EAAM,KAIR,EAAO,EAAG,IACV,GAAG,EAAE,GAAM,EAAE,GAAM,EAAQ,EAAQ,EAAe,GAElD,CAAC,QACM,YAIR,QACA,MAEA,EAGX,YAAc,EAAa,EAA+C,IAClE,GAAO,UACF,KAAO,GACR,EAAO,EAAK,MACP,KAAK,SAGX,GAAK,OACP,OAAO,sBAAsB,GAAoB,OAC9C,AAAC,GAEO,OAAO,yBACH,EACA,GAEN,aAKlB,YAAuB,EAAU,EAAa,OACnC,IAAO,EAAK,IAAQ,EAAI,KAAS,OAG5C,YAAgB,EAAU,EAAa,OAC5B,QAAO,UAAU,eAAe,KAAK,EAAK,eAGjC,EAAkB,EAAgB,OAE9C,QAAO,UAAU,SAAS,MAAM,KAAW,WAAa,EAAW,IAI3E,YAAmB,EAAmB,OAE9B,KAAQ,MACR,MAAO,IAAQ,UACf,MAAO,GAAI,UAAa,UACxB,MAAO,GAAI,UAAa,UACxB,MAAO,GAAI,aAAgB,uBAIT,EAAgB,IAClC,EAAK,WACE,GAAK,UAGV,GAAU,GACX,KAAK,GACL,MAAM,sDACJ,GAAU,EAAQ,GAAK,0BAGN,EAAU,OAC3B,KAAQ,OAGnB,YAAsB,EAAa,OAC3B,QAAO,eACA,OAAO,eAAe,GAG7B,EAAI,YAAY,WAAa,EACtB,KAGJ,EAAI,YAAY,sBAGC,EAAoB,EAA2B,OAClE,GAID,OAAO,UAAU,eAAe,KAAK,EAAK,GACnC,GAGJ,GAAY,GAAa,GAAM,GAP3B,GAWf,KAAM,IAAoB,0BACpB,GAAkB,wBAClB,GAAsB,wCAEc,EAAiB,OAChD,CAAC,KAEJ,EAAW,KACX,CAAC,EAAW,iBAIoB,EAAe,OAC5C,CAAC,KAEJ,EAAS,KACT,CAAC,EAAS,KCjRlB,KAAM,IAAuB,OAAO,IAAI,0BAI3B,GAAwB,OAAO,IAAI,2BAEhD,GAAI,CAAC,OAAO,eAAe,IAAuB,MACxC,GAAsC,CACxC,eAAgB,EAChB,yBAA0B,KAC1B,sBAAuB,GACvB,iBAAkB,WAEf,eAAe,OAAQ,GAAsB,CAChD,MAAO,CACH,SAAU,OAAO,OAAO,MACxB,MAAO,UAKN,IAAW,IACnB,OAAe,IAAsB,MAE7B,GAAW,AACpB,GACO,QACA,OAAQ,OAAe,IAAsB,MAAO,IAGlD,GAAc,IAEI,OAAe,IAAsB,SAEvD,GAAc,CACvB,EACA,EACA,IACO,QACA,KAAK,GAAU,QAAQ,AAAC,GAAQ,MAC7B,GAAU,EAAS,aAClB,eAAe,EAAS,GAAuB,CAClD,MAAO,IAGP,CAAC,EAAY,gBAGe,GAG1B,CACE,YACI,EAAmB,MAChB,EACL,OACQ,EAAQ,GAGlB,gBAAgB,EAAgB,MACtB,CAAE,QAAS,EAAQ,KACrB,KAAK,oBACL,EACA,GAAG,KAAK,cAGL,MAAK,QAAU,CAAC,EAAO,EAGlC,UAAW,OACA,GAAG,KAAK,QAAU,OAAS,KAAK,IAG3C,iBAAkB,OACP,MAGX,qBAAsB,OACX,GAAG,KAAK,cAAc,KAAK,OAC7B,IAAI,QACJ,KAAK,iBAIX,eAAe,EAAQ,EAAK,CAC/B,aAAc,GACd,WAAY,GACZ,MAAO,IAAI,IACP,GAAI,GAAc,GAAO,GAAG,GAChC,SAAU,YAEP,eAAe,EAAO,IAAK,EAAK,CACnC,aAAc,GACd,WAAY,GACZ,MAAO,IAAI,IACP,GAAI,GAAc,GAAM,GAAG,GAC/B,SAAU,eAKf,OAAQ,OAAe,IAAsB,SAAU,IC3F5D,GAAsB,CAAC,EAAgB,IAErC,CAAC,GAAU,MAAO,IAAW,UAAY,IAAW,OAAO,UAGpD,GAIP,OAAO,UAAU,eAAe,KAAK,EAAQ,IAC7C,GAAoB,OAAO,eAAe,GAAS,GAI9C,GAAU,CACnB,EACA,IACU,IACL,MAAM,QAAQ,OACC,EAAwB,MAAM,MAG9C,EAAa,OAAQ,MACf,GAAW,EAAa,SAAW,EACnC,EAAO,EAAa,GACpB,EAAY,EAAO,MAErB,CAAC,MAA2B,WAIrB,CACH,WAAY,GACZ,oBAAqB,EACrB,cAAe,SAIjB,GAAS,GAAQ,EAAW,EAAa,MAAM,UAEjD,GAAO,sBAAwB,SACxB,oBAAsB,KAG1B,cAAc,QAAQ,GAEzB,MAIO,WACH,IAAc,QACb,CAAC,GAAY,IAAW,IAAQ,GAEhC,EAAO,cACD,cAAc,SAItB,QAGJ,CACH,oBAAqB,KACrB,cAAe,GACf,MAAO,IAOF,GAAkB,CAC3B,EACA,EACA,EAA2C,GAAI,WACzC,IAEF,MAAM,QAAQ,OACV,MAAM,QAAQ,IAAW,EAAO,SAAW,EAAO,aAE3C,GAAO,IAAI,CAAC,EAAU,IACzB,GAAgB,EAAO,GAAI,YAG5B,YAAkB,YAClB,MACA,GAAS,IAAW,GAAS,GAAS,IACzC,EAAO,EAAQ,EAAQ,CAAC,EAAkB,WAEnC,QAGL,GAAe,QACN,IAAI,EAAQ,UAEpB,KAAK,GACP,OAAO,AAAC,GAAQ,GAAoB,EAAQ,IAC5C,QAAQ,AAAC,GAAQ,GACN,GAAO,EAAe,IAAI,EAAO,IACnC,EAAe,IAAI,EAAO,IAC1B,GAAgB,EAAO,GAAM,EAAO,GAAM,KAGpD,OAAO,KAAK,GAAS,OAAS,QACvB,UAGR,IAGL,GAAiB,OAAO,SAExB,GAAc,AAAC,GACjB,CAAC,KAAY,MAAQ,EAAO,KAGnB,EAAmB,CAC5B,EACA,EAEA,EAAqB,GACrB,EAAqB,KACC,IAElB,MAAO,IAAM,UACb,MAAO,IAAM,UACb,MAAM,QAAQ,IACd,MAAM,QAAQ,IACd,CAAC,GAAY,IACb,CAAC,GAAY,aAIb,EAAE,cAAgB,EAAE,kBACb,MAEP,GAAS,EAAO,YACb,QAKC,EAAO,KAAY,QACZ,GAAO,KAAY,IAG3B,KAAK,KACL,KAAK,QAEN,GAA4B,CAAC,EAAQ,IACvC,EAAiB,EAAG,EAAG,CAAC,GAAG,GAAS,CAAC,GAAG,OAExC,EAAE,OAAS,OAAW,IAClB,EAAE,OAAS,EAAE,WACN,MACA,GAAI,MAAO,IAAM,GAAwB,GAAI,IAChD,GAAW,YACJ,KAAU,MACb,CAAC,EAAE,IAAI,GAAS,IACZ,GAAM,YACC,KAAU,GAIb,AAHY,EAAO,EAAQ,EAAQ,CACnC,MAEY,OACN,OAIV,IAAQ,GAAO,GACJ,mBAMhB,QACA,MACA,UACA,GAAI,MAAO,IAAM,GAA0B,GAAI,IAClD,GAAW,YACJ,KAAU,MAEb,CAAC,EAAE,IAAI,EAAO,KACd,CAAC,EAAO,EAAO,GAAI,EAAE,IAAI,EAAO,IAAK,CACjC,IAEN,IACM,GAAM,YACC,KAAU,GAAG,MACd,GAAa,EAAO,EAAO,GAAI,EAAO,GAAI,CAC5C,OAGA,GAAe,GACf,IAAe,OACA,EAAO,EAAO,GAAI,EAAO,GAAI,CACxC,KAGJ,IAAiB,OACX,OAIV,IAAQ,GAAO,GACJ,mBAMhB,QACA,MACA,QAIT,GAAY,EAAE,eAET,KAAU,GAAG,MACd,GAAQ,EAAU,UAEpB,EAAM,MACN,CAAC,EAAO,EAAQ,EAAM,MAAO,CAAC,UAEvB,SAGV,GAAU,OAAO,QAKf,QACA,MACA,IANI,IAST,GAAW,AAAC,GAAW,IAAM,MAAQ,MAAO,IAAM,SAElD,GAAmB,AAAC,GACtB,GAAS,IACT,cAAe,SACf,cAAe,SACf,cAAe,OAEN,GAAiB,CAC1B,EACA,IACsB,MAIhB,GACF,CAAC,EAA2C,GAAI,WAChD,CAAC,EAAa,IAAqC,IAC3C,EAAC,GAAiB,SAIf,QAAO,KAAK,GAAQ,MAAM,AAAC,GAAQ,IAClC,GAAiB,EAAO,IAAO,IAC3B,EAAe,IAAI,EAAO,UACnB,GAAO,EAAO,GAAM,EAAO,GAAM,CACpC,MAGO,IAAI,EAAO,GAAM,SAE9B,GACF,GAAU,MACV,GAAoB,EAAQ,IAC5B,EAAO,EAAO,GAAM,EAAO,GAAM,CAC7B,EACA,EAA0B,cAOnB,OAAO,EAAO,IACtB,WAIZ,KAA4B,EAAQ,IAIlC,GAAe,CAAC,EAAQ,IAAgC,IAC7D,KAAK,MAAQ,GAAK,MAAQ,EAAE,cAAgB,EAAE,mBAI3C,IAGE,GAAsB,CAC/B,EACA,IACsB,IAClB,cAAe,eAAgB,cAAe,0BAI5C,GAAY,GAAI,UAAS,GACzB,EAAY,GAAI,UAAS,MAG3B,EAAU,aAAe,EAAU,iBAC5B,UAIF,GAAI,EAAG,EAAI,EAAU,WAAY,OAClC,EAAU,SAAS,KAAO,EAAU,SAAS,SACtC,SAIR,IAGE,GAAsB,CAC/B,EACA,IACsB,IAClB,CAAC,MAAM,QAAQ,IAAM,CAAC,MAAM,QAAQ,eAKlC,GAAQ,OAAO,KAAK,GACpB,EAAQ,OAAO,KAAK,SAEtB,GAAO,EAAG,EAAG,CAAC,EAAkB,IAAe,KAC/C,EAAO,EAAO,IAgBT,GAAU,AAAC,GAAmC,QAC/C,OAAO,UAAU,SAAS,KAAK,QAC9B,qBACA,yBACA,8BACM,iBAEA,aAAiB,SC/W9B,GAAQ,OAAO,OAAO,SACrB,IADqB,CAExB,mBACA,6BAOJ,CAGI,YAAsB,EAAqB,EAAU,GAAO,4CAFjD,OAAO,IAAI,0BAIZ,mBAA2B,OAC1B,UACA,MADA,CAEH,SACA,MAAO,KAAK,QACZ,YAUZ,gBAAkB,GAAuB,CACrC,YAAY,EAAiB,IACrB,MAAO,IAAW,iBACZ,IAAI,WACN,mHAIF,GAGV,gBAAgB,EAAgB,OACxB,MAAK,QAAU,OACR,MAAO,IAAS,UAAY,YAAiB,QAGpD,KAAK,QAAU,OACR,MAAO,IAAS,UAAY,YAAiB,QAGpD,KAAK,QAAU,SACR,MAAO,IAAS,YAAc,YAAiB,UAGtD,KAAK,QAAU,QACR,MAAO,IAAS,WAAa,YAAiB,SAGrD,KAAK,QAAU,OACR,MAAO,IAAS,UAAY,YAAiB,QAGpD,KAAK,QAAU,OACR,MAAO,IAAS,UAAY,YAAiB,QAGpD,KAAK,QAAU,OACR,MAAO,IAAS,SAGpB,YAAiB,MAAK,OAGjC,UAAW,OACA,MAGX,iBAAkB,OACV,MAAK,QAAU,OACR,SAGP,KAAK,QAAU,OACR,SAGP,KAAK,QAAU,SACR,WAGP,KAAK,QAAU,OACR,SAGP,KAAK,QAAU,QACR,UAGJ,GAAU,KAAK,QAG1B,qBAAsB,OACX,OAAS,GAAU,KAAK,QAAU,KAIjD,gBAAuB,GAAwB,CAC3C,gBAAgB,EAAgB,OACrB,CAAC,GAAY,IAAU,IAAU,KAG5C,UAAW,OACA,WAKX,qBAAsB,OACX,YAIf,gBAA8B,GAAkC,CAC5D,YAAY,EAAwB,EAAmB,GAAO,OACpD,EAAQ,GAGlB,gBAAgB,EAAuB,IAC/B,CAAC,MAAM,QAAQ,KAAK,aACd,IAAI,OACN,gCAAgC,KAAK,oBACjC,MAAO,MAAK,OACZ,WAIN,GACF,KAAK,OAAO,SAAW,GACtB,MAAM,QAAQ,IACX,KAAK,OAAO,MAAM,AAAC,GACf,EAAM,KAAK,AAAC,GAAY,EAAO,EAAM,WAG1C,MAAK,QAAU,CAAC,EAAS,EAGpC,UAAW,OACA,QAAQ,KAAK,QAAU,MAAQ,eAG1C,iBAAkB,OACP,SAIf,gBAA+B,GAA2C,CACtE,YAAY,EAAiC,EAAmB,GAAO,OAC7D,EAAQ,GAGlB,gBAAgB,EAAa,IACrB,MAAO,MAAK,QAAW,cACjB,IAAI,OACN,iCAAiC,KAAK,oBAClC,MAAO,MAAK,OACZ,SAIR,GAAS,YAEF,KAAY,MAAK,UAEpB,CAAC,GAAY,EAAO,IACpB,CAAC,EAAO,KAAK,OAAO,GAAW,EAAM,IACvC,GACW,eAKV,MAAK,QAAU,CAAC,EAAS,EAGpC,UAAW,OACA,SAAS,KAAK,QAAU,MAAQ,eAG3C,iBAAkB,OACP,UAIf,gBAA+B,GAA0B,CACrD,YAAY,EAAgB,EAAmB,GAAO,IAC9C,CAAC,GAAI,SAAU,QACT,IAAI,OAAM,kCAEd,EAAQ,GAGlB,gBAAgB,EAAe,MACrB,GAAS,GAAI,SAAU,IAAU,EAAM,SAAS,KAAK,cAEpD,MAAK,QAAU,CAAC,EAAS,EAGpC,UAAW,OACA,SAAS,KAAK,QAAU,MAAQ,eAG3C,iBAAkB,OACP,UAIf,gBAA6B,GAA0B,CACnD,YAAY,EAAyB,EAAmB,GAAO,IACvD,CAAC,GAAI,SAAU,IAAW,CAAC,GAAI,SAAU,QACnC,IAAI,OAAM,8CAEd,GAAI,QAAO,GAAS,GAG9B,gBAAgB,EAAe,MACrB,GAAS,GAAI,SAAU,IAAU,KAAK,OAAO,KAAK,SAEjD,MAAK,QAAU,CAAC,EAAS,EAGpC,UAAW,OACA,SAAS,KAAK,QAAU,MAAQ,aAG3C,iBAAkB,OACP,eAIF,IAAM,AAAC,GAAiC,GAAI,IAAI,GAChD,GAAW,IAAgB,GAAI,IAC/B,GAAkB,AAAC,GAC5B,GAAI,IAAgB,GACX,GAAqB,AAAC,GAC/B,GAAI,IAAgB,EAAQ,IACnB,GAAmB,AAC5B,GACmB,GAAI,IAAiB,GAC/B,GAAsB,AAC/B,GACmB,GAAI,IAAiB,EAAQ,IACvC,GAAmB,AAAC,GAC7B,GAAI,IAAiB,GACZ,GAAsB,AAAC,GAChC,GAAI,IAAiB,EAAU,IACtB,GAAiB,AAAC,GAC3B,GAAI,IAAe,GACV,GAAoB,AAAC,GAC9B,GAAI,IAAe,EAAU,ICxQ3B,GAA4B,IAAM,IAC3B,CACL,eAAgB,EAChB,yBAA0B,KAC1B,sBAAuB,MAMzB,GACF,IAAM,MACI,GAAmC,GACnC,CACF,iBACA,2BACA,gCACA,wBACA,8BACA,aAKA,MAAO,IAA6B,UACpC,IAAmB,EACrB,MACQ,GAA0B,EAC5B,GAAU,YAAa,MAGI,QAC3B,EACI,cACA,GACA,OAAO,GACP,CACI,mBAAoB,KAG5B;AAAA;AAAA,WACY,+BACZ,EACI,GAAU,iBAAkB,GAAkB,IAElD,MAEG,KAAK,CACR,OAAQ,EAAe,WACvB,MAAO,EACP,SAAU,EAAyB,gBAGvC,GAAyB,IAAmB,EAAG,MACzC,GAAW,EAAe,0BAC1B,EAAW,EAAe,mBAEJ,QACxB,EAAY,iBAAkB,GAAI,GAAI,CAClC,mBAAoB,KAExB;AAAA;AAAA,WACY,sBAA6B,OAEtC,KAAK,CACR,OAAQ,OACR,MAAO,EACP,SAAU,uBAIX,ICpET,GAAiB,AAAC,GAAwB,EAAI,QAAQ,QAAS,QAExD,GAA8C,CACvD,EACA,EACA,IAEA,EACI,IACI,GAAe,EAAS,MAAM,EAAG,IACjC,GACI,GAAe,EAAS,MAAM,EAAO,EAAQ,KAEjD,GAAe,EAAS,MAAM,EAAQ,IACtC,KAGC,GAA2C,CACpD,EACA,IAEA,IAAW,KACL,EAAc,GACd,GACI,EACA,EAAO,MACP,EAAO,GAAG,QAMX,GAAwC,CACjD,EACA,IAEA,EACI,IACI,EACK,IAAI,CAAC,EAAM,IAAM,MACR,GAAc,EAAU,SACvB,KAAM,EACP,GAAe,GACf,IAET,KAAK,MACV,KAGC,GAAe,CACxB,EACA,EACA,EACA,IACS,MACH,GAAqB,EAAU,GAC/B,EAAqB,EAAmB,SAAS,KAEjD,EAAa,cAAc,GAC3B,GAAK,GAAa,EAAY,GAI9B,EAAa,QAAQ,EAAY,GACjC,EAAU,SAGZ,wBAAwB,EAAQ,OAAS,OAAO,EAC5C;AAAA,uBAEoB,EAAQ,OAAS,OAAO,EAC5C;AAAA,uBAEoB,EAAQ,OAAS,OAAO,EAC5C,MAKC,GAA+B,CACxC,EACA,IACS,GAAqB,EAAO,EAAU,GAAO,IAAQ;AAAA,EAErD,GAAkC,CAC3C,EACA,IACS,GAAqB,EAAO,EAAU,GAAM,IAAQ;AAAA,EAEpD,GAA+B,CACxC,EACA,IACS,GAAqB,EAAO,EAAU,GAAO,IAAS;AAAA,EAGtD,GAAkC,CAC3C,EACA,EACA,IAEA,MAAO,GAAS,MAAS,UACzB,EAAS,KAAK,SAAW,GACzB,MAAO,GAAS,MAAS,UACzB,EAAS,KAAK,SAAW,EACnB,GAAqB,EAAO,EAAU,GAAM,IAC5C,IACI,OAAO,eAAe,KAAc,EAC9B,UACA,4BACN,EAAe,EAAS;AAAA,EAE5B,GAAqB,EAAO,EAAU,GAAO,IAAS;AAAA,EAE1D,GAAuB,CACzB,EACA,EACA,EACA,IAEA,MAAO,GAAY,MAAS,SACtB,GAAG,yBACH,EAAY,KAAK,SAAW,EAC5B,GAAG,4BACH,GAAG,MAAU,AAAC,EAAa,EAAa,OAAS,OAA3B,KAClB,EACM,EAAe,EAAY,MAC3B,EAAe,EAAY,QC9FzC,GAAiB,WACjB,GAAiB,WACjB,GAAuB,iBACvB,GAAuB,iBAGvBC,GAAW,AAAC,GAA8B,IAAW,GAErD,GAAuB,CACzB,EACA,GACA,GACA,IAUEC,GAA2B,CAC7B,KAAK,EAAmB,EAAmB,MACjC,GAAc,OACd,EAA8B,CAChC,QAAS,qBACT,MAAO,KAAK,MACZ,QAAS,KAAK,SAGZ,EAAO,OAAO,GAAG,EAAU,SA8C1B,CAAE,OAAQ,EAAU,WAAU,QA5CrB,EACV,IACI,EAAY,EAAa,OAAW,OAAW,GAC/C;AAAA;AAAA,gBACiB,EAAc,KACnC,IAAM,MACI,GAAe,EAAQ,MAEzB,GAAmB,WACnB,KAAiB,OAAS,IAAiB,QAIvC,EAAO,EAAU,EAAU,GAAsB,MAE9B,gBAEnB,EAAO,EAAU,EAAU,CAAC,QAET,YAKvB,EAAY,EAAa,OAAW,OAAW,GAC/C;AAAA;AAAA,OACsB,KAChB,GACI,kDAAkD,YAAsB,MACxE;AAAA;AAAA,EACJ,IACN,GACI,EACA,EACA,GACA,GACAD,GAAS,KAAK,UAQc,KAAM,EAAa,SAGrE,YAAY,EAAkB,EAAkB,EAAoB,EAAG,MAC7D,GAAc,cACd,EAAiB,UAAU,SAAW,EAAI,YAAc,OACxD,EAAQ,KAAK,MACb,EAA8B,CAChC,QACA,QAAS,KAAK,QACd,iBACA,oBAAqB,AAAC,GAAgB,MAGtC,MAAO,IAAa,cACd,IAAI,OACN,EACI,EAAY,EAAa,OAAW,OAAW,GAC/C,GAAG,EAAe,qCAClB,EAAc,WAAY,EAAU,QAK5C,MAAO,IAAa,cACd,IAAI,OACN,EACI,EAAY,EAAa,OAAW,OAAW,GAC/C,GAAG,EAAe,qCAClB,EAAc,WAAY,EAAU,QAK5C,GAAO,GACP,EAAe,EACf,EAAe,QAEf,KAAa,KAAY,IAAa,KAE/B,IAAa,MAAa,IAAa,OADvC,MAIQ,KAAK,IAAI,GAAI,CAAC,GAAa,IAC3B,KAAK,IAAI,EAAW,KAC5B,EAAe,GA0BnB,CAAE,QAvBO,EACV,IACI,EAAY,EAAa,OAAW,OAAW,GAC/C;AAAA;AAAA,gBACiB,EAAc;AAAA,OACb,EACZ,GACA,iBAAiB,EAAc;AAAA;AAAA,EAE/B,GACI,EACA,EACA,EACA,IAEd,IACI,EAAY,EAAa,OAAW,OAAW,GAC/C;AAAA;AAAA,YACa,EAAc;AAAA,YACd,EAAc;AAAA;AAAA,EAE3B,GAAa,EAAc,EAAc,EAAW,GAE5C,SAGtB,YAAY,EAAmB,EAAgB,MACrC,GAAc,cACd,EAA8B,CAChC,MAAO,KAAK,MACZ,QAAS,KAAK,mBAED,EAAU,EAAa,GASjC,CAAE,QALO,IACZ,EAAY,EAAa,OAAW,GAAI,GACxC;AAAA;AAAA,YACa,EAAc,KAEb,KAPL,IAAa,SAU9B,UAAU,EAAmB,EAAgB,MACnC,GAAc,YACd,EAA8B,CAChC,MAAO,KAAK,MACZ,QAAS,KAAK,mBAED,EAAU,EAAa,GASjC,CAAE,QALO,IACZ,EAAY,EAAa,OAAW,GAAI,GACxC;AAAA;AAAA,YACa,EAAc,KAEb,KAPL,CAAC,IAUlB,gBAAgB,EAA2B,EAA2B,MAC5D,GAAc,kBACd,EAAQ,KAAK,MACb,EAA8B,CAChC,QACA,QAAS,KAAK,YAEJ,EAAU,EAAU,EAAa,QAEzC,GAAO,EAAW,QAQjB,CAAE,QANO,IACZ,EAAY,EAAa,OAAW,OAAW,GAC/C;AAAA;AAAA,WACY,EAAQ,OAAS,QAAQ,EAAc;AAAA,WACvC,EAAQ,OAAS,QAAQ,EAAc,KAErC,SAGtB,uBACI,EACA,EACF,MACQ,GAAc,yBACd,EAAQ,KAAK,MACb,EAA8B,CAChC,QACA,QAAS,KAAK,YAEJ,EAAU,EAAU,EAAa,QAEzC,GAAO,GAAY,QAQlB,CAAE,QANO,IACZ,EAAY,EAAa,OAAW,OAAW,GAC/C;AAAA;AAAA,WACY,EAAQ,OAAS,SAAS,EAAc;AAAA,WACxC,EAAQ,OAAS,SAAS,EAAc,KAEtC,SAGtB,eAAe,EAAe,EAAoB,MACxC,GAAc,iBACd,EAA8B,CAChC,MAAO,KAAK,MACZ,QAAS,KAAK,YAGd,MAAO,IAAa,gBACd,IAAI,OACN,EACI,EAAY,EAAa,OAAW,OAAW,GAC/C,GAAG,EAAe,uCAClB,EAAc,WAAY,EAAU,UAK1C,GAAO,YAAoB,SAqC1B,CAAE,QAnCO,EACV,IACI,EAAY,EAAa,OAAW,OAAW,GAC/C;AAAA;AAAA,EACA,GACI,uBACA,UAEI,GAAS,aAAgB,YACjC,EAAS,cAAgB,EACnB,GACI,uBACA,EAAS,YACT,GAEJ,IACV,IACI,EAAY,EAAa,OAAW,OAAW,GAC/C;AAAA;AAAA,EACA,GACI,uBACA,OAES,IACb,OAAO,eAAe,KAAc,KAC9B;AAAA;AAAA,kBAAsD,EAClD,KAEJ,MAAO,GAAS,aAAgB,WAChC;AAAA,kBAAqB,EAAc,KACnC,GACI,uBACA,EAAS,cAGX,SAGtB,aAAa,EAA2B,EAA2B,MACzD,GAAc,eACd,EAAQ,KAAK,MACb,EAA8B,CAChC,QACA,QAAS,KAAK,YAEJ,EAAU,EAAU,EAAa,QAEzC,GAAO,EAAW,QAQjB,CAAE,QANO,IACZ,EAAY,EAAa,OAAW,OAAW,GAC/C;AAAA;AAAA,WACY,EAAQ,OAAS,QAAQ,EAAc;AAAA,WACvC,EAAQ,OAAS,QAAQ,EAAc,KAErC,SAGtB,oBAAoB,EAA2B,EAA2B,MAChE,GAAc,sBACd,EAAQ,KAAK,MACb,EAA8B,CAChC,QACA,QAAS,KAAK,YAEJ,EAAU,EAAU,EAAa,QAEzC,GAAO,GAAY,QAQlB,CAAE,QANO,IACZ,EAAY,EAAa,OAAW,OAAW,GAC/C;AAAA;AAAA,WACY,EAAQ,OAAS,SAAS,EAAc;AAAA,WACxC,EAAQ,OAAS,SAAS,EAAc,KAEtC,SAGtB,QAAQ,EAAe,EAAgB,MAC7B,GAAc,UACd,EAA8B,CAChC,MAAO,KAAK,MACZ,QAAS,KAAK,YAED,EAAU,EAAa,QAElC,GAAO,OAAO,MAAM,SAOnB,CAAE,QALO,IACZ,EAAY,EAAa,OAAW,GAAI,GACxC;AAAA;AAAA,YACa,EAAc,KAEb,SAGtB,SAAS,EAAmB,EAAgB,MAClC,GAAc,WACd,EAA8B,CAChC,MAAO,KAAK,MACZ,QAAS,KAAK,mBAED,EAAU,EAAa,GASjC,CAAE,QALO,IACZ,EAAY,EAAa,OAAW,GAAI,GACxC;AAAA;AAAA,YACa,EAAc,KAEb,KAPL,IAAa,OAU9B,WAAW,EAAmB,EAAgB,MACpC,GAAc,aACd,EAA8B,CAChC,MAAO,KAAK,MACZ,QAAS,KAAK,mBAED,EAAU,EAAa,GASjC,CAAE,QALO,IACZ,EAAY,EAAa,OAAW,GAAI,GACxC;AAAA;AAAA,YACa,EAAc,KAEb,KAPL,CAAC,CAAC,IAUnB,cAAc,EAAmB,EAAgB,MACvC,GAAc,gBACd,EAA8B,CAChC,MAAO,KAAK,MACZ,QAAS,KAAK,mBAED,EAAU,EAAa,GASjC,CAAE,QALO,IACZ,EAAY,EAAa,OAAW,GAAI,GACxC;AAAA;AAAA,YACa,EAAc,KAEb,KAPL,IAAa,SAU9B,UAAU,EAAoC,EAAmB,MACvD,GAAc,YACd,EAAQ,KAAK,MACb,EAA8B,CAChC,QAAS,UACT,QACA,QAAS,KAAK,YAGd,GAAY,UACN,IAAI,OACN,EACI,EAAY,EAAa,OAAW,OAAW,GAC/C,GAAG,EACC,mDAEJ,EAAc,WAAY,EAAU,QAK5C,MAAO,IAAa,SAAU,MACxB,GAAwB,GAAG,EAC7B,yCAC2B,EAC3B,mCAGA,MAAO,IAAa,cACd,IAAI,OACN,EACI,EACI,EACA,EACA,OAAO,GACP,GAEJ,EACA,EAAc,WAAY,EAAU,GAChC;AAAA,EACA,EAAc,WAAY,EAAU,UAK9C,GAAQ,EAAS,QAAQ,OAAO,UA+B/B,CAAE,QA5BO,IAAM,MACZ,GAAgB,YAClB,MAAO,IAAa,SAAW,YAAc,UAE3C,EAAgB,kBAChB,EAAa,GACf,EACA,SAIA,GAAY,EAAa,OAAW,OAAW,GAC/C;AAAA;AAAA,EACG,EAAW,KACV,EAAQ,OAAS,KAClB,EAAc;AAAA,EACd,EAAW,KAAiB,EAAQ,OAAS,KAC5C,EACM,GACI,EACA,EACA,OAAO,GAAU,QAErB,EAAc,MAKd,KA9BL,IAAU,SAiCrB,GAAY,MAAM,KAAK,GACvB,EAAQ,EAAU,QAAQ,SA4BzB,CAAE,QAzBO,IAAM,MACZ,GAAgB,iBAChB,EAAgB,YAAY,EAAQ,KACpC,EAAa,GAAgB,EAAe,SAG9C,GAAY,EAAa,OAAW,OAAW,GAC/C;AAAA;AAAA,EACG,EAAW,KACV,EAAQ,OAAS,KAClB,EAAc;AAAA,EACd,EAAW,KAAiB,EAAQ,OAAS,KAC5C,GAAS,MAAM,QAAQ,GACjB,GAAsC,EAAU,GAChD,EAAc,OAEtB,GACF,EAAU,UAAU,AAAC,GACjB,EAAO,EAAM,EAAU,CAAC,OACtB,GACA;AAAA;AAAA,EAAO,KACP,KAII,KA3BL,IAAU,KA8B3B,eAAe,EAA2B,EAAmB,MACnD,GAAc,iBACd,EAAQ,KAAK,MACb,EAA8B,CAChC,QAAS,gBACT,QACA,QAAS,KAAK,YAGd,GAAY,UACN,IAAI,OACN,EACI,EAAY,EAAa,OAAW,OAAW,GAC/C,GAAG,EACC,mDAEJ,EAAc,WAAY,EAAU,UAK1C,GAAQ,MAAM,KAAK,GAAU,UAAU,AAAC,GAC1C,EAAO,EAAM,EAAU,CAAC,WAuBrB,CAAE,QAnBO,IAAM,MACZ,GAAgB,iBAChB,EAAgB,YAAY,EAAQ,KACpC,EAAa,GAAgB,EAAe,SAG9C,GAAY,EAAa,OAAW,OAAW,GAC/C;AAAA;AAAA,EACG,EAAW,KACV,EAAQ,OAAS,KAClB,EAAc;AAAA,EACd,EAAW,KAAiB,EAAQ,OAAS,KAC5C,GAAS,MAAM,QAAQ,GACjB,GAAsC,EAAU,GAChD,EAAc,MAKd,KArBL,IAAU,KAwB3B,QAAQ,EAAmB,EAAmB,MACpC,GAAc,UACd,EAA8B,CAChC,QAAS,gBACT,MAAO,KAAK,MACZ,QAAS,KAAK,SAGZ,EAAO,EAAO,EAAU,EAAU,CAAC,UAwBlC,CAAE,OAAQ,EAAU,WAAU,QAtBrB,EACV,IACI,EAAY,EAAa,OAAW,OAAW,GAC/C;AAAA;AAAA,gBACiB,EAAc;AAAA,KACpB,KAAc,EAAU,GAC7B,iBAAiB,EAAc,KAC/B,IACV,IACI,EAAY,EAAa,OAAW,OAAW,GAC/C;AAAA;AAAA,EACA,GACI,EACA,EACA,GACA,GACAA,GAAS,KAAK,SAMkB,KAAM,EAAa,SAGrE,aAAa,EAAe,EAAkB,MACpC,GAAc,eACd,EAAQ,KAAK,MACb,EAA8B,CAChC,QACA,QAAS,KAAK,YAGd,MAAO,kBAAU,SAAW,cACtB,IAAI,OACN,EACI,EAAY,EAAa,OAAW,OAAW,GAC/C,GAAG,EACC,6EAEJ,EAAc,WAAY,EAAU,QAKb,EAAU,EAAa,QAEpD,GAAO,EAAS,SAAW,QA6B1B,CAAE,QA3BO,IAAM,MACZ,GAAgB,kBAChB,EAAsB,kBACtB,EAAqB,YAAY,EAAQ,KACzC,EAAa,GACf,EACA,EACA,SAIA,GAAY,EAAa,OAAW,OAAW,GAC/C;AAAA;AAAA,EACG,EAAW,KACV,EAAQ,OAAS,KAClB,EAAc;AAAA,KAEX,GACA,GAAG,EAAW,KAAuB,EACjC,EAAS;AAAA,GAEnB,GAAG,EAAW,KACV,EAAQ,OAAS,KAClB,EAAc,MAIP,SAGtB,eACI,EACA,EACA,EACF,MACQ,GAAc,iBACd,EAAmB,OACnB,EAAW,UAAU,SAAW,EAChC,EAA8B,CAChC,MAAO,KAAK,MACZ,QAAS,KAAK,QACd,eAAgB,EAAW,QAAU,OAGrC,GAAa,UACP,IAAI,OACN,EACI,EACI,EACA,OACA,EACA,GAEJ,GAAG,EACC,mDAEJ,EAAc,WAAY,EAAU,UAK1C,GAAmB,EAAQ,MAE7B,IAAqB,UAAY,IAAqB,aAChD,IAAI,OACN,EACI,EACI,EACA,OACA,EACA,GAEJ,GAAG,EACC,6CAEJ,EAAc,WAAY,EAAc,UAK9C,GACF,MAAO,IAAiB,SAClB,EAAa,MAAM,KAAK,OACxB,EAAa,UAEnB,IAAqB,SAAW,IAAuB,OACjD,IAAI,OACN,EACI,EACI,EACA,OACA,EACA,GAEJ,GAAG,EACC,8CAEJ,EAAc,WAAY,EAAc,UAK9C,GAAS,GAAQ,EAAU,GAC3B,CAAE,sBAAqB,cAAe,EACtC,EAAe,EAAO,cACtB,EAAkB,EAAa,SAAW,EAC1C,EAAgB,EAChB,EAAO,MACP,EAEA,EAAO,EACP,EAAO,EAAO,MAAO,EAAe,CAAC,IACrC,QAAQ,SAMV,IAAQ,CAAC,EAgBF,CAAE,QAfO,IACZ,EAAY,EAAa,OAAW,EAAkB,GACtD;AAAA;AAAA,iBACkB,EAAc;AAAA,iBACd,EACd,IAAqB,SAAW,EAAa,SAAW,EAClD,EACA,EAAa,KAAK;AAAA;AAAA,sBAEL,EAAc;AAAA,sBACd,EAAc;AAAA;AAAA,EACrC,GACI,yLAGU,QAuDf,CAAE,QApDO,EACV,IACI,EACI,EACA,OACA,EACA,GAEJ;AAAA;AAAA,KAEM,kBAAkB,EAAc;AAAA;AAAA,sBACT,EAAc,QAC1B,KAAmB,EAAU,GAClC;AAAA,sBAAyB,EACrB,KAEJ,IACN,sBAAsB,EAClB;AAAA;AAAA,kBAEe,EAAc,MAC3C,IACI,EACI,EACA,OACA,EACA,GAEJ;AAAA;AAAA,iBACkB,EAAc;AAAA,KAE1B;AAAA,EACA,GACI,EACA,EACA,GACA,GACAA,GAAS,KAAK,SAElB,kBAAkB,EACd,IAAqB,SACjB,EAAa,SAAW,EACtB,EACA,EAAa,KAAK;AAAA;AAAA,KAGtB,mBAAmB,EACf;AAAA,EAEJ,IACN,mBAAmB,EAAc,MAE/B,SAGtB,QAAQ,EAAkB,EAA2B,MAC3C,GAAc,UACd,EAA8B,CAChC,MAAO,KAAK,MACZ,QAAS,KAAK,YAGd,MAAO,IAAa,cACd,IAAI,OACN,EACI,EAAY,EAAa,OAAW,OAAW,GAC/C,GAAG,EAAe,qCAClB,EAAc,WAAY,EAAU,QAM5C,MAAS,IAAa,UACtB,KAAc,MAAO,GAAS,MAAS,iBAEjC,IAAI,OACN,EACI,EAAY,EAAa,OAAW,OAAW,GAC/C,GAAG,EACC,2DAEJ,EAAc,WAAY,EAAU,UAK1C,GACF,MAAO,IAAa,SACd,EAAS,SAAS,GAClB,GAAI,QAAO,GAAU,KAAK,SAoD7B,CAAE,QAlDO,EACV,IACI,MAAO,IAAa,SACd,EACI,EACA,OACA,OACA,GAEJ;AAAA;AAAA,0BAC2B,EAAc;AAAA,0BACd,GACvB,EACA,EAAS,QAAQ,GACjB,EAAS,UAEb,EACI,EACA,OACA,OACA,GAEJ;AAAA;AAAA,wBACyB,EAAc;AAAA,wBACd,GACrB,EACA,MAAO,GAAS,MAAS,WACnB,EAAS,KAAK,GACd,QAEpB,IAAM,MACI,GAAgB,YAClB,MAAO,IAAa,SAAW,YAAc,YAE3C,EAAgB,kBAChB,EAAa,GACf,EACA,SAIA,GAAY,EAAa,OAAW,OAAW,GAC/C;AAAA;AAAA,EACG,EAAW,KAAiB,EAC3B;AAAA,EAED,EAAW,KAAiB,EAAc,MAIzC,SAGtB,cAAc,EAAkB,EAAkB,MACxC,GAAc,gBACd,EAA8B,CAChC,MAAO,KAAK,MACZ,QAAS,KAAK,YAGd,MAAO,IAAa,UAAY,IAAa,UACvC,IAAI,OACN,EACI,EAAY,EAAa,OAAW,OAAW,GAC/C,GAAG,EACC,8CAEJ,EAAc,WAAY,EAAU,QAK5C,MAAO,IAAa,UAAY,IAAa,UACvC,IAAI,OACN,EACI,EAAY,EAAa,OAAW,OAAW,GAC/C,GAAG,EACC,8CAEJ,EAAc,WAAY,EAAU,UAK1C,GAAO,EAAO,EAAU,EAAU,CACpC,EACA,WAsBG,CAAE,QAnBO,EACV,IACI,EAAY,EAAa,OAAW,OAAW,GAC/C;AAAA;AAAA,gBACiB,EAAc,QACpB,KAAc,EAAU,GAC7B;AAAA,gBAAmB,EAAc,KACjC,IACV,IACI,EAAY,EAAa,OAAW,OAAW,GAC/C;AAAA;AAAA,EACA,GACI,EACA,GAAgB,EAAU,GAC1B,GACA,GACAA,GAAS,KAAK,SAGV,SAGtB,cAAc,EAAmB,EAAmB,MAC1C,GAAc,gBACd,EAA8B,CAChC,QAAS,gBACT,MAAO,KAAK,MACZ,QAAS,KAAK,SAGZ,EAAO,EAAO,EAAU,EAAU,GAAsB,UAwBvD,CAAE,OAAQ,EAAU,WAAU,QAtBrB,EACV,IACI,EAAY,EAAa,OAAW,OAAW,GAC/C;AAAA;AAAA,gBACiB,EAAc;AAAA,KACpB,KAAc,EAAU,GAC7B,iBAAiB,EAAc,KAC/B,IACV,IACI,EAAY,EAAa,OAAW,OAAW,GAC/C;AAAA;AAAA,EACA,GACI,EACA,EACA,GACA,GACAA,GAAS,KAAK,SAMkB,KAAM,EAAa,UCj/BnE,GAAW,AAAC,GAA8B,IAAW,GAErD,GAAc,EAEd,GAAe,0BAEf,GAAoB,AAAC,GACvB,EAAS,SAAW,EACd,GACA,EAAS,IAAI,AAAC,GAAQ,EAAc,IAAM,KAAK,MAEnD,GAAoB,CACtB,EACA,IAEA,EAAS,SAAW,EACd,GACA,EACK,IAAI,CAAC,EAAK,IACP,MAAM,QAAQ,IACd,EAAI,EAAS,QACb,GAAa,EAAS,GAAI,GACpB,GAAY,GACZ,EAAc,IAEvB,KAAK,MAEd,GAAc,AAAC,GAAiB,GAAU,EAAU,IAEpD,GAAe,CAAC,EAAmB,IACrC,EAAO,EAAU,EAAU,CAAC,IAE1B,GAAc,CAChB,EACA,IACU,GAAa,EAAU,GAE/B,GAAgB,CAAC,EAAmB,IACtC,EAAO,OAAS,UAAY,GAAa,EAAU,EAAO,OAExD,GAAe,AAAC,GAClB,EAAQ,OACJ,CAAC,EAAW,IAAiB,EAAO,OAAS,SAAW,EAAI,EAAI,EAChE,GAGF,GAAuB,CACzB,EACA,IAEA;AAAA,qBAAwB,EAAc,UACtB,EACV;AAAA,qBAAwB,EAAc,KACtC,IAMJ,GAAyB,AAAC,GAA8B,MAEpD,GAAQ,EAAM,QAAQ,KACtB,EAAS,EAAM,MAAM,SAEpB,CAAC,EAAgB,OAEd,KAAO,IAAI,OAAO,KAAK,IAAI,EAAG,EAAQ,EAAI,EAAO,SACjD,IAAI,OAAO,KAAK,IAAI,EAAQ,EAAO,UACzC,EACA,GAKF,GAA6B,CAC/B,EACA,EACA,EACA,IACC,IACG,EAAa,SAAW,QACjB,QAGL,GAAQ,oBACV,QACO,GAAQ,GAAkB,EAAa,GAAI,GAAY;AAAA,OAG5D,GAAe,GAAuB,SAGxC;AAAA,EACA,EAAa,OACT,CAAC,EAAiB,CAAC,EAAG,KAClB,EACA,EAAa,OAAO,EAAI,GAAI,IAAM,GAClC,GAAkB,EAAM,GACxB;AAAA,EACJ,KAKN,GAAqC,CACvC,EACA,EACA,EACA,EACA,IACC,MACK,GAAe,aAAa,GAAkB;AAAA,KAChD,EAAa,SAAW,QACjB,QAGL,GAAQ,gBACV,QAAiC,GAAK,IAAkB,QAAY,MAC9D,GAAW,EAAa,GAAG,MAE7B,GAAmB,EAAU,GAAW,MAElC,GAAQ,CACV,EAAe,cACf,EAAe,cACf,IAGE,EAAS,KAAK,IAAI,EAAS,OAAQ,EAAS,eACzC,GAAI,EAAG,EAAI,EAAQ,GAAK,EAAG,IAC5B,EAAI,EAAS,QAAU,EAAI,EAAS,OAAQ,IACxC,GAAa,EAAS,GAAI,EAAS,IAAK,GAClC,KAAK,KAAK,GAAY,EAAS,oBAIrC,GAAkB,EAAS,GAAI,EAAS,IAAK,MACvC,GAAa,GAAK,EAAS,GAAI,EAAS,GAAI,CAC9C,cAGA,MAAO,IAAe,UACtB,EAAW,SAAS,eACpB,EAAW,SAAS,cACtB,GAEQ,KACF,EAAW,MAAM;AAAA,GAAM,MAAM,GAAG,KAAK;AAAA,GAAQ,gBAOzD,EAAI,EAAS,UACP,KACF,EAAe,KAAO,EAAU,EAAS,KAAO,KAGpD,EAAI,EAAS,UACP,KACF,EAAe,KAAO,EAAU,EAAS,KAAO,WAKrD,GAAM,KAAK;AAAA,GAAQ;AAAA,QAI1B,GAAe,EAAQ,GAAkB,EAAU,GAAY;AAAA,OAIjE,GAAe,GAAuB,SAGxC,GACA;AAAA,EACA,EAAa,OAAO,CAAC,EAAiB,CAAC,EAAG,KAA2B,MAC3D,GAAU,EAAa,OAAO,EAAI,GAAI,IAAM,SAE9C,SACQ,GAAiB,IAAkB,SAC3C,GAAmB,EAAU,GACvB,EAAQ,QAAQ,KAAM;AAAA,GACtB,GAAc,EAAU,EAAU,GAClC,EAAU,GAAkB,EAAU,IAC5C;AAAA,GAEL,KAIL,GAAc,WAAW,QAAQ,MAAO,KAExC,GAAgB,CAClB,EACA,EACA,IAEA,EACK,IAAI,CAAC,EAAK,IAAM,IACT,EAAI,EAAS,OAAQ,IACjB,GAAa,EAAS,GAAI,SACnB,IAAc,KAAO,GAAY,GAAO,OAG/C,GAAkB,EAAS,GAAI,GAAM,MAC/B,GAAa,GAAK,EAAS,GAAI,EAAK,CAAE,cAGxC,MAAO,IAAe,UACtB,EAAW,SAAS,eACpB,EAAW,SAAS,oBAKhB,GACK,MAAM;AAAA,GACN,MAAM,GACN,IAAI,AAAC,GAAS,GAAc,GAC5B,KAAK;AAAA,GAAQ,WAQ9B,OACK,EAAS,OACR,KAAO,EAAc,GACrB,EAAe,KAAO,EAAU,KACtC,MAGP,KAAK;AAAA,GAER,GAAqB,CACvB,EACA,IAEA,EAAS,KACL,CAAC,EAAK,IAAM,EAAI,EAAS,QAAU,GAAkB,EAAK,EAAS,KAKrE,GAAoB,CAAC,EAAmB,IAA+B,MACnE,GAAe,EAAQ,GACvB,EAAe,EAAQ,SAEzB,MAAiB,GAIjB,GAAY,IAKZ,IAAiB,QACjB,IAAiB,YACjB,IAAiB,UAKjB,YAAoB,QAAS,YAAoB,QAKjD,IAAiB,UACjB,MAAQ,GAAiB,iBAAoB,YAM7C,IAAiB,UACjB,MAAQ,GAAiB,iBAAoB,aAQ/C,GAAc,CAAC,EAAa,IAC9B,EAAO,OAAS,QACV,+BACA,EAAO,OAAS,aAChB,qCACA,GAAa,EAAU,EAAO,OAC9B,GAAY,EAAO,OACnB,EAAc,EAAO,OAMzB,GAAuB,CACzB,EACA,EACA,EACA,EACA,IACC,IACG,EAAe,SAAW,QACnB,MAGP,QAAiC,GAAK,IAAkB,cACjD,GAAQ,GAAY,EAAe,GAAG,GAAI,GAAY;AAAA,OAG3D,GAAe,GAAuB,SAGxC,GAAM,QAAQ,IAAK,IAAI,OACvB;AAAA,EACA,EAAe,OACX,CAAC,EAAiB,CAAC,EAAG,KAClB,EACA,EAAa,OAAO,EAAI,GAAI,IAAM,GAClC,GAAY,EAAQ,GACpB;AAAA,EACJ,KAKN,GAA0B,AAAC,GAC7B,SAEI,EACA,EACqB,MACf,GAAmB,GACnB,EAA8B,CAChC,MAAO,KAAK,MACZ,QAAS,KAAK,YAED,EAAU,EAAa,MACxB,EAAU,EAAa,EAAkB,QAEnD,GAAgB,GAAM,GACtB,EAAe,EAAgB,MAAQ,EAAS,cAChD,EAAQ,EACR,EAAS,MAAM,QACf,EAAS,KAAK,MAAM,OACpB,EAAQ,EACR,EAAS,MAAM,MAAM,IAAI,AAAC,GAAW,EAAE,MACvC,EAAS,KAAK,MACd,EAAO,EAAQ,QAkCd,CAAE,QAjCO,EACV,IACI,EACI,EACA,EACA,EACA,GAEJ;AAAA;AAAA,4BAC6B,EAAc;AAAA,4BACd,EAAc;AAAA;AAAA,EAC3C,EACK,OAAO,CAAC,EAAsB,EAAW,IAClC,GAAM,OAAS,MACT,KACF,GAAG,EAAI,MAAM,GAAkB,MAIhC,GACR,IACF,KAAK;AAAA,GACd,IACI,EACI,EACA,EACA,EACA,GAEJ;AAAA;AAAA,+BACgC,EAAc;AAAA,+BACd,EAAc,KAEtC,SAGpB,GAAwB,AAAC,GAC3B,SAEI,EACA,EACqB,MACf,GAAmB,GACnB,EAA8B,CAChC,MAAO,KAAK,MACZ,QAAS,KAAK,YAED,EAAU,EAAa,MAC7B,EAAU,EAAa,EAAkB,QAE9C,GAAe,EAAS,cAGxB,EAAQ,EAAS,KAAK,QAAQ,OAChC,CAAC,EAAW,IAAiB,EAAO,OAAS,SAAW,EAAI,EAAI,EAChE,GAGE,EAAO,EAAQ,QAmDd,CAAE,QAjDO,EACV,IACI,EACI,EACA,EACA,EACA,GAEJ;AAAA;AAAA,8BAC+B,EAAc;AAAA,8BACd,EAAc;AAAA;AAAA,EAC7C,EAAS,KAAK,QACT,OACG,CAAC,EAAsB,EAAa,IAE5B,GAAO,OAAS,UAChB,EAAM,OAAS,MAET,KACF,GAAG,EAAI,MAAM,EAAc,EAAO,UAInC,GAEX,IAEH,KAAK;AAAA,MACA,KAAK,MAAM,SAAW,EAC1B;AAAA;AAAA,8BAAmC,EAC/B,EAAS,KAAK,MAAM,UAExB,IACV,IACI,EACI,EACA,EACA,EACA,GAEJ;AAAA;AAAA,iCACkC,EAAc;AAAA,iCACd,EAAc,QACtC,KAAK,MAAM,SAAW,EAC1B;AAAA,iCAAoC,EAChC,EAAS,KAAK,MAAM,UAExB,IAEE,SAGpB,GAA+B,AAAC,GAClC,SAEI,EACA,EACqB,MACf,GAAmB,WACnB,EAA8B,CAChC,MAAO,KAAK,MACZ,QAAS,KAAK,YAEiB,EAAU,EAAa,MAC1C,EAAU,EAAa,EAAkB,QAEnD,GAAgB,GAAM,GACtB,EAAe,EAAgB,MAAQ,EAAS,cAChD,EAAQ,EACR,EAAS,MAAM,QACf,EAAS,KAAK,MAAM,OAEpB,EAAO,IAAU,QAuBhB,CAAE,QArBO,EACV,IACI,EACI,EACA,EACA,EACA,GAEJ;AAAA;AAAA,gCACiC,EAAc,KACnD,IACI,EACI,EACA,EACA,EACA,GAEJ;AAAA;AAAA,4BAC6B,EAAc;AAAA,4BACd,EAAc,KAEnC,SAGpB,GAA6B,AAAC,GAChC,SAEI,EACA,EACqB,MACf,GAAmB,WACnB,EAA8B,CAChC,MAAO,KAAK,MACZ,QAAS,KAAK,YAEiB,EAAU,EAAa,MAC/C,EAAU,EAAa,EAAkB,QAE9C,GAAe,EAAS,cAGxB,EAAQ,EAAS,KAAK,QAAQ,OAChC,CAAC,EAAW,IAAiB,EAAO,OAAS,SAAW,EAAI,EAAI,EAChE,GAGE,EAAO,IAAU,QAiChB,CAAE,QA/BO,EACV,IACI,EACI,EACA,EACA,EACA,GAEJ;AAAA;AAAA,kCACmC,EAAc,QACvC,KAAK,MAAM,SAAW,EAC1B;AAAA;AAAA,kCAAuC,EACnC,EAAS,KAAK,MAAM,UAExB,IACV,IACI,EACI,EACA,EACA,EACA,GAEJ;AAAA;AAAA,8BAC+B,EAAc;AAAA,8BACd,EAAc,QACnC,KAAK,MAAM,SAAW,EAC1B;AAAA,8BAAiC,EAC7B,EAAS,KAAK,MAAM,UAExB,IAEE,SAGpB,GAA8B,AAAC,GACjC,SAEI,KACG,EACkB,MACf,GAAmB,cACnB,EAA8B,CAChC,MAAO,KAAK,MACZ,QAAS,KAAK,YAEF,EAAU,EAAa,EAAkB,QAEnD,GAAgB,GAAM,GACtB,EAAe,EAAgB,MAAQ,EAAS,cAEhD,EAAQ,EACR,EAAS,MAAM,MAAM,IAAI,AAAC,GAAW,EAAE,MACvC,EAAS,KAAK,MAEd,EAAO,EAAM,KAAK,AAAC,GAAc,GAAY,EAAU,UAmEtD,CAAE,QAjEO,EACV,IAAM,MAEI,GAAmC,MACrC,GAAI,OAEJ,EAAI,EAAM,QACV,EAAa,OAAS,IAElB,GAAY,EAAU,EAAM,OACf,KAAK,CAAC,EAAG,EAAM,QAE3B,QAIL,GACI,EACA,EACA,EACA,GAEJ;AAAA;AAAA,gBACiB,GAAkB;AAAA,KAC5B,SAAW,GAClB,EAAU,EAAM,MAAQ,EAAU,GAC5B,GACA,GACI,EACA,EACA,EAAM,SAAW,IAE3B;AAAA,mBAAsB,EAAc,EAAM,WAGlD,IAAM,MAEI,GAAmC,MACrC,GAAI,OAEJ,EAAI,EAAM,QACV,EAAa,OAAS,MAET,KAAK,CAAC,EAAG,EAAM,QACvB,QAIL,GACI,EACA,EACA,EACA,GAEJ;AAAA;AAAA,EACA,GACI,EACA,EACA,GAAS,KAAK,QACd,EAAM,SAAW,GAErB;AAAA,mBAAsB,EAAc,EAAM,WAItC,SAGpB,GAA4B,AAAC,GAC/B,SAEI,EACA,EACqB,MACf,GAAmB,WACnB,EAA8B,CAChC,MAAO,KAAK,MACZ,QAAS,KAAK,YAEP,EAAU,EAAa,EAAkB,QAE9C,GAAe,EAAS,cACxB,CAAE,QAAO,WAAY,EAAS,KAE9B,EAAO,EAAQ,KAAK,AAAC,GACvB,GAAc,EAAU,UAuErB,CAAE,QApEO,EACV,IAAM,MAEI,GAAuC,MACzC,GAAI,OAEJ,EAAI,EAAQ,QACZ,EAAe,OAAS,IAEpB,GAAc,EAAU,EAAQ,OACjB,KAAK,CAAC,EAAG,EAAQ,QAE/B,QAIL,GACI,EACA,EACA,EACA,GAEJ;AAAA;AAAA,gBACiB,EAAc;AAAA,KACtB,SAAW,GACpB,EAAQ,GAAG,OAAS,UACpB,EAAU,EAAQ,GAAG,SAAW,EAAU,GACpC,GACA,GACI,iBACA,EACA,EACA,EAAQ,SAAW,IAE7B,GAAqB,GAAa,GAAU,EAAM,SAG1D,IAAM,MAEI,GAAuC,MACzC,GAAI,OAEJ,EAAI,EAAQ,QACZ,EAAe,OAAS,MAET,KAAK,CAAC,EAAG,EAAQ,QAC3B,QAIL,GACI,EACA,EACA,EACA,GAEJ;AAAA;AAAA,YACa,EAAc;AAAA,EAC3B,GACI,aACA,EACA,EACA,EAAQ,SAAW,GAEvB,GAAqB,GAAa,GAAU,EAAM,SAI9C,SAGpB,GAA8B,AAAC,GACjC,SAEI,KACG,EACkB,MACf,GAAmB,cACnB,EAA8B,CAChC,MAAO,KAAK,MACZ,QAAS,KAAK,YAEF,EAAU,EAAa,EAAkB,QAEnD,GAAgB,GAAM,GACtB,EAAe,EAAgB,MAAQ,EAAS,cAEhD,EAAQ,EACR,EAAS,MAAM,MAAM,IAAI,AAAC,GAAW,EAAE,MACvC,EAAS,KAAK,MACd,EAAQ,EAAM,OAAS,EAEvB,EAAO,GAAS,GAAK,GAAY,EAAU,EAAM,UAsEhD,CAAE,QApEO,EACV,IAAM,MACI,GAAmC,SACrC,GAAQ,KAEK,KAAK,CAAC,EAAQ,EAAG,EAAM,EAAQ,OAEnC,KAAK,CAAC,EAAO,EAAM,KAG5B,EACI,EACA,EACA,EACA,GAEJ;AAAA;AAAA,gBACiB,GAAkB;AAAA,KAC5B,SAAW,GAClB,EAAU,EAAM,MAAQ,EAAU,GAC5B,GACA,GACI,EACA,EACA,EAAM,SAAW,EACjB,IAEV;AAAA,mBAAsB,EAAc,EAAM,WAGlD,IAAM,MACI,GAAmC,MACrC,GAAS,EAAG,IACR,EAAQ,EAAG,IACP,GAAI,EAAQ,OAET,GAAK,GAAK,CAAC,GAAY,EAAU,EAAM,QACrC,EAEL,EAAI,MACA,EAAQ,KAGH,KAAK,CAAC,EAAG,EAAM,OAGnB,KAAK,CAAC,EAAO,EAAM,WAIhC,GACI,EACA,EACA,EACA,GAEJ;AAAA;AAAA,EACA,GACI,EACA,EACA,GAAS,KAAK,QACd,EAAM,SAAW,EACjB,GAEJ;AAAA,mBAAsB,EAAc,EAAM,WAItC,SAGpB,GAA4B,AAAC,GAC/B,SAEI,EACA,EACqB,MACf,GAAmB,WACnB,EAA8B,CAChC,MAAO,KAAK,MACZ,QAAS,KAAK,YAEP,EAAU,EAAa,EAAkB,QAE9C,GAAe,EAAS,cAExB,CAAE,QAAO,WAAY,EAAS,KAC9B,EAAQ,EAAQ,OAAS,EAEzB,EAAO,GAAS,GAAK,GAAc,EAAU,EAAQ,UA4EpD,CAAE,QA1EO,EACV,IAAM,MACI,GAAuC,SACzC,GAAQ,KAEO,KAAK,CAAC,EAAQ,EAAG,EAAQ,EAAQ,OAErC,KAAK,CAAC,EAAO,EAAQ,KAGhC,EACI,EACA,EACA,EACA,GAEJ;AAAA;AAAA,gBACiB,EAAc;AAAA,KACtB,SAAW,GACpB,EAAQ,GAAG,OAAS,UACpB,EAAU,EAAQ,GAAG,SAAW,EAAU,GACpC,GACA,GACI,iBACA,EACA,EACA,EAAQ,SAAW,EACnB,IAEV,GAAqB,GAAa,GAAU,EAAM,SAG1D,IAAM,MACI,GAAuC,MACzC,GAAS,EAAG,IACR,EAAQ,EAAG,IACP,GAAI,EAAQ,OAGZ,GAAK,GACL,CAAC,GAAc,EAAU,EAAQ,QAE5B,EAEL,EAAI,MACA,EAAQ,KAGD,KAAK,CAAC,EAAG,EAAQ,OAGrB,KAAK,CAAC,EAAO,EAAQ,WAIpC,GACI,EACA,EACA,EACA,GAEJ;AAAA;AAAA,YACa,EAAc;AAAA,EAC3B,GACI,aACA,EACA,EACA,EAAQ,SAAW,EACnB,GAEJ,GAAqB,GAAa,GAAU,EAAM,SAI9C,SAGpB,GAA6B,AAAC,GAChC,SAEI,EACA,KACG,EACkB,MACf,GAAmB,IACnB,EAA8B,CAChC,cAAe,AAAC,GAAgB,EAChC,MAAO,KAAK,MACZ,QAAS,KAAK,QACd,eAAgB,qBAEJ,EAAU,EAAa,EAAkB,GAErD,CAAC,OAAO,cAAc,IAAQ,EAAM,OAC9B,IAAI,OACN,EACI,EACI,EACA,OACA,EACA,GAEJ,GAAG,+BACH,EAAc,EAAkB,EAAK,UAK3C,GAAgB,GAAM,GACtB,EAAe,EAAgB,MAAQ,EAAS,cAEhD,EAAQ,EACR,EAAS,MAAM,MAAM,IAAI,AAAC,GAAW,EAAE,MACvC,EAAS,KAAK,MACd,EAAS,EAAM,OACf,EAAO,EAAM,EAEb,EAAO,EAAO,GAAU,GAAY,EAAU,EAAM,UA0GnD,CAAE,QAxGO,EACV,IAAM,MAGI,GAAmC,SACrC,GAAO,GAAK,KACC,KAAK,CAAC,EAAO,EAAG,EAAM,EAAO,OAEjC,KAAK,CAAC,EAAM,EAAM,KAC3B,EAAO,EAAI,KACE,KAAK,CAAC,EAAO,EAAG,EAAM,EAAO,KAI1C,EACI,EACA,EACA,EACA,GAEJ;AAAA;AAAA,KACM;AAAA,gBACW,GAAkB;AAAA,KAC5B,SAAW,GAClB,EAAU,EAAM,MAAQ,EAAU,GAC5B,GACA,GACI,EACA,EACA,EAAM,SAAW,EACjB,IAEV;AAAA,mBAAsB,EAAc,EAAM,WAGlD,IAAM,MAKI,GAAmC,MACrC,EAAO,EAAQ,IACX,EAAO,GAAK,EAAG,IACX,GAAI,EAAO,OAER,GAAK,GAAK,CAAC,GAAY,EAAU,EAAM,QACrC,EAEL,EAAI,MACA,EAAO,KAGF,KAAK,CAAC,EAAG,EAAM,UAEnB,KAAK,CAAC,EAAM,EAAM,KAC3B,EAAO,EAAI,EAAQ,IACf,GAAI,EAAO,OAGX,EAAI,GACJ,CAAC,GAAY,EAAU,EAAM,QAExB,EAEL,GAAK,MACD,EAAO,KAGF,KAAK,CAAC,EAAG,EAAM,cAEzB,EAAS,EAAG,IAEf,GAAI,EAAS,OAEV,GAAK,GAAK,CAAC,GAAY,EAAU,EAAM,QACrC,EAEL,EAAI,MACA,EAAS,KAGJ,KAAK,CAAC,EAAG,EAAM,WAI5B,GACI,EACA,EACA,EACA,GAEJ;AAAA;AAAA,KACM;AAAA,EACN,GACI,EACA,EACA,GAAS,KAAK,QACd,EAAM,SAAW,EACjB,GAEJ;AAAA,mBAAsB,EAAc,EAAM,WAItC,SAGpB,GAA+B,AAAC,GAClC,SAEI,EACA,EACA,EACqB,MACf,GAAmB,IACnB,EAA8B,CAChC,cAAe,AAAC,GAAgB,EAChC,MAAO,KAAK,MACZ,QAAS,KAAK,QACd,eAAgB,kBAET,EAAU,EAAa,EAAkB,GAEhD,CAAC,OAAO,cAAc,IAAQ,EAAM,OAC9B,IAAI,OACN,EACI,EACI,EACA,OACA,EACA,GAEJ,GAAG,+BACH,EAAc,EAAkB,EAAK,UAK3C,GAAe,EAAS,cACxB,CAAE,QAAO,WAAY,EAAS,KAC9B,EAAS,EAAQ,OACjB,EAAO,EAAM,EAEb,EAAO,EAAO,GAAU,GAAc,EAAU,EAAQ,UAgHvD,CAAE,QA9GO,EACV,IAAM,MAGI,GAAuC,SACzC,GAAO,GAAK,KACG,KAAK,CAAC,EAAO,EAAG,EAAQ,EAAO,OAEnC,KAAK,CAAC,EAAM,EAAQ,KAC/B,EAAO,EAAI,KACI,KAAK,CAAC,EAAO,EAAG,EAAQ,EAAO,KAI9C,EACI,EACA,EACA,EACA,GAEJ;AAAA;AAAA,KACM;AAAA,gBACW,EAAc;AAAA,KACtB,SAAW,GACpB,EAAQ,GAAG,OAAS,UACpB,EAAU,EAAQ,GAAG,SAAW,EAAU,GACpC,GACA,GACI,iBACA,EACA,EACA,EAAQ,SAAW,EACnB,IAEV,GAAqB,GAAa,GAAU,EAAM,SAG1D,IAAM,MAKI,GAAuC,MACzC,EAAO,EAAQ,IACX,EAAO,GAAK,EAAG,IACX,GAAI,EAAO,OAGX,GAAK,GACL,CAAC,GAAc,EAAU,EAAQ,QAE5B,EAEL,EAAI,MACA,EAAO,KAGA,KAAK,CAAC,EAAG,EAAQ,UAErB,KAAK,CAAC,EAAM,EAAQ,KAC/B,EAAO,EAAI,EAAQ,IACf,GAAI,EAAO,OAGX,EAAI,GACJ,CAAC,GAAc,EAAU,EAAQ,QAE5B,EAEL,GAAK,MACD,EAAO,KAGA,KAAK,CAAC,EAAG,EAAQ,cAE7B,EAAS,EAAG,IAEf,GAAI,EAAS,OAEV,GAAK,GAAK,CAAC,GAAc,EAAU,EAAQ,QACzC,EAEL,EAAI,MACA,EAAS,KAGF,KAAK,CAAC,EAAG,EAAQ,WAIhC,GACI,EACA,EACA,EACA,GAEJ;AAAA;AAAA,KACM;AAAA,YACO,EAAc;AAAA,EAC3B,GACI,aACA,EACA,EACA,EAAQ,SAAW,EACnB,GAEJ,GAAqB,GAAa,GAAU,EAAM,SAI9C,SAGpB,GAA8B,CAChC,eAAgB,GAA4B,kBAC5C,iBAAkB,GAA0B,oBAC5C,cAAe,GAA2B,iBAC1C,gBAAiB,GAA6B,mBAC9C,WAAY,GAAwB,cACpC,gBAAiB,GAA6B,mBAC9C,eAAgB,GAA4B,kBAC5C,iBAAkB,GAAwB,oBAC1C,sBAAuB,GACnB,yBAEJ,qBAAsB,GAA4B,wBAClD,yBAA0B,GACtB,4BAEJ,wBAAyB,GACrB,2BAEJ,uBAAwB,GAA0B,0BAClD,sBAAuB,GACnB,yBAEJ,eAAgB,GAAsB,kBACtC,oBAAqB,GAA2B,uBAChD,mBAAoB,GAA0B,sBAC9C,SAAU,GAAsB,YAChC,cAAe,GAA2B,iBAC1C,aAAc,GAA0B,iBAGtC,GAAS,AAAC,GACZ,GAAY,MAAQ,EAAS,kBAAoB,GAE/C,GAAQ,AAAC,GACX,GAAY,MACZ,EAAS,OAAS,MAClB,MAAO,GAAS,MAAM,KAAQ,YAC9B,MAAO,GAAS,MAAM,OAAU,WAE9B,GAAkB,CACpB,EACA,EACA,EACA,IACC,IACG,CAAC,GAAO,IAAa,CAAC,GAAM,QACtB,IAAI,OACN,EACI,EAAY,EAAa,OAAW,EAAkB,GACtD,GAAG,EACC,mDAEJ,EAAc,WAAY,EAAU,MAM9C,GAAa,CACf,EACA,EACA,EACA,IACC,IACG,CAAC,GAAO,QACF,IAAI,OACN,EACI,EAAY,EAAa,OAAW,EAAkB,GACtD,GAAG,EAAe,4CAClB,EAAc,WAAY,EAAU,MC7zC9C,GAAc,eAEd,GAAuB,AAAC,GAC1B,EACK,MAAM;AAAA,GAEN,OAAO,AAAC,GAAS,CAAC,GAAY,KAAK,IACnC,KAAK;AAAA,GACL,YAKI,GAA2B,AACpC,GACqC,IACjC,CAAC,QACM,CAAE,QAAS,GAAI,MAAO,SAO3B,GAAe,EAAQ,MACzB,qEAEA,CAAC,OAEK,IAAI,OAAM,yDAEd,GAAU,GAAqB,EAAa,IAC5C,EAAQ,GAAqB,EAAa,UACzC,CAAE,UAAS,UCDhB,GAAgB,kCAgBhB,GAAY,AAAC,GAAmB,MAC5B,GACF,GAAM,MAA2B,MAAO,GAAE,SAAY,eAGtD,IACA,MAAO,GAAE,MAAS,UAClB,MAAO,GAAE,OAAU,SAEZ,CACH,aACA,QAAS,GACT,QAAS,EAAE,QACX,MAAO,GAIR,CACH,aACA,QAAS,GACT,QAAS,EAAa,EAAE,QAAU,OAAO,GACzC,MAAO,IAIF,GAAgB,CACzB,EACA,IAEA,SAEI,EACA,EACiB,MACX,GAAU,CACZ,MAAO,KAAK,MACZ,QAAS,KAAK,YAGd,GAAS,QAET,GAAe,GAAQ,KACd,GAAU,WAEf,MAAO,IAAa,eAChB,CAAC,EAAa,MACR,GACF,IAAa,OAAY,GAAK,gBAC5B,IAAI,OACN,EACI,EACI,EACA,OACA,EACA,GAEJ,GAAG,EACC,uCAEJ,EAAc,WAAY,EAAU,cAK5C,WAEK,KACI,GAAU,MAK3B,IAAa,aACN,IAAQ,EAAa,EAAS,MAC9B,MAAO,IAAa,iBACpB,IAAqB,EAAa,EAAS,EAAQ,MACnD,MAAO,IAAa,eACpB,IACH,EACA,EACA,EACA,MAEG,IAAa,MAAQ,MAAO,GAAS,MAAS,iBAC9C,IACH,EACA,EACA,EACA,MAGJ,IAAa,MACb,MAAO,GAAS,iBAAoB,iBAE7B,IACH,EACA,EACA,EACA,MAEG,IAAa,MAAQ,MAAO,IAAa,eACzC,IACH,EACA,EACA,EACA,QAGE,IAAI,OACN,EACI,EAAY,EAAa,OAAW,OAAW,GAC/C,GAAG,EACC,6EAEJ,EAAc,WAAY,EAAU,MAMlD,GAA2B,CAC7B,QAAS,GAAc,WACvB,aAAc,GAAc,iBAG1B,GAAwB,CAC1B,EACA,EACA,EACA,IACwB,MAClB,GAAO,IAAW,MAAQ,EAAS,KAAK,EAAO,eA0B9C,CAAE,QAxBO,EACV,IACI,EAAY,EAAa,OAAW,OAAW,GAC/C;AAAA;AAAA,EACA,GAAe,yBAA0B,QAC7B,MAAQ,EAAO,WACrB,EACI,yBACA,EACA,UACA,GACA,GAAY,GAChB,EAAe,yBAA0B,EAAQ,UAC3D,IACI,EAAY,EAAa,OAAW,OAAW,GAC/C;AAAA;AAAA,EACA,GAAe,qBAAsB,QACzB,KACN;AAAA,EAAO,GACP,EAAO,WACP,EAAe,qBAAsB,EAAQ,WAC7C,GAAY,GACZ,EAAe,qBAAsB,EAAQ,UAE3C,SAOhB,GAA4B,CAC9B,EACA,EACA,EACA,IACwB,MAClB,GAAO,IAAW,MAAQ,EAAS,gBAAgB,EAAO,aA0BzD,CAAE,QAxBO,EACV,IACI,EAAY,EAAa,OAAW,OAAW,GAC/C;AAAA;AAAA,EACA,GAAe,oCAAqC,GACpD;AAAA,OACY,MAAQ,EAAO,WACrB,EAAe,qBAAsB,EAAQ,QAC7C,EAAe,qBAAsB,EAAQ,WAC7C,GAAY,GACZ,EAAe,iBAAkB,EAAQ,UACnD,IACI,EAAY,EAAa,OAAW,OAAW,GAC/C;AAAA;AAAA,EACA,GAAe,gCAAiC,GAChD;AAAA,OACY,KACN,GACA,EAAO,WACP,EAAe,qBAAsB,EAAQ,QAC7C,EAAe,qBAAsB,EAAQ,WAC7C,GAAY,GACZ,EAAe,iBAAkB,EAAQ,UAEvC,SAGhB,GAAwB,CAC1B,EACA,EACA,EACA,IACwB,MAClB,GAAO,IAAW,MAAQ,EAAO,UAAY,EAAS,cA8BrD,CAAE,QA5BO,EACV,IACI,EAAY,EAAa,OAAW,OAAW,GAC/C;AAAA;AAAA,EACA,GAAe,yBAA0B,EAAS,cACtC,MAAQ,EAAO,WACrB,GAAY,GACZ,EAAe,yBAA0B,EAAQ,UAC3D,IACI,EAAY,EAAa,OAAW,OAAW,GAC/C;AAAA;AAAA,OACY,KACN,GAAe,qBAAsB,EAAS,SAC9C;AAAA,EACA,GACA,EAAO,WACP,GACI,EAAS,QACT,EAAO,QACP,mBACA,mBACA,IAEJ;AAAA,EACA,GAAY,GACZ,GAAe,qBAAsB,EAAS,SAC9C,EAAe,qBAAsB,EAAQ,UAE3C,SAGhB,GAAuB,CACzB,EACA,EACA,EACA,IACwB,MAClB,GAAO,IAAW,MAAQ,EAAO,gBAAiB,SA+CjD,CAAE,QA7CO,EACV,IACI,EAAY,EAAa,OAAW,OAAW,GAC/C;AAAA;AAAA,EACA,GACI,uBACA,QAEQ,MACZ,EAAO,OAAS,MAChB,MAAO,GAAO,MAAM,aAAgB,YACpC,EAAO,MAAM,cAAgB,EACvB,GACI,uBACA,EAAO,MAAM,YACb,GAEJ,IACN;AAAA,OACY,MAAQ,EAAO,WACrB,EAAe,qBAAsB,EAAQ,WAC7C,GAAY,GACZ,EAAe,mBAAoB,EAAQ,UACrD,IACI,EAAY,EAAa,OAAW,OAAW,GAC/C;AAAA;AAAA,EACA,GAA6B,uBAAwB,QACzC,KACN;AAAA,EAAO,MACC,OAAS,MACjB,MAAO,GAAO,MAAM,aAAgB,WAC9B,GACI,uBACA,EAAO,MAAM,aAEjB,IACN;AAAA,KACQ,WACF,EACI,qBACA,EACA,WACA,GAAY,GAChB,EAAe,mBAAoB,EAAQ,WAE/C,SAGhB,GAAwB,CAC1B,EACA,EACA,EACA,IACwB,MAClB,GAAO,IAAW,MAAQ,EAAO,QAAQ,SAAS,SA0BjD,CAAE,QAxBO,EACV,IACI,EAAY,EAAa,OAAW,OAAW,GAC/C;AAAA;AAAA,EACA,GAAe,2BAA4B,QAC/B,MAAQ,EAAO,WACrB,EACI,2BACA,EACA,UACA,GACA,GAAY,GAChB,EAAe,2BAA4B,EAAQ,UAC7D,IACI,EAAY,EAAa,OAAW,OAAW,GAC/C;AAAA;AAAA,EACA,GAAe,uBAAwB,QAC3B,KACN;AAAA,EAAO,GACP,EAAO,WACP,EAAe,uBAAwB,EAAQ,WAC/C,GAAY,GACZ,EAAe,uBAAwB,EAAQ,UAE7C,SAGhB,GAAU,CACZ,EACA,EACA,IACwB,MAClB,GAAO,IAAW,WAgBjB,CAAE,QAdO,EACV,IACI,EAAY,EAAa,OAAW,GAAI,GACxC;AAAA;AAAA,OACY,MAAQ,EAAO,WACrB,EAAe,kBAAmB,EAAQ,QAC1C,EAAe,kBAAmB,EAAQ,WAC1C,GAAY,GACZ,EAAe,iBAAkB,EAAQ,UACnD,IACI,EAAY,EAAa,OAAW,GAAI,GACxC;AAAA;AAAA,EACA,GAEQ,SAGhB,GAAiB,CAAC,EAAe,IACnC,EAAQ,EAAc,GAAY;AAAA,EAEhC,EAAiB,CACnB,EACA,EACA,EACA,IACC,IACG,IAAW,WACJ,MAGP,IAAQ,UAAW,MACb,GAAU,EAAO,WAEnB,MAAO,IAAa,SAAU,MACxB,GAAQ,EAAQ,QAAQ,MAC1B,IAAU,SAEN,GACA,GACI,EACA,EACA,EAAS,QAEb;AAAA,UAGD,YAAoB,cAEvB,GACA,GACI,EACA,MAAO,GAAS,MAAS,WACnB,EAAS,KAAK,GACd,MAEV;AAAA,QAID,GAAQ,EAAc,GAAW;AAAA,QAGxC,KAAQ,OACD,EAAO,QACR,EAAQ,EAAc,EAAO,MAAM,MAAQ;AAAA,EAC3C,GAGN,IAAQ,QACD,EAAO,QAAU,GAAK,EAAQ,EAAc,EAAO,OAAS;AAAA,EAGhE,IAGL,GAAc,AAAC,GACjB,IAAW,MAAQ,CAAC,EAAO,QACrB,GACA,GAAyB,EAAO,MAAM,OAAQ,MClaxD,gBAAiC,MAAM,EAMvC,KAAM,IAAY,AAAgB,GAC9B,CAAC,CAAC,UACM,IAAQ,UAAY,MAAO,IAAQ,aAC3C,MAAO,GAAI,MAAS,WAElB,GAA4C,SAC9C,EACF,OACS,UAEH,EACA,EACF,OACS,GAAQ,MAAM,KAAM,CAAC,EAAU,EAA0B,OAIlE,GAAoB,CAAC,EAAc,IACjC,IAAS,WAAa,IAAS,eACxBE,GAAmB,EAAM,IAEhC,IAAS,gCACT,IAAS,qCAEF,GAA0C,GAG9C,KAGL,EAAc,CAAC,KAAgB,IAAqB,IAClD,EAAK,SAAW,OACV,IAAI,OAAM,2CAGd,GAAc,KACd,EAAmB,CACrB,IAAK,GACL,QAAS,CAAE,IAAK,IAChB,SAAU,CAAE,IAAK,KAGf,EAAM,GAAI,kBAET,KAAK,GAAa,QAAQ,AAAC,GAAS,MACjC,GAAU,EAAY,GACtB,EAAiB,GAAkB,EAAM,IAAY,IAC/C,GAAQ,GAAoB,EAAS,GAAO,GAAI,KAChD,IAAI,GAAQ,GAAoB,EAAS,GAAM,GAAI,KAEnD,SAAS,GAAQ,GACzB,EACA,EACA,GACA,EACA,KAEQ,SAAS,IAAI,GAAQ,GAC7B,EACA,EACA,GACA,EACA,KAGQ,QAAQ,GAAQ,GACxB,EACA,EACA,GACA,EACA,KAEQ,QAAQ,IAAI,GAAQ,GAC5B,EACA,EACA,GACA,EACA,KAID,GAGL,GAAa,AAAC,GACf,GAAW,KACZC,EAA4B,8CAE1B,GACF,CACI,EACA,EACA,EACA,EACA,IAEJ,IAAI,IAAS,MACH,GAAU,CACZ,QACA,QAAS,eAGT,CAAC,GAAU,QACL,IAAI,IACNC,EACIC,EACI,EACA,OACA,GACA,GAEJ,GAAGF,EACC,sCAEJG,EACI,WACA,EACAC,UAMV,GAAW,GAAI,UAEd,GAAO,KACV,AAAC,GACG,GACI,EACA,EACA,WACA,EACA,GACF,MAAM,KAAM,GAClB,AAAC,MACY,QACLF,EACI,EACA,OACA,GACA,GAEJ;AAAA;AAAA;AAAA,qBAEsBE,EAA2B,KAC9C,QAAQ,OAAO,MAKhC,GACF,CACI,EACA,EACA,EACA,EACA,IAEJ,IAAI,IAAS,MACH,GAAU,CACZ,QACA,QAAS,WAGP,EACF,MAAO,IAAW,WAAa,IAAW,KAE1C,CAAC,GAAU,QACL,IAAI,IACNH,EACIC,EACI,EACA,OACA,GACA,GAEJ,GAAGF,EACC,wEAEJG,EACI,WACA,EACAC,UAMV,GAAW,GAAI,UAEd,GAAc,KACjB,AAAC,MACY,QACLF,EACI,EACA,OACA,GACA,GAEJ;AAAA;AAAA;AAAA,qBAEsBE,EAA2B,KAC9C,QAAQ,OAAO,IAE1B,AAAC,GACG,GACI,EACA,EACA,UACA,EACA,GACF,MAAM,KAAM,KAIxB,GAAsB,CACxB,EACA,EACA,EACA,EACA,IAEA,cAA4B,EAAW,IAC/B,GAAS,QACP,GAAQ,SAAK,IAAL,CAAmB,mBAAkB,oBAE7C,EAAmC,OAMrC,UAAW,IAAO,EAAS,IACxB,MAPkC,CAQrC,SACA,MAAO,EACP,QACA,UACA,UAGE,EAAgB,CAClB,EACA,IACC,OACe,QAEL,iBAEN,EAAO,MAAQ,GAAW,CAAC,EAAO,MAAQ,CAAC,EAAQ,MAE9C,GAAU,GAAW,EAAO,YAC9B,MAEA,KACQ,IACF,QAAU,GACT,KACC,IACF,QAAU,MAER,GAAI,IAAmB,GAI3B,MAAM,yBACA,kBAAkB,EAAO,MAMjC,cAAgB,SAAK,GAAL,CAAa,YAE/B,OACM,QAEK,iBAAiB,KAAK,KAKvC,EAAc,AAAC,GAAiB,MAE9B,GAAQ,MAA2B,IACnC,cAAmB,MACnB,EAAM,OAAS,2BAEf,MAAM,yBAGA,kBAAkB,EAAO,GAE7B,MAGN,MAEA,MAEI,EAAQ,MAA2B,GAC7B,EAAQ,KAAK,EAAgB,EAAQ,GAAG,GAIvC,UAAqC,OAC3B,GAAQ,KAAK,EAAgB,EAAQ,GAAG,MAGzD,GAAU,GAAkB,MACtB,GAAc,EACd,EAAa,GAAI,UACnB,OAAM,yBACA,kBAAkB,EAAY,GAGjC,EACF,KAAK,AAAC,GAAY,EAAc,EAAS,IACzC,MAAM,cAIJ,GAFY,SAIlB,SACE,GAAY,KAI/B,EAAO,OAAS,AACZ,GACO,GAAY,EAAU,GAAO,GAExC,EAAO,SAAW,GAClB,EAAO,IAAM,GAEb,EAAO,IAAM,CACT,gBAAiB,GACjB,iBAAkB,GAClB,iBAAkB,GAClB,eAAgB,IAGpB,EAAO,iBAAmB,GAC1B,EAAO,gBAAkB,GACzB,EAAO,iBAAmB,GAC1B,EAAO,eAAiB,GAExB,KAAM,IAAkB,AAAC,GAAgB,IAEjC,MAAO,IAAW,UAClB,MAAO,GAAO,MAAS,WACtB,EAAO,SACJ,MAAO,GAAO,SAAY,UAC1B,MAAO,GAAO,SAAY,gBAExB,IAAI,OACN;AAAA;AAAA;AAAA,GAIQC,EAAuB,qBAK3C,YAAoB,EAAkB,MAC5B,GAAQ,GAAI,OACd,MAAM,yBACA,kBAAkB,EAAO,OAG1B,CACL,yBAA0B,EAC1B,8BAA+B,IAGvC,eAA0B,EAAkB,MAClC,GAAQ,GAAI,OACd,MAAM,yBACA,kBAAkB,EAAO,OAGL,EAAK,GAAI,qBAC9B,CACL,sBAAuB,GACvB,2BAA4B,IAKpC,GAAYP,GAAU,GAAM,GAC5B,GAAY,GAAa,GAAM,GAC/B,GAAYQ,GAAiB,GAAM,GAEnC,EAAO,sBAAyB,OAChC,EAAO,WAAa,GACpB,EAAO,cAAgB,GACvB,EAAO,SAAW,GAClB,EAAO,SAAW,GAClB,EAAO,gCAAkC,GAEzC,KAAM,IAAe,EC7EO,GAAI,KAAK,IAypBrC,KAAM,IAAuB,SAAU,EAAgB,EAAiB,IAChE,GAAa,IAAU,GAAa,aAC7B,GAAe,IAAQ,QAAQ,GAAe,IAC9C,IAKfC,GAAO,OAAO,CACV,QAAQ,EAAmB,EAAmB,MAGpC,GAAc,UACd,EAAU,CACZ,QAAS,gBACT,MAAO,KAAK,MACZ,QAAS,KAAK,SAGZ,EAAO,KAAK,OAAO,EAAU,EAAU,CACzC,GACA,UAoCG,CAAE,OAAQ,EAAU,WAAU,QAjCrB,EACV,IACI,KAAK,MAAM,YACP,EACA,OACA,OACA,GAEJ;AAAA;AAAA,gBACiB,KAAK,MAAM,cAAc;AAAA,QACpC,MAAM,UAAU,KACtB,KAAK,MAAM,UAAU,GACf,iBAAiB,KAAK,MAAM,cAAc,KAC1C,IACV,IACI,KAAK,MAAM,YACP,EACA,OACA,OACA,GAEJ;AAAA;AAAA,EACA,KAAK,MAAM,qBACP,EACA,EACA,WACA,WACA,KAAK,SAAW,IAMgB,KAAM,EAAa,WAIzE,YAAwB,EAAU,UAC1B,GAAI,CACJ,GAAI,EAAI,GACR,MAAO,EAAI,MACX,KACI,MAAO,GAAI,KAAK,QAAW,WACrB,EAAI,KAAK,SACT,EAAI,MAGd,EAAQ,GAAa,GACnB,EAAI,MACJC,qBAAU,KAAI,QAAJ,OAAa,UACzB,QAAO,KAAK,GAAO,OAAS,MAC1B,MAAQ,GAEP,uMChmCX,oBAAqC,EAAI,GAAzCC,OADCC,GACDD,ICJA,GAAIE,IAAS,UAAY,CAAC,GAAI,GAAI,KAAS,EAAG,EAAI,eAAmB,EAAG,EAAI,MAAM,IAAI,EAAG,MAAO,GAAG,MAAM,CAAC,YAAY,WAAW,CAAC,EAAI,GAAG,4BACrIC,GAAkB,6jCCUtB,oBAAqC,EAAI,IAWjC,WAAoB,OACb,IAAS,KAAK,OAGzB,gBAAiB,MACR,MAAM,WAGf,SAAU,MACA,GAAgB,SAAS,gBAC3B,6BACA,eAEC,YAAc,YAAyB,cAvBzBC,IAAtB,EAAK,CAAE,QAAS,MAAMC,GAAA,sBACDD,IAArB,EAAK,CAAE,QAAS,KAAKC,GAAA,wBACGD,IAAxB,EAAK,CAAE,QAAS,QAAQC,GAAA,qBACCD,IAAzB,EAAK,CAAE,QAAS,MAASC,GAAA,oBAChBD,IAAT,EAAK,KAAIC,GAAA,uBACoBD,IAA7B,EAAK,CAAE,QAAS,aAAaC,GAAA,2BACcD,IAA3C,EAAK,CAAE,QAAS,2BAA2BC,GAAA,0BAPhDA,OALCJ,EAAU,CACP,WAAY,CACR,QAAS,OAGjBI,ICXA,GAAIH,IAAS,UAAY,CAAC,GAAI,GAAI,KAAS,EAAG,EAAI,eAAmB,EAAG,EAAI,MAAM,IAAI,EAAG,MAAO,GAAG,MAAM,CAAC,EAAG,YAAY,CAAC,MAAM,CAAC,gBAAgB,GAAM,4BAA4B,GAAM,kBAAkB,GAAM,cAAc,GAAK,YAAY,EAAI,OAAO,CAAE,AAAC,EAAI,SAA+Z,EAAG,MAAM,CAAC,YAAY,iBAAiB,CAAC,EAAG,MAAM,CAAC,YAAY,2CAA2C,CAAC,EAAG,KAAK,CAAC,EAAI,GAAG,EAAI,GAAG,EAAI,eAAe,EAAG,IAAI,CAAC,EAAI,GAAG,EAAI,GAAG,EAAI,YAAY,EAAG,YAAY,CAAC,GAAG,CAAC,MAAQ,EAAI,iBAAiB,CAAC,EAAI,GAAG,EAAI,GAAG,EAAI,iBAAiB,GAApqB,EAAG,MAAM,CAAC,YAAY,kBAAkB,CAAC,EAAG,MAAM,CAAC,YAAY,wBAAwB,CAAC,EAAG,MAAM,CAAC,YAAY,oBAAoB,CAAE,EAAI,YAAa,EAAG,sBAAsB,CAAC,MAAM,CAAC,UAAU,gBAAgB,cAAc,GAAG,YAAY,KAAK,EAAI,MAAM,KAAK,EAAG,kBAAkB,CAAC,MAAM,CAAC,UAAU,cAAc,WAAW,EAAI,YAAY,EAAG,MAAM,CAAC,YAAY,WAAW,CAAC,EAAI,GAAG,EAAI,GAAG,EAAI,aAAa,MAAwR,IACl7BC,GAAkB,kVCItB,oBAAqC,EAAI,IAKjC,WAAW,OACJ,SAAS,KAAK,SALCC,IAAzB,EAAK,CAAE,SAAU,MAAQE,GAAA,oBACCF,IAA1B,EAAK,CAAE,SAAU,MAASE,GAAA,qBACAF,IAA1B,EAAK,CAAE,SAAU,MAASE,GAAA,sBAH/BA,OADCL,EAAU,KACXK,ICLA,GAAIJ,IAAS,UAAY,CAAC,GAAI,GAAI,KAAS,EAAG,EAAI,eAAmB,EAAG,EAAI,MAAM,IAAI,EAAG,MAAO,GAAG,MAAM,CAAC,EAAG,MAAM,CAAC,MAAM,CAAC,KAAO,EAAI,SAAS,MAAQ,EAAI,MAAM,OAAS,EAAI,aAC1KC,GAAkB,4UCMtB,SAAS,MAAQ,SAAS,SAO1B,oBAAqC,EAAI,IAGjC,QAAQ,OACD,UAAS,SAGpB,SAAU,MACD,WAAa,KACN,WAAW,UAAU,AAAC,GAAU,MACnC,WAAa,EAAY,oBAIhC,SAAS,MACL,GAAY,cACb,QAAQ,KAAK,CAAE,KAAM,YAhBlCI,OALCN,EAAU,CACP,WAAY,CACR,WAAY,OAGpBM,ICdA,GAAIL,IAAS,UAAY,CAAC,GAAI,GAAI,KAAS,EAAG,EAAI,eAAmB,EAAG,EAAI,MAAM,IAAI,EAAG,MAAO,GAAG,MAAM,CAAC,MAAM,CAAC,GAAK,QAAQ,CAAC,EAAG,aAAa,CAAC,EAAG,IAAI,CAAC,YAAY,sBAAsB,YAAY,CAAC,KAAO,KAAK,MAAM,CAAC,KAAO,MAAM,CAAC,EAAG,WAAW,CAAC,YAAY,YAAY,MAAM,CAAC,KAAO,qBAAqB,EAAG,SAAS,CAAC,EAAI,GAAG,EAAI,GAAG,EAAI,WAAW,GAAI,EAAI,WAAY,EAAG,YAAY,CAAC,GAAG,CAAC,MAAQ,EAAI,SAAS,CAAC,EAAI,GAAG,YAAY,EAAI,MAAM,GAAG,EAAG,gBAAgB,IACzcC,GAAkB,4UCMtB,KAAM,IAAoB,kCAO1B,oBAAwC,EAAI,CAA5C,aAdA,oCAkBwB,qBAKI,sBAKC,MAErB,YAAqB,OACd,CAAC,CAAC,KAAK,UAKlB,SAAU,MACD,aAAe,QACf,UAAY,QACZ,WAAa,KAAK,WAAW,KAAK,MAG3C,SAAU,MACD,KAAO,GAAI,WAET,iBAAiB,UAAW,KAAK,WAAY,SAE/C,KAAK,IAAI,IAAM,QACT,oBAAoB,UAAW,KAAK,cAInD,cAAe,MACN,aAAe,QACf,cAAgB,QAGX,YAAW,EAAqB,IACtC,EAAM,SAAW,KAAK,oBAItB,GAAY,EAAM,UAEjB,cAAgB,WACb,IAAI,2BAA4B,MAEpC,GAAsB,aAClB,IAAI,2CAER,MACM,GAAW,KAAM,IAAM,KACzB,uCACA,CACI,MAAO,EACP,MAAO,yBAKX,EAAS,MACT,EAAS,KAAK,SACd,EAAS,KAAK,QAAQ,OAAS,MAEjB,EAAS,KAAK,QAAQ,WAC5B,IAAI,6BAA8B,UAEzC,WACG,KAAK,sCAAuC,QAGnD,cAAgB,QAEhB,MAAM,eAAgB,CACvB,IAAK,EACL,OAAQ,MAhFRC,IAAP,KAAO,GAAA,yBACiBA,IAAxB,EAAK,CAAE,QAAS,QAAQ,GAAA,sBAF7B,OALCH,EAAU,CACP,WAAY,CACR,QAAS,OAGjB,ICdA,GAAIC,IAAS,UAAY,CAAC,GAAI,GAAI,KAAS,EAAG,EAAI,eAAmB,EAAG,EAAI,MAAM,IAAI,EAAG,MAAO,GAAG,MAAM,CAAE,EAAI,UAAW,EAAG,MAAM,CAAC,EAAG,KAAK,CAAC,EAAI,GAAG,YAAY,EAAG,IAAI,CAAC,EAAI,GAAG,uBAAuB,EAAI,GAAG,EAAI,cAAe,EAAI,OAAQ,EAAG,MAAM,CAAC,YAAY,aAAa,MAAM,CAAC,IAAM,EAAI,UAAU,EAAI,OAAO,EAAI,KAAK,EAAG,YAAY,CAAC,GAAG,CAAC,MAAQ,SAAS,EAAO,CAAC,MAAO,GAAI,kBAAkB,CAAC,EAAI,GAAG,IAAI,EAAI,GAAG,EAAI,UAAY,gBAAkB,iBAAiB,OAAO,EAAG,YAAY,CAAC,YAAY,gBAAgB,MAAM,CAAC,YAAY,EAAI,cAAc,GAAG,CAAC,kBAAkB,SAAS,EAAO,CAAC,EAAI,aAAa,GAAQ,mBAAmB,SAAS,EAAO,CAAC,EAAI,aAAa,KAAU,CAAC,EAAG,oBAAoB,CAAE,EAAI,cAAe,EAAG,sBAAsB,CAAC,MAAM,CAAC,UAAU,gBAAgB,cAAc,GAAG,YAAY,KAAK,EAAI,KAAM,AAAC,EAAI,cAA0D,EAAI,KAA/C,EAAG,SAAS,CAAC,MAAM,CAAC,IAAM,EAAI,cAAuB,IAAI,IAAI,IACt4BC,GAAkB,kVCMtB,oBAA6C,EAAI,GACrCC,IAAP,KAAOI,GAAA,uBADZA,OAHCP,EAAU,CACP,WAAY,MAEhBO,ICPA,GAAIN,IAAS,UAAY,CAAC,GAAI,GAAI,KAAS,EAAG,EAAI,eAAmB,EAAG,EAAI,MAAM,IAAI,EAAG,MAAQ,GAAI,QAAQ,eAAgB,EAAG,OAAO,CAAC,EAAG,aAAa,CAAC,EAAI,GAAG,EAAI,GAAG,EAAI,QAAQ,cAAe,EAAI,QAAQ,eAAgB,EAAG,UAAU,CAAC,EAAI,GAAG,mBAAmB,EAAI,KAAK,EAAI,GAAG,2BAA2B,GAAG,EAAG,OAAO,CAAC,EAAI,GAAG,IAAI,EAAI,GAAG,EAAI,QAAQ,WAAW,QACpWC,GAAkB,kVCOtB,oBAA0C,EAAI,IAGtC,eAAe,OAER,AADM,IAAS,WAAW,KAAK,QAC1B,gBAGZ,aAAa,OAEN,AADM,IAAS,WAAW,KAAK,QAC1B,eAAe,GAAS,iBAThCC,IAAP,KAAOK,GAAA,sBADZA,OAHCR,EAAU,CACP,WAAY,MAEhBQ,ICRA,GAAIP,IAAS,UAAY,CAAC,GAAI,GAAI,KAAS,EAAG,EAAI,eAAmB,EAAG,EAAI,MAAM,IAAI,EAAG,MAAO,GAAG,OAAO,CAAC,EAAG,aAAa,CAAC,EAAI,GAAG,EAAI,GAAG,EAAI,eAAe,EAAI,GAAG,IAAI,EAAI,GAAG,EAAI,cAAc,MAAM,IACnMC,GAAkB,kVCkBtB,oBAA0C,EAAI,CAA9C,aAnBA,mCAsBgC,gBACT,qCAEqB,GAExC,SAAU,MACD,SAAW,QACX,QAAU,QACV,6BAA+B,GAGxC,SAAU,MACD,KAAO,EAAY,WACnB,KACG,GAAI,AAAC,GAAU,CACP,QACK,mBAIhB,YAGT,eAAgB,eACP,eAAM,mBAGT,eAAc,EAAwB,MAClC,GACF,EAAQ,SAAW,EAAY,QAC/B,EAAQ,YAAc,EAAY,UAMlC,AALW,MAAM,GAAY,cAC7B,EAAQ,OACR,EAAQ,YAGD,eACF,gBAED,QACK,QAAQ,KAAK,CAAE,KAAM,WAKtC,0BAA2B,MAClB,6BAA+B,GAGxC,yBAA0B,MACjB,6BAA+B,QAGlC,oBAAoB,CAElB,AADW,MAAM,GAAY,qBACtB,cACF,QAAQ,KAAK,CAAE,KAAM,eAIpB,gBAAgB,MACrB,QAAU,QACT,GAAM,KAAK,SACb,IACI,GAAmB,GACnB,EAAa,KACb,EAAiB,KAClB,GACkB,QACX,GAAS,KAAM,GAAY,aAAa,UAErC,KAAW,GACZ,EAAQ,aAAe,MACN,KAAK,KACL,IAGjB,EAAC,GAAc,EAAQ,aAAe,OACzB,EAAQ,oBAGxB,QAEJ,SAAWO,kBAAO,EAAkB,AAAC,GACtC,EAAE,aAAe,EAAE,aAAe,CAAC,EAAE,oBAEpC,WACG,MAAM,0CAA2C,QACpD,SAAW,gBAEX,QAAU,MA7F3B,OANCT,EAAU,CACP,WAAY,CACR,mBAAoB,GACpB,gBAAiB,OAGzB,ICnBA,GAAIC,IAAS,UAAY,CAAC,GAAI,GAAI,KAAS,EAAG,EAAI,eAAmB,EAAG,EAAI,MAAM,IAAI,EAAG,MAAO,GAAG,MAAM,CAAC,EAAG,MAAM,CAAC,YAAY,kBAAkB,CAAC,EAAG,KAAK,CAAC,YAAY,YAAY,CAAC,EAAI,GAAG,cAAc,EAAG,UAAU,CAAC,MAAM,CAAC,mBAAmB,KAAK,CAAC,EAAG,YAAY,CAAC,YAAY,iBAAiB,MAAM,CAAC,kBAAkB,KAAK,CAAC,EAAG,UAAU,CAAC,EAAI,GAAG,eAAe,EAAG,OAAO,CAAC,YAAY,WAAW,CAAC,EAAI,GAAG,yBAAyB,EAAG,aAAa,CAAC,EAAI,GAAG,0BAA0B,GAAG,EAAG,kBAAkB,CAAC,EAAG,eAAe,CAAC,GAAG,CAAC,MAAQ,SAAS,EAAO,CAAC,MAAO,GAAI,8BAA8B,CAAC,EAAI,GAAG,0BAA0B,IAAI,IAAI,GAAG,EAAG,MAAM,CAAC,EAAG,WAAW,CAAC,EAAG,eAAe,CAAC,EAAG,gBAAgB,CAAC,EAAI,GAAG,QAAQ,EAAG,gBAAgB,CAAC,EAAI,GAAG,cAAc,EAAG,gBAAgB,CAAC,EAAI,GAAG,YAAY,EAAG,gBAAgB,CAAC,EAAI,GAAG,cAAc,GAAG,EAAI,GAAI,EAAI,SAAU,SAAS,EAAQ,CAAC,MAAO,GAAG,eAAe,CAAC,IAAI,EAAQ,WAAW,CAAC,EAAG,gBAAgB,CAAC,EAAI,GAAG,EAAI,GAAG,EAAQ,UAAU,UAAU,EAAG,OAAO,EAAG,gBAAgB,CAAC,EAAG,mBAAmB,CAAC,MAAM,CAAC,QAAU,MAAY,GAAG,EAAG,gBAAgB,CAAE,EAAQ,aAAc,EAAG,OAAO,CAAC,EAAI,GAAG,YAAY,EAAG,gBAAgB,CAAC,MAAM,CAAC,OAAS,EAAQ,iBAAiB,GAAG,EAAG,OAAO,CAAC,EAAI,GAAG,YAAY,EAAG,gBAAgB,CAAC,MAAM,CAAC,OAAS,EAAQ,iBAAiB,KAAK,EAAG,gBAAgB,CAAC,EAAG,gBAAgB,CAAC,MAAM,CAAC,OAAS,EAAQ,kBAAkB,GAAG,EAAG,gBAAgB,CAAC,EAAG,UAAU,CAAC,MAAM,CAAC,mBAAmB,KAAK,CAAE,AAAC,EAAQ,aAA8O,EAAI,KAApO,EAAG,YAAY,CAAC,YAAY,iBAAiB,MAAM,CAAC,kBAAkB,KAAK,CAAC,EAAG,UAAU,CAAC,EAAI,GAAG,eAAe,EAAG,OAAO,CAAC,YAAY,WAAW,CAAC,EAAI,GAAG,qBAAqB,EAAG,aAAa,CAAC,EAAI,GAAG,sBAAsB,GAAY,EAAG,kBAAkB,CAAC,EAAG,eAAe,CAAC,GAAG,CAAC,MAAQ,SAAS,EAAO,CAAC,MAAO,GAAI,cAAc,MAAY,CAAC,EAAI,GAAG,qBAAqB,IAAI,IAAI,IAAI,MAAM,IAAI,GAAG,EAAG,oBAAoB,CAAC,MAAM,CAAC,YAAY,EAAI,6BAA6B,WAAW,uBAAuB,aAAa,gGAAgG,kBAAkB,SAAS,iBAAiB,UAAU,GAAG,CAAC,kBAAkB,SAAS,EAAO,CAAC,EAAI,6BAA6B,GAAQ,mBAAmB,SAAS,EAAO,CAAC,EAAI,6BAA6B,GAAQ,YAAY,EAAI,wBAAwB,aAAa,EAAI,sBAAsB,IAC/0EC,GAAkB,kVCetB,oBAAsC,EAAI,CAA1C,aAhBA,mCAiB6B,wBACD,uBACD,wBACC,4BACI,oCACQ,mBAEhB,gBACD,GAInB,SAAU,MACD,SAAW,UACX,SAAW,QACX,QAAU,QAEV,gBAAkB,KAAK,gBAAgB,KAAK,WAC5C,gBAAkBQ,oBAAS,KAAK,gBAAiB,KAG1D,SAAU,MACD,KAAO,EAAY,WAAW,UAAU,AAAC,GAAU,MAC/C,cAAgB,EAAY,WAC5B,aAAe,EAAY,UAC3B,kBAAoB,EAAY,eAChC,0BAA4B,EAAY,uBACxC,cAAgB,EAAY,WAC5B,SAAW,CACZ,MAAO,EAAY,MACnB,UAAW,EAAY,UACvB,kBAAmB,EAAY,kBAC/B,KAAM,EAAY,KAClB,MAAO,EAAY,SAK/B,eAAgB,eACP,eAAM,cAGf,WAAY,GAEI,YAAY,KAAK,SAAS,OAI1C,YAAa,CACL,KAAK,eAAiB,KAAK,SAAS,YAGnC,SAAW,QACX,QAAU,QACV,mBAGT,aAAa,EAAyC,MAC7C,SAAS,UAAY,EAAO,SAC5B,SAAS,kBAAoB,EAAO,OAErC,OAAK,oBAAsB,KAAK,SAAS,WACzC,KAAK,4BAA8B,KAAK,SAAS,0BAIhD,SAAW,QACX,QAAU,QACV,wBAGK,kBAAkB,IACxB,GAAoC,GACpC,EAAY,GACZ,KAAK,eAAiB,KAAK,SAAS,SACxB,KAAO,KAAK,SAAS,OACrB,IAGZ,KAAK,oBAAsB,KAAK,SAAS,cAC7B,UAAY,KAAK,SAAS,YAC1B,IAIZ,KAAK,4BAA8B,KAAK,SAAS,sBAErC,kBAAoB,KAAK,SAAS,oBAClC,IAGZ,QACM,GAAY,eAAe,QAGhC,SAAW,GAEZ,SACK,QAAU,MAlDvBP,IADC,GAAM,kBACPQ,GAAA,0BAjDJA,OANCX,EAAU,CACP,WAAY,CACR,OAAQ,GACR,SAAU,OAGlBW,IChBA,GAAIV,IAAS,UAAY,CAAC,GAAI,GAAI,KAAS,EAAG,EAAI,eAAmB,EAAG,EAAI,MAAM,IAAI,EAAG,MAAO,GAAG,MAAM,CAAC,EAAG,MAAM,CAAC,YAAY,kBAAkB,CAAE,EAAI,SAAU,EAAG,MAAM,CAAC,EAAG,MAAM,CAAC,EAAG,WAAW,CAAC,EAAG,QAAQ,CAAC,MAAM,CAAC,IAAM,SAAS,CAAC,EAAI,GAAG,UAAU,EAAG,WAAW,CAAC,MAAM,CAAC,KAAO,OAAO,YAAc,QAAQ,MAAM,CAAC,MAAO,EAAI,SAAS,KAAM,SAAS,SAAU,EAAK,CAAC,EAAI,KAAK,EAAI,SAAU,OAAQ,IAAM,WAAW,oBAAoB,IAAI,GAAG,EAAG,MAAM,CAAC,YAAY,gBAAgB,CAAC,EAAG,WAAW,CAAC,YAAY,eAAe,CAAC,EAAG,QAAQ,CAAC,MAAM,CAAC,IAAM,UAAU,CAAC,EAAI,GAAG,WAAW,EAAG,WAAW,CAAC,MAAM,CAAC,KAAO,OAAO,YAAc,SAAS,MAAM,CAAC,MAAO,EAAI,SAAS,MAAO,SAAS,SAAU,EAAK,CAAC,EAAI,KAAK,EAAI,SAAU,QAAS,IAAM,WAAW,qBAAqB,GAAG,EAAG,YAAY,CAAC,WAAW,CAAC,CAAC,KAAK,OAAO,QAAQ,SAAS,MAAO,EAAI,SAAS,QAAU,EAAI,cAAe,WAAW,qCAAqC,GAAG,CAAC,MAAQ,SAAS,EAAO,CAAC,MAAO,GAAI,eAAe,CAAC,EAAI,GAAG,iBAAiB,GAAG,EAAG,MAAM,CAAC,YAAY,gBAAgB,CAAC,EAAG,WAAW,CAAC,YAAY,eAAe,CAAC,EAAG,QAAQ,CAAC,MAAM,CAAC,IAAM,UAAU,CAAC,EAAI,GAAG,WAAW,EAAG,WAAW,CAAC,MAAM,CAAC,KAAO,OAAO,YAAc,QAAQ,SAAW,IAAI,MAAM,CAAC,MAAO,EAAI,SAAS,MAAO,SAAS,SAAU,EAAK,CAAC,EAAI,KAAK,EAAI,SAAU,QAAS,IAAM,WAAW,qBAAqB,IAAI,GAAG,EAAG,MAAM,CAAC,EAAG,SAAS,CAAC,MAAM,CAAC,UAAY,EAAI,SAAS,UAAU,OAAS,EAAI,SAAS,mBAAmB,GAAG,CAAC,aAAe,EAAI,iBAAiB,GAAG,EAAG,IAAI,CAAC,WAAW,CAAC,CAAC,KAAK,OAAO,QAAQ,SAAS,MAAO,EAAI,SAAU,WAAW,cAAc,CAAC,EAAI,GAAG,iBAAiB,EAAG,IAAI,CAAC,WAAW,CAAC,CAAC,KAAK,OAAO,QAAQ,SAAS,MAAO,EAAI,QAAS,WAAW,aAAa,CAAC,EAAI,GAAG,cAAc,EAAG,aAAa,GAAG,EAAI,UAC3tDC,GAAkB,kVCatB,oBAAuC,EAAI,CAA3C,aAdA,kCAesB,mBACI,sBAEG,gCACU,uBACT,qBACF,gCACW,8BACF,oBACV,MAMnB,mBAAmB,OACZ,MAAK,YAAc,wBAA0B,WAGpD,oBAAoB,OACb,MAAK,gBACR,KAAK,cACL,KAAK,uBACL,KAAK,wBACH,aACA,MAGN,2BAA2B,OACvB,MAAK,YACE,gDAEA,qCAIT,UAAU,MACP,QAAU,EAAY,YAAc,QACpC,cAAgB,EAAY,sBAC5B,WAAa,QACb,UAAY,QACZ,YAAc,QAGjB,UAAU,CACR,EAAY,oBACP,UAAY,SAGf,MAAK,4BAGD,uBAAuB,CAC7B,KAAK,iBACC,GAAY,eAEd,KAAK,WACA,QAAQ,KAAK,CAAE,KAAM,KAAK,aAE1B,QAAQ,KAAK,CAAE,KAAM,eAKxB,oBAAoB,OAC1B,GAAY,mBACN,MAAK,uBACJ,IAGJ,GAIX,wBAAyB,CACjB,KAAK,qBACA,wBAA0B,SAIjC,QAAQ,MACL,WAAa,MACd,IACI,KAAM,MAAK,8BAIX,CAAC,KAAK,cAAe,MAChB,wBAA0B,aAG/B,CAAC,KAAK,QAAS,MACV,sBAAwB,kBAG5B,wBAA0B,QAC1B,sBAAwB,QACxB,eAAiB,QACjB,eAAiB,GAElB,CAAC,KAAK,aAAe,GAAoB,KAAK,cACxC,MAAK,sBACR,MACG,GAAM,GAAiB,KAAK,SAC7B,OAGK,MAAK,sBAAsB,QAF5B,wBAA0B,iBAMlC,WAAa,SAIZ,kBAAkB,IACxB,IACI,CAAE,KAAM,GAAY,cAAc,KAAK,SAAW,MAC7C,eAAiB,QACjB,WAAa,eAIhB,GAAS,KAAM,GAAY,eAAe,KAAK,YACjD,EAAO,aACF,QAAQ,KAAK,CACd,KAAM,OACN,MAAO,CACH,MAAO,KAAK,MACZ,OAAQ,EAAO,OACf,UAAW,EAAO,UAClB,QAAS,KAAK,QACd,mBAAoB,mBAGrB,EAAO,UAAY,GAAO,CAC7B,EAAO,YAAc,4BAChB,eAAiB,GACf,EAAO,YAAc,oCACvB,sBAAwB,kBAIhC,WACG,MAAM,0CAA2C,QACpD,UAAY,SAIX,uBAAsB,EAAa,IACzC,IACI,CAAE,KAAM,GAAY,kBAAkB,GAAO,MACxC,eAAiB,QACjB,WAAa,eAIhB,GAAS,KAAM,GAAY,qBAAqB,MAClD,EAAO,aACF,QAAQ,KAAK,CACd,KAAM,OACN,MAAO,CACH,MAAO,KAAK,MACZ,OAAQ,EAAO,OACf,UAAW,EAAO,UAClB,QAAS,EACT,mBAAoB,mBAGrB,EAAO,UAAY,GAAO,CAC7B,EAAO,YAAc,4BAChB,aAAe,GACb,EAAO,YAAc,oCACvB,sBAAwB,kBAIhC,WACG,MACJ,iDACA,QAEC,UAAY,MA3KAC,IAAxB,EAAK,CAAE,QAAS,QAAQS,GAAA,qBA+DzBT,IADC,GAAM,kBACPS,GAAA,sCA3EJA,OAHCZ,EAAU,CACP,WAAY,MAEhBY,ICdA,GAAIX,IAAS,UAAY,CAAC,GAAI,GAAI,KAAS,EAAG,EAAI,eAAmB,EAAG,EAAI,MAAM,IAAI,EAAG,MAAO,GAAG,MAAM,CAAC,YAAY,mBAAmB,CAAC,EAAG,OAAO,CAAC,GAAG,CAAC,OAAS,SAAS,EAAO,CAAC,SAAO,iBAAwB,EAAI,MAAM,MAAM,KAAM,cAAc,CAAC,EAAG,UAAU,CAAC,EAAG,iBAAiB,CAAC,EAAG,MAAM,CAAC,YAAY,YAAY,CAAC,EAAI,GAAG,aAAa,EAAG,kBAAkB,CAAC,EAAG,MAAM,CAAC,YAAY,uBAAuB,CAAC,EAAG,MAAM,CAAC,YAAY,kBAAkB,CAAC,EAAG,WAAW,CAAC,MAAM,EAAI,mBAAmB,CAAC,EAAG,QAAQ,CAAC,MAAM,CAAC,IAAM,YAAY,CAAC,EAAI,GAAG,EAAI,GAAG,EAAI,qBAAqB,EAAG,WAAW,CAAC,MAAM,CAAC,KAAO,UAAU,GAAK,UAAU,aAAe,QAAQ,SAAW,EAAI,YAAY,MAAM,CAAC,MAAO,EAAI,QAAS,SAAS,SAAU,EAAK,CAAC,EAAI,QAAQ,GAAK,WAAW,aAAa,EAAG,OAAO,CAAC,WAAW,CAAC,CAAC,KAAK,OAAO,QAAQ,SAAS,MAAO,EAAI,eAAgB,WAAW,mBAAmB,YAAY,YAAY,CAAC,EAAI,GAAG,+BAA+B,EAAG,OAAO,CAAC,WAAW,CAAC,CAAC,KAAK,OAAO,QAAQ,SAAS,MAAO,EAAI,aAAc,WAAW,iBAAiB,YAAY,YAAY,CAAC,EAAI,GAAG,sCAAuC,EAAI,wBAAyB,EAAG,OAAO,CAAC,YAAY,YAAY,CAAC,EAAI,GAAG,qEAAqE,EAAI,KAAM,EAAI,sBAAuB,EAAG,OAAO,CAAC,YAAY,YAAY,CAAC,EAAI,GAAG,EAAI,GAAG,EAAI,6BAA6B,EAAI,MAAM,IAAI,KAAK,EAAG,MAAM,CAAC,YAAY,8BAA8B,CAAC,EAAG,MAAM,CAAC,WAAW,CAAC,CAAC,KAAK,OAAO,QAAQ,SAAS,MAAO,EAAI,wBAAyB,WAAW,4BAA4B,YAAY,0BAA0B,CAAC,EAAI,GAAG,2CAA2C,EAAG,MAAM,CAAC,YAAY,4BAA4B,CAAC,EAAG,cAAc,CAAC,MAAM,CAAC,GAAK,oBAAoB,MAAM,CAAC,MAAO,EAAI,cAAe,SAAS,SAAU,EAAK,CAAC,EAAI,cAAc,GAAK,WAAW,mBAAmB,EAAG,QAAQ,CAAC,MAAM,CAAC,IAAM,qBAAqB,CAAC,EAAI,GAAG,kBAAkB,EAAG,IAAI,CAAC,MAAM,CAAC,OAAS,SAAS,KAAO,WAAW,CAAC,EAAI,GAAG,yBAAyB,OAAO,EAAG,kBAAkB,CAAC,EAAG,YAAY,CAAC,YAAY,aAAa,MAAM,CAAC,KAAO,SAAS,SAAW,EAAI,aAAa,CAAE,EAAI,WAAY,EAAG,sBAAsB,CAAC,MAAM,CAAC,UAAU,gBAAgB,cAAc,GAAG,YAAY,IAAI,CAAC,EAAI,GAAG,gBAAgB,EAAG,OAAO,CAAC,EAAI,GAAG,WAAW,IAAI,IAAI,IAAI,MACpxEC,GAAkB,kVCOtB,oBAAuC,EAAI,CAA3C,aARA,+BASmB,mBACO,sBAEG,6BACO,MAQ5B,iBAAiB,OACV,MAAK,eAAiB,KAAK,qBAC5B,aACA,MAGN,oBAAoB,OACb,cACH,KAAK,qBAAuB,QAAU,QAAU,eAIlD,UAAU,MACP,KAAO,QACP,WAAa,QAGhB,UAAU,MACN,MAAK,yBAGT,WAAW,UACT,MACK,WAAa,QACb,cAAgB,QAChB,qBAAuB,QACtB,GAAO,QAAK,OAAL,cAAW,UAEnB,EAGE,MACG,GAAS,KAAM,GAAY,cAC7B,KAAK,OACL,KAAK,UACL,MAGA,EAAO,aACF,4BACE,EAAO,UAAY,GAAO,CAC7B,EAAO,YAAc,oBAChB,qBAAuB,GACrB,EAAO,YAAc,wBACvB,0BAhBN,MACF,cAAgB,wBAqBpB,WAAa,IAI1B,aAAc,MACL,QAAQ,KAAK,CACd,KAAM,QACN,MAAO,CACH,MAAO,KAAK,cAKV,uBAAuB,MAC3B,GAAY,eAEd,KAAK,WACA,QAAQ,KAAK,CAAE,KAAM,KAAK,aAE1B,QAAQ,KAAK,CAAE,KAAM,cAIpB,oBAAoB,OAC1B,GAAY,mBACN,MAAK,uBACJ,IAGJ,KArFcC,IAAxB,EAAK,CAAE,QAAS,QAAQ,GAAA,qBACAA,IAAxB,EAAK,CAAE,QAAS,QAAQ,GAAA,sBACAA,IAAxB,EAAK,CAAE,QAAS,QAAQ,GAAA,yBACjBA,IAAP,KAAO,GAAA,uBACoBA,IAA3B,EAAK,CAAE,QAAS,WAAW,GAAA,kCAXhC,OAHCH,EAAU,CACP,WAAY,MAEhB,ICRA,GAAIC,IAAS,UAAY,CAAC,GAAI,GAAI,KAAS,EAAG,EAAI,eAAmB,EAAG,EAAI,MAAM,IAAI,EAAG,MAAO,GAAG,MAAM,CAAC,YAAY,mBAAmB,CAAC,EAAG,OAAO,CAAC,GAAG,CAAC,OAAS,SAAS,EAAO,CAAC,SAAO,iBAAwB,EAAI,SAAS,MAAM,KAAM,cAAc,CAAC,EAAG,UAAU,CAAC,EAAG,iBAAiB,CAAC,EAAG,MAAM,CAAC,YAAY,YAAY,CAAC,EAAI,GAAG,EAAI,GAAG,EAAI,wBAAwB,EAAG,kBAAkB,CAAC,EAAG,MAAM,CAAC,YAAY,uBAAuB,CAAC,EAAG,MAAM,CAAC,YAAY,kBAAkB,CAAC,EAAG,IAAI,CAAC,EAAI,GAAG,6BAA6B,EAAG,SAAS,CAAC,EAAI,GAAG,EAAI,GAAG,EAAI,YAAY,EAAI,GAAG,0CAA0C,EAAG,WAAW,CAAC,MAAM,EAAI,gBAAgB,CAAC,EAAG,QAAQ,CAAC,MAAM,CAAC,IAAM,SAAS,CAAC,EAAI,GAAG,UAAU,EAAG,WAAW,CAAC,MAAM,CAAC,KAAO,OAAO,GAAK,OAAO,SAAW,EAAI,YAAY,MAAM,CAAC,MAAO,EAAI,KAAM,SAAS,SAAU,EAAK,CAAC,EAAI,KAAK,GAAK,WAAW,UAAW,EAAI,cAAe,EAAG,OAAO,CAAC,YAAY,YAAY,CAAC,EAAI,GAAG,iCAAiC,EAAI,KAAM,EAAI,qBAAsB,EAAG,OAAO,CAAC,YAAY,YAAY,CAAC,EAAI,GAAG,mCAAmC,EAAI,MAAM,IAAI,OAAO,EAAG,kBAAkB,CAAC,EAAG,YAAY,CAAC,MAAM,CAAC,SAAW,EAAI,YAAY,GAAG,CAAC,MAAQ,SAAS,EAAO,CAAC,MAAO,GAAI,iBAAiB,CAAC,EAAI,GAAG,YAAY,EAAG,YAAY,CAAC,YAAY,aAAa,MAAM,CAAC,KAAO,SAAS,SAAW,EAAI,aAAa,CAAE,EAAI,WAAY,EAAG,sBAAsB,CAAC,MAAM,CAAC,UAAU,gBAAgB,cAAc,GAAG,YAAY,IAAI,CAAC,EAAI,GAAG,gBAAgB,EAAG,OAAO,CAAC,EAAI,GAAG,WAAW,IAAI,IAAI,IAAI,MAC/9CC,GAAkB,kVCStB,oBAAyC,EAAI,CAA7C,aAVA,kCAWuB,MAEf,UAAU,OACH,GAAY,QAGvB,SAAU,MACD,QAAU,MAEN,IAAI,eAAgB,IAAM,MAC1B,QAAU,QAEV,IAAI,cAAe,IAAM,MACzB,QAAU,OAd3BW,OALCb,EAAU,CACP,WAAY,CACR,QAAS,OAGjBa,ICVA,GAAIZ,IAAS,UAAY,CAAC,GAAI,GAAI,KAAS,EAAG,EAAI,eAAmB,EAAG,EAAI,MAAM,IAAI,EAAG,MAAO,GAAG,MAAM,CAAE,EAAI,QAAS,EAAG,UAAU,CAAC,MAAM,CAAC,OAAS,GAAG,SAAW,EAAE,MAAQ,KAAK,KAAO,EAAI,QAAQ,QAAU,EAAI,WAAW,EAAI,MAAM,IACrOC,GAAkB,kVCMtB,oBAAuC,EAAI,IACnC,SAAS,OACF,UAAS,UAGhB,WAAW,OACJ,UAAS,WANxBY,OAHCd,EAAU,CACP,WAAY,MAEhBc,ICPA,GAAIb,IAAS,UAAY,CAAC,GAAI,GAAI,KAAS,EAAG,EAAI,eAAmB,EAAG,EAAI,MAAM,IAAI,EAAG,MAAO,GAAG,MAAM,CAAC,YAAY,mBAAmB,CAAC,EAAG,UAAU,CAAC,EAAG,iBAAiB,CAAC,EAAG,KAAK,CAAC,YAAY,YAAY,CAAC,EAAI,GAAG,EAAI,GAAG,EAAI,UAAU,yBAAyB,EAAG,kBAAkB,CAAC,EAAG,IAAI,CAAC,EAAG,KAAK,CAAC,EAAI,GAAG,wCAAwC,EAAG,IAAI,CAAC,EAAI,GAAG,sDAAsD,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,0BAA0B,CAAC,EAAI,GAAG,UAAU,EAAI,GAAG,QAAQ,EAAG,IAAI,CAAC,EAAI,GAAG,2FAA2F,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,2BAA2B,CAAC,EAAI,GAAG,2BAA2B,EAAI,GAAG,SAAS,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,oBAAoB,CAAC,EAAI,GAAG,oBAAoB,EAAI,GAAG,QAAQ,EAAG,IAAI,CAAC,EAAI,GAAG,0GAA0G,EAAG,IAAI,CAAC,EAAI,GAAG,8JAA8J,EAAG,MAAM,CAAC,YAAY,4BAA4B,CAAC,EAAG,KAAK,CAAC,MAAM,CAAC,GAAK,QAAQ,CAAC,EAAG,KAAK,CAAC,MAAM,CAAC,MAAQ,MAAM,CAAC,EAAG,KAAK,CAAC,EAAI,GAAG,2BAA2B,EAAG,MAAM,CAAC,YAAY,qBAAqB,CAAC,EAAG,KAAK,CAAC,MAAM,CAAC,MAAQ,MAAM,CAAC,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,SAAS,CAAC,EAAI,GAAG,yBAAyB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,iBAAiB,CAAC,EAAI,GAAG,yBAAyB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,uBAAuB,CAAC,EAAI,GAAG,yBAAyB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,4CAA4C,CAAC,EAAI,GAAG,8CAA8C,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,yBAAyB,CAAC,EAAI,GAAG,yEAAyE,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,yCAAyC,CAAC,EAAI,GAAG,2CAA2C,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,yBAAyB,CAAC,EAAI,GAAG,2BAA2B,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,6BAA6B,CAAC,EAAI,GAAG,+BAA+B,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,eAAe,CAAC,EAAI,GAAG,iBAAiB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,2BAA2B,CAAC,EAAI,GAAG,6BAA6B,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,aAAa,CAAC,EAAI,GAAG,eAAe,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,2BAA2B,CAAC,EAAI,GAAG,6BAA6B,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,mBAAmB,CAAC,EAAI,GAAG,yBAAyB,EAAG,KAAK,CAAC,MAAM,CAAC,GAAK,gBAAgB,CAAC,EAAG,KAAK,CAAC,MAAM,CAAC,MAAQ,MAAM,CAAC,EAAG,KAAK,CAAC,EAAI,GAAG,2BAA2B,EAAG,IAAI,CAAC,EAAI,GAAG,kHAAkH,EAAG,KAAK,CAAC,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,oBAAoB,CAAC,EAAI,GAAG,eAAe,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,0BAA0B,CAAC,EAAI,GAAG,qBAAqB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,2BAA2B,CAAC,EAAI,GAAG,sBAAsB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,2BAA2B,CAAC,EAAI,GAAG,sBAAsB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,qBAAqB,CAAC,EAAI,GAAG,gBAAgB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,yBAAyB,CAAC,EAAI,GAAG,oBAAoB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,+BAA+B,CAAC,EAAI,GAAG,0BAA0B,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,gCAAgC,CAAC,EAAI,GAAG,2BAA2B,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,gCAAgC,CAAC,EAAI,GAAG,2BAA2B,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,yBAAyB,CAAC,EAAI,GAAG,oBAAoB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,0BAA0B,CAAC,EAAI,GAAG,qBAAqB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,0BAA0B,CAAC,EAAI,GAAG,qBAAqB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,gCAAgC,CAAC,EAAI,GAAG,2BAA2B,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,iCAAiC,CAAC,EAAI,GAAG,4BAA4B,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,iCAAiC,CAAC,EAAI,GAAG,4BAA4B,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,0BAA0B,CAAC,EAAI,GAAG,qBAAqB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,iCAAiC,CAAC,EAAI,GAAG,4BAA4B,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,iCAAiC,CAAC,EAAI,GAAG,4BAA4B,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,2BAA2B,CAAC,EAAI,GAAG,sBAAsB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,mCAAmC,CAAC,EAAI,GAAG,8BAA8B,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,qCAAqC,CAAC,EAAI,GAAG,gCAAgC,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,8BAA8B,CAAC,EAAI,GAAG,yBAAyB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,yBAAyB,CAAC,EAAI,GAAG,sBAAsB,EAAG,IAAI,CAAC,EAAI,GAAG,+ZAA6a,EAAG,IAAI,CAAC,EAAI,GAAG,+XAAmY,EAAG,IAAI,CAAC,EAAI,GAAG,uVAAyV,EAAG,IAAI,CAAC,EAAI,GAAG,6cAA6c,EAAG,IAAI,CAAC,EAAI,GAAG,2fAA2f,EAAG,IAAI,CAAC,EAAI,GAAG,wKAAwK,EAAG,IAAI,CAAC,EAAG,OAAO,CAAC,EAAI,GAAG,2DAA2D,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,WAAW,CAAC,EAAI,GAAG,EAAI,GAAG,EAAI,QAAQ,YAAY,EAAI,GAAG,qcAAqc,EAAG,KAAK,CAAC,MAAM,CAAC,GAAK,sBAAsB,CAAC,EAAG,KAAK,CAAC,MAAM,CAAC,MAAQ,MAAM,CAAC,EAAG,KAAK,CAAC,EAAI,GAAG,2BAA2B,EAAG,IAAI,CAAC,EAAI,GAAG,yPAA2P,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,kDAAkD,CAAC,EAAI,GAAG,mDAAmD,EAAI,GAAG,iVAAiV,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,sCAAsC,CAAC,EAAI,GAAG,gCAAgC,EAAI,GAAG,2QAA2Q,EAAG,IAAI,CAAC,EAAI,GAAG,mOAAmO,EAAG,IAAI,CAAC,EAAI,GAAG,yqBAAyqB,EAAG,IAAI,CAAC,EAAI,GAAG,0NAA0N,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,sCAAsC,CAAC,EAAI,GAAG,gCAAgC,EAAI,GAAG,gDAAgD,EAAG,KAAK,CAAC,MAAM,CAAC,GAAK,2CAA2C,CAAC,EAAG,KAAK,CAAC,MAAM,CAAC,MAAQ,MAAM,CAAC,EAAG,KAAK,CAAC,EAAI,GAAG,gDAAgD,EAAG,IAAI,CAAC,EAAI,GAAG,6OAA6O,EAAG,IAAI,CAAC,EAAI,GAAG,yhBAAyhB,EAAG,IAAI,CAAC,EAAI,GAAG,oFAAsF,EAAG,IAAI,CAAC,EAAI,GAAG,suBAAwuB,EAAG,IAAI,CAAC,EAAI,GAAG,iJAAiJ,EAAG,KAAK,CAAC,EAAG,KAAK,CAAC,EAAI,GAAG,oGAAoG,EAAG,KAAK,CAAC,EAAI,GAAG,4CAA4C,EAAG,KAAK,CAAC,EAAI,GAAG,yIAAyI,EAAG,KAAK,CAAC,EAAI,GAAG,yGAAyG,EAAG,KAAK,CAAC,EAAI,GAAG,wDAAwD,EAAG,IAAI,CAAC,EAAI,GAAG,+KAA+K,EAAG,KAAK,CAAC,MAAM,CAAC,GAAK,wBAAwB,CAAC,EAAG,KAAK,CAAC,MAAM,CAAC,MAAQ,MAAM,CAAC,EAAG,KAAK,CAAC,EAAI,GAAG,6EAA6E,EAAG,IAAI,CAAC,EAAI,GAAG,0iBAAgiB,EAAG,IAAI,CAAC,EAAI,GAAG,kZAAkZ,EAAG,IAAI,CAAC,MAAM,CAAC,OAAS,SAAS,KAAO,uDAAuD,CAAC,EAAI,GAAG,0CAA0C,EAAI,GAAG,QAAQ,EAAG,IAAI,CAAC,EAAI,GAAG,6SAA6S,EAAG,IAAI,CAAC,EAAI,GAAG,mQAAmQ,EAAG,IAAI,CAAC,EAAI,GAAG,mGAAmG,EAAG,IAAI,CAAC,EAAI,GAAG,6NAA6N,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,sCAAsC,CAAC,EAAI,GAAG,gCAAgC,EAAI,GAAG,QAAQ,EAAG,IAAI,CAAC,EAAI,GAAG,kBAAkB,EAAG,IAAI,CAAC,EAAI,GAAG,8FAA8F,EAAG,IAAI,CAAC,EAAI,GAAG,yHAAyH,EAAG,IAAI,CAAC,EAAI,GAAG,qVAAqV,EAAG,IAAI,CAAC,EAAI,GAAG,4FAA4F,EAAG,IAAI,CAAC,EAAI,GAAG,4RAA4R,EAAG,IAAI,CAAC,EAAI,GAAG,qGAAqG,EAAG,KAAK,CAAC,EAAG,KAAK,CAAC,EAAI,GAAG,wIAAwI,EAAG,KAAK,CAAC,EAAI,GAAG,+EAA+E,EAAG,KAAK,CAAC,EAAI,GAAG,mNAAmN,EAAG,KAAK,CAAC,EAAI,GAAG,qHAAqH,EAAG,KAAK,CAAC,EAAI,GAAG,8QAA8Q,EAAG,IAAI,CAAC,EAAI,GAAG,kCAAkC,EAAG,KAAK,CAAC,EAAG,KAAK,CAAC,EAAI,GAAG,yGAAyG,EAAG,KAAK,CAAC,EAAI,GAAG,yGAAyG,EAAG,KAAK,CAAC,EAAI,GAAG,6IAA6I,EAAG,KAAK,CAAC,EAAI,GAAG,iKAAiK,EAAG,KAAK,CAAC,EAAI,GAAG,6EAA6E,EAAG,KAAK,CAAC,EAAI,GAAG,sIAAsI,EAAG,KAAK,CAAC,MAAM,CAAC,GAAK,wCAAwC,CAAC,EAAG,KAAK,CAAC,MAAM,CAAC,MAAQ,MAAM,CAAC,EAAG,KAAK,CAAC,EAAI,GAAG,6CAA6C,EAAG,IAAI,CAAC,EAAI,GAAG,sVAAwV,EAAG,KAAK,CAAC,MAAM,CAAC,GAAK,wBAAwB,CAAC,EAAG,KAAK,CAAC,MAAM,CAAC,MAAQ,MAAM,CAAC,EAAG,KAAK,CAAC,EAAI,GAAG,6BAA6B,EAAG,IAAI,CAAC,EAAI,GAAG,wwCAA4wC,EAAG,KAAK,CAAC,MAAM,CAAC,GAAK,4BAA4B,CAAC,EAAG,KAAK,CAAC,MAAM,CAAC,MAAQ,MAAM,CAAC,EAAG,KAAK,CAAC,EAAI,GAAG,iCAAiC,EAAG,IAAI,CAAC,EAAI,GAAG,oxCAAoxC,EAAG,KAAK,CAAC,MAAM,CAAC,GAAK,cAAc,CAAC,EAAG,KAAK,CAAC,MAAM,CAAC,MAAQ,MAAM,CAAC,EAAG,KAAK,CAAC,EAAI,GAAG,mBAAmB,EAAG,IAAI,CAAC,EAAI,GAAG,qrBAAgrB,EAAG,KAAK,CAAC,MAAM,CAAC,GAAK,0BAA0B,CAAC,EAAG,KAAK,CAAC,MAAM,CAAC,MAAQ,MAAM,CAAC,EAAG,KAAK,CAAC,EAAI,GAAG,+BAA+B,EAAG,IAAI,CAAC,EAAI,GAAG,6iBAA6iB,EAAG,IAAI,CAAC,EAAI,GAAG,+HAA+H,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,sCAAsC,CAAC,EAAI,GAAG,gCAAgC,EAAI,GAAG,gRAAgR,EAAG,IAAI,CAAC,EAAI,GAAG,kXAAkX,EAAG,IAAI,CAAC,EAAI,GAAG,8lCAA8lC,EAAG,KAAK,CAAC,MAAM,CAAC,GAAK,YAAY,CAAC,EAAG,KAAK,CAAC,MAAM,CAAC,MAAQ,OAAO,CAAC,EAAG,KAAK,CAAC,EAAI,GAAG,iBAAiB,EAAG,IAAI,CAAC,EAAI,GAAG,0PAA0P,EAAG,IAAI,CAAC,EAAI,GAAG,mQAAmQ,EAAG,KAAK,CAAC,MAAM,CAAC,GAAK,0BAA0B,CAAC,EAAG,KAAK,CAAC,MAAM,CAAC,MAAQ,OAAO,CAAC,EAAG,KAAK,CAAC,EAAG,KAAK,CAAC,EAAI,GAAG,iCAAiC,EAAG,IAAI,CAAC,EAAI,GAAG,oqCAA+pC,EAAG,IAAI,CAAC,EAAI,GAAG,6bAAqb,EAAG,IAAI,CAAC,EAAI,GAAG,kOAAkO,EAAG,IAAI,CAAC,EAAI,GAAG,olCAA+kC,EAAG,IAAI,CAAC,EAAI,GAAG,yTAAyT,EAAG,IAAI,CAAC,EAAI,GAAG,+YAA4Y,EAAG,IAAI,CAAC,EAAI,GAAG,4KAA4K,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,sCAAsC,CAAC,EAAI,GAAG,gCAAgC,EAAI,GAAG,kpDAAopD,EAAG,KAAK,CAAC,MAAM,CAAC,GAAK,kBAAkB,CAAC,EAAG,KAAK,CAAC,MAAM,CAAC,MAAQ,OAAO,CAAC,EAAG,KAAK,CAAC,EAAI,GAAG,uBAAuB,EAAG,IAAI,CAAC,EAAI,GAAG,4UAA4U,EAAG,IAAI,CAAC,EAAI,GAAG,sNAAsN,EAAG,IAAI,CAAC,EAAI,GAAG,iMAAiM,EAAG,IAAI,CAAC,EAAI,GAAG,oYAA4Z,EAAG,IAAI,CAAC,EAAI,GAAG,4fAA4f,IAAI,IAC58hCC,GAAkB,kVCMtB,oBAAuC,EAAI,IACnC,SAAS,OACF,UAAS,UAGhB,WAAW,OACJ,UAAS,WANxBY,OAHCd,EAAU,CACP,WAAY,MAEhBc,ICPA,GAAIb,IAAS,UAAY,CAAC,GAAI,GAAI,KAAS,EAAG,EAAI,eAAmB,EAAG,EAAI,MAAM,IAAI,EAAG,MAAO,GAAG,MAAM,CAAC,YAAY,4BAA4B,CAAC,EAAG,UAAU,CAAC,EAAG,iBAAiB,CAAC,EAAG,KAAK,CAAC,YAAY,YAAY,CAAC,EAAI,GAAG,EAAI,GAAG,EAAI,UAAU,uBAAuB,EAAG,kBAAkB,CAAC,EAAG,IAAI,CAAC,EAAG,KAAK,CAAC,EAAI,GAAG,uCAAuC,EAAG,IAAI,CAAC,EAAI,GAAG,8DAA8D,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,wBAAwB,CAAC,EAAI,GAAG,UAAU,EAAI,GAAG,QAAQ,EAAG,IAAI,CAAC,EAAI,GAAG,wFAAwF,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,2BAA2B,CAAC,EAAI,GAAG,2BAA2B,EAAI,GAAG,SAAS,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,WAAW,CAAC,EAAI,GAAG,sBAAsB,EAAI,GAAG,QAAQ,EAAG,MAAM,CAAC,YAAY,0BAA0B,CAAC,EAAG,KAAK,CAAC,MAAM,CAAC,GAAK,QAAQ,CAAC,EAAG,KAAK,CAAC,MAAM,CAAC,MAAQ,MAAM,CAAC,EAAG,KAAK,CAAC,EAAI,GAAG,2BAA2B,EAAG,MAAM,CAAC,YAAY,qBAAqB,CAAC,EAAG,KAAK,CAAC,MAAM,CAAC,MAAQ,MAAM,CAAC,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,SAAS,CAAC,EAAI,GAAG,yBAAyB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,kBAAkB,CAAC,EAAI,GAAG,oBAAoB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,0BAA0B,CAAC,EAAI,GAAG,4BAA4B,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,iBAAiB,CAAC,EAAI,GAAG,mBAAmB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,6BAA6B,CAAC,EAAI,GAAG,mCAAmC,EAAG,KAAK,CAAC,MAAM,CAAC,GAAK,iBAAiB,CAAC,EAAG,KAAK,CAAC,MAAM,CAAC,MAAQ,MAAM,CAAC,EAAG,KAAK,CAAC,EAAI,GAAG,sBAAsB,EAAG,IAAI,CAAC,EAAI,GAAG,0PAA0P,EAAG,IAAI,CAAC,EAAI,GAAG,4JAA4J,EAAG,KAAK,CAAC,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,oBAAoB,CAAC,EAAI,GAAG,eAAe,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,0BAA0B,CAAC,EAAI,GAAG,qBAAqB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,2BAA2B,CAAC,EAAI,GAAG,sBAAsB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,2BAA2B,CAAC,EAAI,GAAG,sBAAsB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,qBAAqB,CAAC,EAAI,GAAG,gBAAgB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,yBAAyB,CAAC,EAAI,GAAG,oBAAoB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,+BAA+B,CAAC,EAAI,GAAG,0BAA0B,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,gCAAgC,CAAC,EAAI,GAAG,2BAA2B,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,gCAAgC,CAAC,EAAI,GAAG,2BAA2B,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,yBAAyB,CAAC,EAAI,GAAG,oBAAoB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,0BAA0B,CAAC,EAAI,GAAG,qBAAqB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,0BAA0B,CAAC,EAAI,GAAG,qBAAqB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,gCAAgC,CAAC,EAAI,GAAG,2BAA2B,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,iCAAiC,CAAC,EAAI,GAAG,4BAA4B,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,iCAAiC,CAAC,EAAI,GAAG,4BAA4B,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,0BAA0B,CAAC,EAAI,GAAG,qBAAqB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,iCAAiC,CAAC,EAAI,GAAG,4BAA4B,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,iCAAiC,CAAC,EAAI,GAAG,4BAA4B,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,2BAA2B,CAAC,EAAI,GAAG,sBAAsB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,mCAAmC,CAAC,EAAI,GAAG,8BAA8B,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,qCAAqC,CAAC,EAAI,GAAG,gCAAgC,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,8BAA8B,CAAC,EAAI,GAAG,yBAAyB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,yBAAyB,CAAC,EAAI,GAAG,sBAAsB,EAAG,IAAI,CAAC,EAAI,GAAG,ofAA8a,EAAG,IAAI,CAAC,EAAI,GAAG,8UAA0T,EAAG,KAAK,CAAC,MAAM,CAAC,GAAK,yBAAyB,CAAC,EAAG,KAAK,CAAC,MAAM,CAAC,MAAQ,MAAM,CAAC,EAAG,KAAK,CAAC,EAAI,GAAG,8BAA8B,EAAG,IAAI,CAAC,EAAI,GAAG,mGAAmG,EAAG,IAAI,CAAC,EAAI,GAAG,kGAAkG,EAAG,IAAI,CAAC,MAAM,CAAC,OAAS,SAAS,KAAO,oBAAoB,CAAC,EAAI,GAAG,aAAa,EAAI,GAAG,2IAA2I,EAAG,IAAI,CAAC,EAAI,GAAG,yOAAyO,EAAG,IAAI,CAAC,MAAM,CAAC,OAAS,SAAS,KAAO,wCAAwC,CAAC,EAAI,GAAG,yCAAyC,EAAI,GAAG,kFAAkF,EAAG,IAAI,CAAC,EAAI,GAAG,2PAA2P,EAAG,IAAI,CAAC,EAAG,SAAS,CAAC,EAAI,GAAG,gBAAgB,EAAI,GAAG,aAAa,EAAG,IAAI,CAAC,MAAM,CAAC,OAAS,SAAS,KAAO,wBAAwB,CAAC,EAAI,GAAG,gBAAgB,EAAI,GAAG,4GAAuG,EAAG,IAAI,CAAC,MAAM,CAAC,OAAS,SAAS,KAAO,wCAAwC,CAAC,EAAI,GAAG,yCAAyC,EAAI,GAAG,kCAAkC,EAAG,IAAI,CAAC,MAAM,CAAC,OAAS,SAAS,KAAO,wBAAwB,CAAC,EAAI,GAAG,gBAAgB,EAAI,GAAG,0BAA0B,EAAG,IAAI,CAAC,EAAG,SAAS,CAAC,EAAI,GAAG,oBAAoB,EAAI,GAAG,aAAa,EAAG,IAAI,CAAC,MAAM,CAAC,OAAS,SAAS,KAAO,2BAA2B,CAAC,EAAI,GAAG,oBAAoB,EAAI,GAAG,oHAA+G,EAAG,MAAM,EAAI,GAAG,mBAAmB,EAAG,IAAI,CAAC,MAAM,CAAC,OAAS,SAAS,KAAO,2BAA2B,CAAC,EAAI,GAAG,oBAAoB,EAAI,GAAG,yBAAyB,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,2EAA2E,CAAC,EAAI,GAAG,4EAA4E,EAAI,GAAG,kCAAkC,EAAG,IAAI,CAAC,MAAM,CAAC,OAAS,SAAS,KAAO,2BAA2B,CAAC,EAAI,GAAG,oBAAoB,EAAI,GAAG,0BAA0B,EAAG,IAAI,CAAC,EAAI,GAAG,2IAAiI,EAAG,IAAI,CAAC,MAAM,CAAC,OAAS,SAAS,KAAO,mDAAmD,CAAC,EAAI,GAAG,sBAAsB,EAAI,GAAG,8PAAoP,EAAG,IAAI,CAAC,EAAI,GAAG,4OAAuO,EAAG,KAAK,CAAC,MAAM,CAAC,GAAK,gBAAgB,CAAC,EAAG,KAAK,CAAC,MAAM,CAAC,MAAQ,MAAM,CAAC,EAAG,KAAK,CAAC,EAAI,GAAG,qBAAqB,EAAG,IAAI,CAAC,EAAI,GAAG,ySAAyS,EAAG,IAAI,CAAC,EAAI,GAAG,6DAA6D,EAAG,KAAK,CAAC,EAAG,KAAK,CAAC,EAAI,GAAG,2CAA2C,EAAG,KAAK,CAAC,EAAI,GAAG,2HAA2H,EAAG,IAAI,CAAC,EAAI,GAAG,sFAAsF,EAAG,KAAK,CAAC,EAAG,KAAK,CAAC,EAAI,GAAG,0GAA0G,EAAG,KAAK,CAAC,EAAI,GAAG,yGAAyG,EAAG,KAAK,CAAC,EAAI,GAAG,wFAAwF,EAAG,KAAK,CAAC,EAAI,GAAG,wEAAwE,EAAG,KAAK,CAAC,EAAI,GAAG,kHAAkH,EAAG,KAAK,CAAC,EAAI,GAAG,yHAAyH,EAAG,IAAI,CAAC,EAAI,GAAG,mLAAmL,EAAG,IAAI,CAAC,EAAI,GAAG,mOAAmO,EAAG,KAAK,CAAC,MAAM,CAAC,GAAK,4BAA4B,CAAC,EAAG,KAAK,CAAC,MAAM,CAAC,MAAQ,MAAM,CAAC,EAAG,KAAK,CAAC,EAAI,GAAG,iCAAiC,EAAG,IAAI,CAAC,EAAI,GAAG,0YAA0Y,IAAI,IAC3hVC,GAAkB,kVCMtB,oBAAuC,EAAI,IACnC,SAAS,OACF,UAAS,UAGhB,WAAW,OACJ,UAAS,WANxB,OAHCF,EAAU,CACP,WAAY,MAEhB,ICPA,GAAI,IAAS,UAAY,CAAC,GAAI,GAAI,KAAS,EAAG,EAAI,eAAmB,EAAG,EAAI,MAAM,IAAI,EAAG,MAAO,GAAG,MAAM,CAAC,YAAY,mCAAmC,CAAC,EAAG,UAAU,CAAC,EAAG,iBAAiB,CAAC,EAAG,KAAK,CAAC,YAAY,YAAY,CAAC,EAAI,GAAG,4DAA4D,EAAG,kBAAkB,CAAC,EAAG,IAAI,CAAC,EAAG,KAAK,CAAC,EAAI,GAAG,uCAAuC,EAAG,IAAI,CAAC,EAAI,GAAG,qEAAqE,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,+BAA+B,CAAC,EAAI,GAAG,UAAU,EAAI,GAAG,QAAQ,EAAG,IAAI,CAAC,EAAI,GAAG,+FAA+F,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,WAAW,CAAC,EAAI,GAAG,sBAAsB,EAAI,GAAG,SAAS,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,oBAAoB,CAAC,EAAI,GAAG,oBAAoB,EAAI,GAAG,QAAQ,EAAG,MAAM,CAAC,YAAY,iCAAiC,CAAC,EAAG,KAAK,CAAC,MAAM,CAAC,GAAK,QAAQ,CAAC,EAAG,KAAK,CAAC,MAAM,CAAC,MAAQ,MAAM,CAAC,EAAG,KAAK,CAAC,EAAI,GAAG,2BAA2B,EAAG,MAAM,CAAC,YAAY,qBAAqB,CAAC,EAAG,KAAK,CAAC,MAAM,CAAC,MAAQ,MAAM,CAAC,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,SAAS,CAAC,EAAI,GAAG,yBAAyB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,kBAAkB,CAAC,EAAI,GAAG,wCAAwC,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,iBAAiB,CAAC,EAAI,GAAG,mBAAmB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,UAAU,CAAC,EAAI,GAAG,YAAY,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,gCAAgC,CAAC,EAAI,GAAG,kCAAkC,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,kBAAkB,CAAC,EAAI,GAAG,2CAA2C,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,8BAA8B,CAAC,EAAI,GAAG,gCAAgC,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,eAAe,CAAC,EAAI,GAAG,iBAAiB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,uBAAuB,CAAC,EAAI,GAAG,wCAAwC,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,gCAAgC,CAAC,EAAI,GAAG,sCAAsC,EAAG,KAAK,CAAC,MAAM,CAAC,GAAK,iBAAiB,CAAC,EAAG,KAAK,CAAC,MAAM,CAAC,MAAQ,MAAM,CAAC,EAAG,KAAK,CAAC,EAAI,GAAG,0CAA0C,EAAG,IAAI,CAAC,EAAI,GAAG,uHAAuH,EAAG,KAAK,CAAC,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,oBAAoB,CAAC,EAAI,GAAG,eAAe,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,0BAA0B,CAAC,EAAI,GAAG,qBAAqB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,2BAA2B,CAAC,EAAI,GAAG,sBAAsB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,2BAA2B,CAAC,EAAI,GAAG,sBAAsB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,qBAAqB,CAAC,EAAI,GAAG,gBAAgB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,yBAAyB,CAAC,EAAI,GAAG,oBAAoB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,+BAA+B,CAAC,EAAI,GAAG,0BAA0B,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,gCAAgC,CAAC,EAAI,GAAG,2BAA2B,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,gCAAgC,CAAC,EAAI,GAAG,2BAA2B,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,yBAAyB,CAAC,EAAI,GAAG,oBAAoB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,0BAA0B,CAAC,EAAI,GAAG,qBAAqB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,0BAA0B,CAAC,EAAI,GAAG,qBAAqB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,gCAAgC,CAAC,EAAI,GAAG,2BAA2B,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,iCAAiC,CAAC,EAAI,GAAG,4BAA4B,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,iCAAiC,CAAC,EAAI,GAAG,4BAA4B,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,0BAA0B,CAAC,EAAI,GAAG,qBAAqB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,iCAAiC,CAAC,EAAI,GAAG,4BAA4B,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,iCAAiC,CAAC,EAAI,GAAG,4BAA4B,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,2BAA2B,CAAC,EAAI,GAAG,sBAAsB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,mCAAmC,CAAC,EAAI,GAAG,8BAA8B,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,qCAAqC,CAAC,EAAI,GAAG,gCAAgC,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,8BAA8B,CAAC,EAAI,GAAG,yBAAyB,EAAG,KAAK,CAAC,EAAG,IAAI,CAAC,MAAM,CAAC,KAAO,yBAAyB,CAAC,EAAI,GAAG,sBAAsB,EAAG,IAAI,CAAC,EAAI,GAAG,0eAAoa,EAAG,IAAI,CAAC,EAAI,GAAG,uYAAmX,EAAG,IAAI,CAAC,EAAI,GAAG,wGAAwG,EAAG,IAAI,CAAC,EAAI,GAAG,8oBAA8oB,EAAG,IAAI,CAAC,EAAI,GAAG,iaAAia,EAAG,IAAI,CAAC,EAAI,GAAG,2GAA2G,EAAG,IAAI,CAAC,YAAY,KAAK,MAAM,CAAC,KAAO,sCAAsC,CAAC,EAAI,GAAG,gCAAgC,EAAI,GAAG,qUAAqU,EAAG,KAAK,CAAC,MAAM,CAAC,GAAK,gBAAgB,CAAC,EAAG,KAAK,CAAC,MAAM,CAAC,MAAQ,MAAM,CAAC,EAAG,KAAK,CAAC,EAAI,GAAG,qBAAqB,EAAG,IAAI,CAAC,EAAI,GAAG,8MAA8M,EAAG,KAAK,CAAC,MAAM,CAAC,GAAK,SAAS,CAAC,EAAG,KAAK,CAAC,MAAM,CAAC,MAAQ,MAAM,CAAC,EAAG,KAAK,CAAC,EAAI,GAAG,cAAc,EAAG,IAAI,CAAC,EAAI,GAAG,0NAA0N,EAAG,KAAK,CAAC,MAAM,CAAC,GAAK,+BAA+B,CAAC,EAAG,KAAK,CAAC,MAAM,CAAC,MAAQ,MAAM,CAAC,EAAG,KAAK,CAAC,EAAI,GAAG,oCAAoC,EAAG,IAAI,CAAC,EAAI,GAAG,6cAA6c,EAAG,KAAK,CAAC,MAAM,CAAC,GAAK,iBAAiB,CAAC,EAAG,KAAK,CAAC,MAAM,CAAC,MAAQ,MAAM,CAAC,EAAG,KAAK,CAAC,EAAI,GAAG,6CAA6C,EAAG,IAAI,CAAC,EAAI,GAAG,qfAAqf,EAAG,KAAK,CAAC,MAAM,CAAC,GAAK,6BAA6B,CAAC,EAAG,KAAK,CAAC,MAAM,CAAC,MAAQ,MAAM,CAAC,EAAG,KAAK,CAAC,EAAI,GAAG,kCAAkC,EAAG,IAAI,CAAC,EAAI,GAAG,6GAA6G,EAAG,KAAK,CAAC,MAAM,CAAC,GAAK,cAAc,CAAC,EAAG,KAAK,CAAC,MAAM,CAAC,MAAQ,MAAM,CAAC,EAAG,KAAK,CAAC,EAAI,GAAG,mBAAmB,EAAG,IAAI,CAAC,EAAI,GAAG,6MAA6M,EAAG,KAAK,CAAC,MAAM,CAAC,GAAK,sBAAsB,CAAC,EAAG,KAAK,CAAC,MAAM,CAAC,MAAQ,MAAM,CAAC,EAAG,KAAK,CAAC,EAAI,GAAG,0CAA0C,EAAG,IAAI,CAAC,EAAI,GAAG,8HAA8H,EAAG,KAAK,CAAC,MAAM,CAAC,GAAK,+BAA+B,CAAC,EAAG,KAAK,CAAC,MAAM,CAAC,MAAQ,MAAM,CAAC,EAAG,KAAK,CAAC,EAAI,GAAG,oCAAoC,EAAG,IAAI,CAAC,EAAI,GAAG,qJAAqJ,IAAI,IAClxT,GAAkB,iJCAf,GAAI,MAAO,SAAW,YAAa,CACjC,GAAS,GAAT,UAAmB,CACjB,GAAI,GAAO,SAAS,KAChB,EAAS,SAAS,eAAe,uBACrC,AAAI,GACF,GAAS,SAAS,gBAAgB,6BAA8B,OAChE,EAAO,MAAM,SAAW,WACxB,EAAO,MAAM,MAAQ,IACrB,EAAO,MAAM,OAAS,IACtB,EAAO,GAAK,sBACZ,EAAO,aAAa,QAAQ,8BAC5B,EAAO,aAAa,aAAa,iCAEnC,EAAO,UAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WACnB,EAAK,aAAa,EAAQ,EAAK,YAEjC,AAAG,SAAS,aAAe,UACzB,SAAS,iBAAiB,mBAAoB,GAE9C,ICpBX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GA6EA,EAAI,IAAI,IACR,EAAI,IAAIe,oBACR,EAAI,IAAIC,sBACR,EAAI,IAAIC,qBACR,EAAI,IAAIC,iBACR,EAAI,IAAIC,kBACR,EAAI,IAAIC,qBACR,EAAI,IAAIC,mBACR,EAAI,IAAIC,sBACR,EAAI,IAAIC,oBACR,EAAI,IAAIC,kBACR,EAAI,IAAIC,kBACR,EAAI,IAAIC,oBACR,EAAI,IAAIC,2BACR,EAAI,IAAIC,yBACR,EAAI,IAAIC,kBACR,EAAI,IAAIC,qBACR,EAAI,IAAIC,mBACR,EAAI,IAAIC,sBACR,EAAI,IAAIC,oBACR,EAAI,IAAIC,mBACR,EAAI,IAAIC,0BACR,EAAI,IAAIC,wBAER,KAAM,IAAwB,CAC1B,CACI,KAAM,SACN,KAAM,QACN,UAAWxB,GACX,MAAO,AAAC,KACJ,MAAO,EAAM,MAAM,SAG3B,CACI,KAAM,cACN,KAAM,OACN,UAAW,GACX,MAAO,AAAC,KACJ,MAAO,EAAM,MAAM,MACnB,OAAQ,EAAM,MAAM,OACpB,UAAW,EAAM,MAAM,UACvB,QAAS,EAAM,MAAM,QACrB,mBAAoB,EAAM,MAAM,sBAGxC,CACI,KAAM,SACN,KAAM,QACN,UAAWE,IAEf,CACI,KAAM,kBACN,KAAM,iBACN,UAAW,IAEf,CACI,KAAM,yBACN,KAAM,wBACN,UAAW,IAEf,CACI,KAAM,IACN,KAAM,OACN,UAAW,KAIb,GAAS,GAAI,IAAU,CACzB,KAAM,UACN,YAGE,GAAU,EAChB,GAAI,IAEJ,AAAI,OAAO,iBACC,IACJ,uEAIU,AAFE,GAAa,OAAO,QAEd,SAEV,iBAAiB,UAAW,AAAC,GAAY,CAC7C,EAAQ,KAAK,OAAS,gBACf,iBAIR,iBAAiB,QAAS,IAAM,CAC/B,OACY,YAAY,CACpB,KAAM,cAKN,WAAW,KAAK,GAAK,IAAI,UAAU,AAAC,GAAa,CACrD,IACI,YACQ,IAAI,iDACA,YAAY,CACpB,KAAM,QACN,OAAQ,EAAY,aASxC,GAAO,WAAW,CAAC,EAAI,EAAM,IAAS,IACzB,MAAM,sBAInB,KAAM,IAAc,GAAI,KAAI,CACxB,QACA,OACA,QACA,iBACA,0BAGJ,GAAO,WAAW,MAAO,EAAI,EAAM,IAAS,IACpC,MACM,GAAW,GAAQ,gBAErB,IAAe,EAAU,CACpB,GAAQ,qBACH,IAAQ,kBAGN,YAAY,CACpB,KAAM,QACN,OAAQ,EAAY,uBAOxB,GAAY,CAAC,GAAQ,kBACjB,MACM,IAAQ,eAEV,EAAG,OAAS,SAAW,EAAG,OAAS,gBAC3B,IACJ,qDAGC,CAAE,KAAM,2BAKZ,WACG,MAAM,oCAAqC,UAKvD,CAAC,GAAY,IAAI,EAAG,OAAS,CAAC,EAAU,SAChC,IAAI,sDACP,CAAE,KAAM,qBAEV,iCAUf,GAAO,UAAU,CAAC,EAAI,IAAS,IAClB,MAAM,iBAGnB,mBAAuB,CACT,GAAI,GAAI,CACd,OAAQ,AAAC,GAAc,EAAU,MAClC,OAAO,YAEE,GAAI,GAAI,CAChB,UACA,OAAQ,AAAC,GAAc,EAAU,MAClC,OAAO,QAGd"}
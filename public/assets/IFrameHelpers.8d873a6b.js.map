{"version":3,"file":"IFrameHelpers.8d873a6b.js","sources":["../../../vite/modulepreload-polyfill","../../../../aux-vm/globalThis-polyfill.ts","../../shared/Utils.ts","../../../../aux-records/Utils.ts","../../../../aux-records/AuthUtils.ts","../../shared/AuthManager.ts","../../shared/index.ts","../../../../aux-vm-browser/html/IFrameHelpers.ts"],"sourcesContent":["const p = function polyfill() {\n    const relList = document.createElement('link').relList;\n    if (relList && relList.supports && relList.supports('modulepreload')) {\n        return;\n    }\n    for (const link of document.querySelectorAll('link[rel=\"modulepreload\"]')) {\n        processPreload(link);\n    }\n    new MutationObserver((mutations) => {\n        for (const mutation of mutations) {\n            if (mutation.type !== 'childList') {\n                continue;\n            }\n            for (const node of mutation.addedNodes) {\n                if (node.tagName === 'LINK' && node.rel === 'modulepreload')\n                    processPreload(node);\n            }\n        }\n    }).observe(document, { childList: true, subtree: true });\n    function getFetchOpts(script) {\n        const fetchOpts = {};\n        if (script.integrity)\n            fetchOpts.integrity = script.integrity;\n        if (script.referrerpolicy)\n            fetchOpts.referrerPolicy = script.referrerpolicy;\n        if (script.crossorigin === 'use-credentials')\n            fetchOpts.credentials = 'include';\n        else if (script.crossorigin === 'anonymous')\n            fetchOpts.credentials = 'omit';\n        else\n            fetchOpts.credentials = 'same-origin';\n        return fetchOpts;\n    }\n    function processPreload(link) {\n        if (link.ep)\n            // ep marker = processed\n            return;\n        link.ep = true;\n        // prepopulate the load record\n        const fetchOpts = getFetchOpts(link);\n        fetch(link.href, fetchOpts);\n    }\n};__VITE_IS_MODERN__&&p();","/**\n * globatThis polyfill, dont touch.\n * Ref: https://mathiasbynens.be/notes/globalthis\n * Used to get oculus browser running.\n */\ndeclare var __magic__: any;\n(function () {\n    console.log('[globalThis-polyfill] load');\n    if (typeof globalThis === 'object') return;\n    (<any>Object.prototype).__defineGetter__('__magic__', function () {\n        return this;\n    });\n    __magic__.globalThis = __magic__; // lolwat\n    delete (<any>Object.prototype).__magic__;\n    // Your code can use `globalThis` now.\n})();\n\n(globalThis as any).global = globalThis;\n","\nexport interface RegexRule {\n    type: 'allow' | 'deny';\n    pattern: string;\n}\n\n/**\n * Determines if the given value matches the given list of rules.\n * @param value The value to test.\n * @param rules The rules that the value should be tested against.\n */\nexport function isStringValid(value: string, rules: RegexRule[]) {\n    if (rules.length <= 0) {\n        return true;\n    }\n\n    const regexRules = rules.map((r) => ({\n        type: r.type,\n        pattern: new RegExp(r.pattern, 'i'),\n    }));\n\n    let good = false;\n    for (let rule of regexRules) {\n        if (rule.type === 'allow') {\n            if (rule.pattern.test(value)) {\n                good = true;\n                break;\n            }\n        } else if (rule.type === 'deny') {\n            if (rule.pattern.test(value)) {\n                good = false;\n                break;\n            }\n        }\n    }\n\n    return good;\n}\n","import { fromByteArray, toByteArray } from 'base64-js';\nimport _, { padStart, sortBy, StringChain } from 'lodash';\nimport { sha256, hmac } from 'hash.js';\n\n/**\n * Converts the given string into a base64 string.\n * @param str The string to convert.\n */\nexport function toBase64String(str: string): string {\n    const encoder = new TextEncoder();\n    const array = encoder.encode(str);\n    return fromByteArray(array);\n}\n\n/**\n * Converts the given string from a base64 string.\n * @param base64\n */\nexport function fromBase64String(base64: string): string {\n    const decoder = new TextDecoder();\n    const array = toByteArray(base64);\n    return decoder.decode(array);\n}\n\n/**\n * Signs the given request and adds the related headers to it.\n * @param request The request to sign.\n * @param secretAccessKey The secret access key to use.\n * @param accessKeyId The ID of the access key that is being used.\n * @param date The date to use for signing.\n * @param region The AWS region.\n * @param service The AWS service.\n */\nexport function signRequest(\n    request: CanonicalRequest,\n    secretAccessKey: string,\n    accessKeyId: string,\n    date: Date,\n    region: string,\n    service: string\n): CanonicalRequest {\n    const hash = request.payloadSha256Hex.toLowerCase();\n    request = {\n        ...request,\n        headers: {\n            ...request.headers,\n            'x-amz-date': getAmzDateString(date),\n            'x-amz-content-sha256': hash,\n        },\n    };\n\n    let canonicalRequest = createCanonicalRequest(request);\n    let stringToSign = createStringToSign(\n        canonicalRequest,\n        date,\n        region,\n        service\n    );\n    let signature = createAWS4Signature(\n        stringToSign,\n        secretAccessKey,\n        date,\n        region,\n        service\n    );\n\n    let credential = `${accessKeyId}/${getDateString(\n        date\n    )}/${region}/${service}/aws4_request`;\n    let signedHeaders = Object.keys(request.headers)\n        .map((header) => header.toLowerCase())\n        .sort()\n        .join(';');\n\n    let authorization = `AWS4-HMAC-SHA256 Credential=${credential},SignedHeaders=${signedHeaders},Signature=${signature}`;\n\n    let result: CanonicalRequest = {\n        method: request.method,\n        path: request.path,\n        queryString: { ...request.queryString },\n        headers: {\n            ...request.headers,\n            Authorization: authorization,\n        },\n        payloadSha256Hex: hash,\n    };\n\n    return result;\n}\n\n/**\n * Constructs a string that can be signed from the given request, date, AWS region, and AWS Service.\n * @param canonicalRequest The canonical request to include.\n * @param date The date that the signature is happening on.\n * @param region The region that the signature is for.\n * @param service The service that the signature is for.\n */\nexport function createStringToSign(\n    canonicalRequest: string,\n    date: Date,\n    region: string,\n    service: string\n): string {\n    const isoDate = getDateString(date);\n    const isoDateTime = getAmzDateString(date);\n\n    const sha = sha256();\n    sha.update(canonicalRequest);\n    const canonicalRequestHash = sha.digest('hex');\n\n    return `AWS4-HMAC-SHA256\\n${isoDateTime}\\n${isoDate}/${region}/${service}/aws4_request\\n${canonicalRequestHash}`;\n}\n\n/**\n * Creates a signature using the given secret access key and additional info.\n * @param stringToSign The string that should be signed.\n * @param secretAccessKey The secret access key.\n * @param date The date that the signature is happening on.\n * @param region The AWS region.\n * @param service The AWS Service.\n */\nexport function createAWS4Signature(\n    stringToSign: string,\n    secretAccessKey: string,\n    date: Date,\n    region: string,\n    service: string\n): string {\n    const final = createHmac(\n        createSigningKey(secretAccessKey, date, region, service),\n        stringToSign,\n        'hex'\n    );\n    return final;\n}\n\nexport function createSigningKey(\n    secretAccessKey: string,\n    date: Date,\n    region: string,\n    service: string,\n    enc?: 'hex'\n) {\n    const dateString =\n        date.getUTCFullYear() +\n        padStart((1 + date.getUTCMonth()).toString(), 2, '0') +\n        padStart(date.getUTCDate().toString(), 2, '0');\n    const dateKey = createHmac('AWS4' + secretAccessKey, dateString);\n    const dateRegionKey = createHmac(dateKey, region);\n    const dateRegionServiceKey = createHmac(dateRegionKey, service);\n    const signingKey = createHmac(dateRegionServiceKey, 'aws4_request', enc);\n\n    return signingKey;\n}\n\nfunction createHmac(key: string | number[], data: string): number[];\nfunction createHmac(key: string | number[], data: string, enc: 'hex'): string;\nfunction createHmac(key: string | number[], data: string, enc?: 'hex') {\n    const hmacSha256 = hmac(<any>sha256, key);\n    hmacSha256.update(data);\n\n    if (enc) {\n        return hmacSha256.digest(enc);\n    } else {\n        return hmacSha256.digest();\n    }\n}\n\n/**\n * Creates a canonical request string that can be used to create a AWS Signature for the given request.\n *\n * See https://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-header-based-auth.html\n * @param request The request to create the canonical request for.\n */\nexport function createCanonicalRequest(request: CanonicalRequest): string {\n    let str = '';\n\n    str += request.method + '\\n';\n    str += canonicalUriEncode(request.path, false) + '\\n';\n\n    let queryStringParams = Object.keys(request.queryString).map((name) => [\n        name,\n        canonicalUriEncode(name, true),\n    ]);\n    queryStringParams = sortBy(\n        queryStringParams,\n        ([name, encodedName]) => encodedName\n    );\n    let i = 0;\n    for (let [name, encodedName] of queryStringParams) {\n        let value = request.queryString[name];\n        str += encodedName + '=' + canonicalUriEncode(value, true);\n        if (i < queryStringParams.length - 1) {\n            str += '&';\n        }\n        i++;\n    }\n    str += '\\n';\n\n    let headerNames = Object.keys(request.headers).map((name) => [\n        name,\n        name.toLowerCase(),\n    ]);\n    headerNames = sortBy(headerNames, ([name, encodedName]) => encodedName);\n    i = 0;\n    for (let [name, encodedName] of headerNames) {\n        let value = request.headers[name];\n        str += encodedName + ':' + value.trim() + '\\n';\n        i++;\n    }\n    str += '\\n';\n    str +=\n        headerNames.map(([name, encodedName]) => encodedName).join(';') + '\\n';\n    str += request.payloadSha256Hex.toLowerCase();\n\n    return str;\n}\n\nexport interface CanonicalRequest {\n    method: 'GET' | 'POST' | 'PUT' | 'DELETE';\n    path: string;\n    headers: {\n        [name: string]: string;\n    };\n    queryString: {\n        [name: string]: string;\n    };\n    payloadSha256Hex: string;\n}\n\nconst A = 'A'.charCodeAt(0);\nconst Z = 'Z'.charCodeAt(0);\nconst a = 'a'.charCodeAt(0);\nconst z = 'z'.charCodeAt(0);\nconst _0 = '0'.charCodeAt(0);\nconst _9 = '9'.charCodeAt(0);\nconst __ = '_'.charCodeAt(0);\nconst _dash = '-'.charCodeAt(0);\nconst _squiggle = '~'.charCodeAt(0);\nconst _dot = '.'.charCodeAt(0);\nconst _slash = '/'.charCodeAt(0);\n\n/**\n * URI Encodes the given string according to AWS Signature Version 4.\n * See https://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-header-based-auth.html\n * @param input The string to URI encode.\n * @param encodeSlash Whether to encode slashes as %2F.\n */\nexport function canonicalUriEncode(\n    input: string,\n    encodeSlash: boolean\n): string {\n    const textEncoder = new TextEncoder();\n    const bytes = textEncoder.encode(input);\n    const textDecoder = new TextDecoder();\n    let result: number[] = [];\n    for (let i = 0; i < bytes.length; i++) {\n        let ch = bytes[i];\n        if (\n            (ch >= A && ch <= Z) ||\n            (ch >= a && ch <= z) ||\n            (ch >= _0 && ch <= _9) ||\n            ch == __ ||\n            ch == _dash ||\n            ch == _squiggle ||\n            ch == _dot\n        ) {\n            result.push(ch);\n        } else if (ch === _slash) {\n            if (encodeSlash) {\n                result.push(...textEncoder.encode('%2F'));\n            } else {\n                result.push(ch);\n            }\n        } else {\n            result.push(...textEncoder.encode(encodeHexUtf8(ch)));\n        }\n    }\n    const buffer = new Uint8Array(result);\n    return textDecoder.decode(buffer);\n}\n\n/**\n * Encodes the given character code as a URI hex string.\n * @param char The character to encode.\n */\nexport function encodeHexUtf8(char: number): string {\n    const hex = char.toString(16).toUpperCase();\n    return '%' + (hex.length === 1 ? '0' + hex : hex);\n}\n\nfunction getDateString(date: Date): string {\n    return (\n        date.getUTCFullYear() +\n        padStart((1 + date.getUTCMonth()).toString(), 2, '0') +\n        padStart(date.getUTCDate().toString(), 2, '0')\n    );\n}\n\nfunction getAmzDateString(date: Date): string {\n    return (\n        getDateString(date) +\n        'T' +\n        padStart(date.getUTCHours().toString(), 2, '0') +\n        padStart(date.getUTCMinutes().toString(), 2, '0') +\n        padStart(date.getUTCSeconds().toString(), 2, '0') +\n        'Z'\n    );\n}\n","import { padStart } from 'lodash';\nimport { randomBytes } from 'tweetnacl';\nimport { fromBase64String, toBase64String } from './Utils';\n\n/**\n * The number of characters that random codes should contain.\n */\nexport const RANDOM_CODE_LENGTH = 6;\n\n/**\n * Creates a new random numerical code.\n */\nexport function randomCode(): string {\n    const bytes = randomBytes(4);\n    const int32 = new Uint32Array(bytes.buffer);\n    const str = padStart(\n        int32[0].toString().substring(0, RANDOM_CODE_LENGTH),\n        RANDOM_CODE_LENGTH,\n        '0'\n    );\n    return str;\n}\n\n/**\n * Formats the given user ID, session ID, session secret, and expiration time into a key that is used to authenticate a user to a particular session.\n * @param userId The ID of the user.\n * @param sessionId The ID of the session.\n * @param sessionSecret The secret for the session.\n * @param expireTimeMs The unix timestamp that the key expires at.\n */\nexport function formatV1SessionKey(\n    userId: string,\n    sessionId: string,\n    sessionSecret: string,\n    expireTimeMs: number\n): string {\n    return `vSK1.${toBase64String(userId)}.${toBase64String(\n        sessionId\n    )}.${toBase64String(sessionSecret)}.${toBase64String(\n        expireTimeMs.toString()\n    )}`;\n}\n\n/**\n * Parses the given session token into a user ID and session ID, and session secret array.\n * Returns null if the key cannot be parsed.\n * @param key The key to parse.\n */\nexport function parseSessionKey(\n    key: string | null\n): [\n    userId: string,\n    sessionId: string,\n    sessionSecret: string,\n    expireTimeMs: number\n] {\n    return parseV1SessionKey(key);\n}\n\n/**\n * Parses a version 1 session key into a user ID, session ID, session secret, and expiration time.\n * Returns null if the key cannot be parsed or if it is not a V1 key.\n * @param key The key to parse.\n */\nexport function parseV1SessionKey(\n    key: string\n): [\n    userId: string,\n    sessionId: string,\n    sessionSecret: string,\n    expireTimeMs: number\n] {\n    if (!key) {\n        return null;\n    }\n\n    if (!key.startsWith('vSK1.')) {\n        return null;\n    }\n\n    const withoutVersion = key.slice('vSK1.'.length);\n    let periodAfterUserId = withoutVersion.indexOf('.');\n    if (periodAfterUserId < 0) {\n        return null;\n    }\n\n    const userIdBase64 = withoutVersion.slice(0, periodAfterUserId);\n    const sessionIdPlusPassword = withoutVersion.slice(periodAfterUserId + 1);\n\n    if (userIdBase64.length <= 0 || sessionIdPlusPassword.length <= 0) {\n        return null;\n    }\n\n    const periodAfterSessionId = sessionIdPlusPassword.indexOf('.');\n    if (periodAfterSessionId < 0) {\n        return null;\n    }\n\n    const sessionIdBase64 = sessionIdPlusPassword.slice(\n        0,\n        periodAfterSessionId\n    );\n    const passwordPlusExpireTime = sessionIdPlusPassword.slice(\n        periodAfterSessionId + 1\n    );\n\n    if (sessionIdBase64.length <= 0 || passwordPlusExpireTime.length <= 0) {\n        return null;\n    }\n\n    const periodAfterPassword = passwordPlusExpireTime.indexOf('.');\n    if (periodAfterPassword < 0) {\n        return null;\n    }\n\n    const passwordBase64 = passwordPlusExpireTime.slice(0, periodAfterPassword);\n    const expireTimeBase64 = passwordPlusExpireTime.slice(\n        periodAfterPassword + 1\n    );\n\n    if (passwordBase64.length <= 0 || expireTimeBase64.length <= 0) {\n        return null;\n    }\n\n    try {\n        const userId = fromBase64String(userIdBase64);\n        const sessionId = fromBase64String(sessionIdBase64);\n        const password = fromBase64String(passwordBase64);\n        const expireTime = parseInt(fromBase64String(expireTimeBase64));\n\n        return [userId, sessionId, password, expireTime];\n    } catch (err) {\n        return null;\n    }\n}\n","import axios from 'axios';\nimport { Subject, BehaviorSubject, Observable, from } from 'rxjs';\nimport { AppMetadata } from '../../shared/AuthMetadata';\nimport {\n    CreatePublicRecordKeyResult,\n    PublicRecordKeyPolicy,\n} from '@casual-simulation/aux-records';\nimport { isStringValid, RegexRule } from './Utils';\nimport { parseSessionKey } from '@casual-simulation/aux-records/AuthUtils';\nimport type {\n    CompleteLoginResult,\n    LoginRequestResult,\n    ListSessionsResult,\n    RevokeSessionResult,\n    RevokeAllSessionsResult,\n    ListedSession,\n    ReplaceSessionResult,\n} from '@casual-simulation/aux-records/AuthController';\nimport { AddressType } from '@casual-simulation/aux-records/AuthStore';\nimport { omitBy } from 'lodash';\n\nconst EMAIL_KEY = 'userEmail';\nconst ACCEPTED_TERMS_KEY = 'acceptedTerms';\nconst SESSION_KEY = 'sessionKey';\n\nexport class AuthManager {\n    private _userId: string;\n    private _sessionId: string;\n    private _appMetadata: AppMetadata;\n\n    private _loginState: Subject<boolean>;\n    private _emailRules: RegexRule[];\n    private _phoneRules: RegexRule[];\n    private _apiEndpoint: string;\n    private _gitTag: string;\n\n    constructor(apiEndpoint: string, gitTag: string) {\n        this._apiEndpoint = apiEndpoint;\n        this._gitTag = gitTag;\n        this._loginState = new BehaviorSubject<boolean>(false);\n    }\n\n    get userId() {\n        return this._userId;\n    }\n\n    get sessionId() {\n        return this._sessionId;\n    }\n\n    get email() {\n        return this._appMetadata?.email;\n    }\n\n    get phone() {\n        return this._appMetadata?.phoneNumber;\n    }\n\n    get avatarUrl() {\n        return this._appMetadata?.avatarUrl;\n    }\n\n    get avatarPortraitUrl() {\n        return this._appMetadata?.avatarPortraitUrl;\n    }\n\n    get name() {\n        return this._appMetadata?.name;\n    }\n\n    get userInfoLoaded() {\n        return !!this._userId && !!this.savedSessionKey && !!this._appMetadata;\n    }\n\n    get loginState(): Observable<boolean> {\n        return this._loginState;\n    }\n\n    async validateEmail(email: string): Promise<boolean> {\n        if (!this._emailRules) {\n            const rules = await this._getEmailRules();\n            this._emailRules = rules.map((r) => ({\n                type: r.type,\n                pattern: r.pattern,\n            }));\n        }\n\n        return isStringValid(email, this._emailRules);\n    }\n\n    async validateSmsNumber(sms: string): Promise<boolean> {\n        if (!this._phoneRules) {\n            const rules = await this._getSmsRules();\n            this._phoneRules = rules.map((r) => ({\n                type: r.type,\n                pattern: r.pattern,\n            }));\n        }\n\n        return isStringValid(sms, this._phoneRules);\n    }\n\n    isLoggedIn(): boolean {\n        const sessionKey = this.savedSessionKey;\n        if (!sessionKey) {\n            return false;\n        }\n        const parsed = parseSessionKey(sessionKey);\n        if (!parsed) {\n            return false;\n        }\n\n        const [userId, sessionId, sessionSecret, expireTimeMs] = parsed;\n        if (Date.now() >= expireTimeMs) {\n            return false;\n        }\n\n        return true;\n    }\n\n    async loadUserInfo() {\n        const [userId, sessionId, sessionSecret, expireTimeMs] =\n            parseSessionKey(this.savedSessionKey);\n        this._userId = userId;\n        this._sessionId = sessionId;\n        this._appMetadata = await this._loadAppMetadata();\n\n        if (!this._appMetadata) {\n            this._userId = null;\n            this._sessionId = null;\n            this.savedSessionKey = null;\n        } else {\n            this._saveAcceptedTerms(true);\n            if (this.email) {\n                this._saveEmail(this.email);\n            }\n        }\n\n        this._loginState.next(this.userInfoLoaded);\n        return this.userInfoLoaded;\n    }\n\n    async createPublicRecordKey(\n        recordName: string,\n        policy: PublicRecordKeyPolicy\n    ): Promise<CreatePublicRecordKeyResult> {\n        if (!this.userInfoLoaded) {\n            await this.loadUserInfo();\n        }\n        const response = await axios.post(\n            `${this.apiEndpoint}/api/v2/records/key`,\n            {\n                recordName: recordName,\n                policy: policy,\n            },\n            {\n                headers: this._authenticationHeaders(),\n            }\n        );\n        return response.data;\n    }\n\n    async logout(revokeSessionKey: boolean = true) {\n        const sessionKey = this.savedSessionKey;\n        if (sessionKey) {\n            this.savedSessionKey = null;\n            if (revokeSessionKey) {\n                await this._revokeSessionKey(sessionKey);\n            }\n        }\n        this._userId = null;\n        this._sessionId = null;\n        this._appMetadata = null;\n        this._saveEmail(null);\n        this._loginState.next(false);\n    }\n\n    async listSessions(expireTimeMs: number = null): Promise<ListedSession[]> {\n        const query = omitBy(\n            {\n                expireTimeMs,\n            },\n            (o) => typeof o === 'undefined' || o === null\n        );\n        const url = new URL(`${this.apiEndpoint}/api/v2/sessions`);\n        for (let key in query) {\n            url.searchParams.set(key, query[key].toString());\n        }\n        const response = await axios.get(url.href, {\n            headers: this._authenticationHeaders(),\n        });\n\n        const result = response.data as ListSessionsResult;\n\n        if (result.success) {\n            return result.sessions;\n        } else {\n            return [];\n        }\n    }\n\n    private async _revokeSessionKey(sessionKey: string): Promise<void> {\n        try {\n            const response = await axios.post(\n                `${this.apiEndpoint}/api/v2/revokeSession`,\n                {\n                    sessionKey: sessionKey,\n                },\n                {\n                    headers: {\n                        Authorization: `Bearer ${sessionKey}`,\n                    },\n                }\n            );\n            console.log('[AuthManager] Session key revoked!');\n        } catch (err) {\n            console.log('[AuthManager] Could not revoke session key:', err);\n        }\n    }\n\n    async loginWithEmail(email: string) {\n        return this._login(email, 'email');\n    }\n\n    async loginWithPhoneNumber(phoneNumber: string) {\n        return this._login(phoneNumber, 'phone');\n    }\n\n    async completeLogin(\n        userId: string,\n        requestId: string,\n        code: string\n    ): Promise<CompleteLoginResult> {\n        const result = await this._completeLoginRequest(\n            userId,\n            requestId,\n            code\n        );\n\n        if (result.success === true) {\n            this.savedSessionKey = result.sessionKey;\n            this._userId = result.userId;\n        }\n\n        return result;\n    }\n\n    async revokeSession(\n        userId: string,\n        sessionId: string\n    ): Promise<RevokeSessionResult> {\n        const response = await axios.post(\n            `${this.apiEndpoint}/api/v2/revokeSession`,\n            {\n                userId,\n                sessionId,\n            },\n            {\n                validateStatus: (status) => status < 500,\n                headers: this._authenticationHeaders(),\n            }\n        );\n\n        const result = response.data as RevokeSessionResult;\n\n        if (\n            result.success &&\n            userId === this.userId &&\n            sessionId === this.sessionId\n        ) {\n            this.savedSessionKey = null;\n            await this.logout();\n        }\n\n        return result;\n    }\n\n    async revokeAllSessions(userId?: string): Promise<RevokeAllSessionsResult> {\n        if (!userId) {\n            userId = this.userId;\n        }\n\n        const response = await axios.post(\n            `${this.apiEndpoint}/api/v2/revokeAllSessions`,\n            {\n                userId,\n            },\n            {\n                validateStatus: (status) => status < 500,\n                headers: this._authenticationHeaders(),\n            }\n        );\n\n        const result = response.data as RevokeAllSessionsResult;\n\n        if (result.success && userId === this.userId) {\n            this.savedSessionKey = null;\n            await this.logout();\n        }\n\n        return result;\n    }\n\n    async replaceSession(): Promise<ReplaceSessionResult> {\n        const response = await axios.post(\n            `${this.apiEndpoint}/api/v2/replaceSession`,\n            {},\n            {\n                validateStatus: (status) => status < 500,\n                headers: this._authenticationHeaders(),\n            }\n        );\n\n        const result = response.data as ReplaceSessionResult;\n\n        if (result.success && result.userId === this.userId) {\n            this.savedSessionKey = result.sessionKey;\n        }\n\n        return result;\n    }\n\n    private async _completeLoginRequest(\n        userId: string,\n        requestId: string,\n        code: string\n    ): Promise<CompleteLoginResult> {\n        const response = await axios.post(\n            `${this.apiEndpoint}/api/v2/completeLogin`,\n            {\n                userId,\n                requestId,\n                code,\n            },\n            {\n                validateStatus: (status) => status < 500,\n            }\n        );\n\n        return response.data;\n    }\n\n    private async _login(\n        address: string,\n        addressType: AddressType\n    ): Promise<LoginRequestResult> {\n        const response = await axios.post(\n            `${this.apiEndpoint}/api/v2/login`,\n            {\n                address: address,\n                addressType: addressType,\n            },\n            {\n                validateStatus: (status) => status < 500,\n            }\n        );\n\n        return response.data;\n    }\n\n    get version(): string {\n        return this._gitTag;\n    }\n\n    get savedEmail(): string {\n        return localStorage.getItem(EMAIL_KEY);\n    }\n\n    get hasAcceptedTerms(): boolean {\n        return localStorage.getItem(ACCEPTED_TERMS_KEY) === 'true';\n    }\n\n    get savedSessionKey(): string {\n        return localStorage.getItem(SESSION_KEY);\n    }\n\n    set savedSessionKey(value: string) {\n        if (!value) {\n            localStorage.removeItem(SESSION_KEY);\n        } else {\n            localStorage.setItem(SESSION_KEY, value);\n        }\n    }\n\n    async changeEmail(newEmail: string) {\n        // TODO: Implement\n        // await this.magic.user.updateEmail({\n        //     email: newEmail,\n        // });\n        // await this.loadUserInfo();\n    }\n\n    async updateMetadata(newMetadata: Partial<AppMetadata>) {\n        // TODO: Handle errors\n        await this._putAppMetadata({\n            avatarUrl: this.avatarUrl,\n            avatarPortraitUrl: this.avatarPortraitUrl,\n            name: this.name,\n            email: this.email,\n            phoneNumber: this.phone,\n            ...newMetadata,\n        });\n        await this.loadUserInfo();\n    }\n\n    private _saveEmail(email: string) {\n        if (email) {\n            localStorage.setItem(EMAIL_KEY, email);\n        } else {\n            localStorage.removeItem(EMAIL_KEY);\n        }\n    }\n\n    private _saveAcceptedTerms(acceptedTerms: boolean) {\n        if (acceptedTerms) {\n            localStorage.setItem(ACCEPTED_TERMS_KEY, 'true');\n        } else {\n            localStorage.removeItem(ACCEPTED_TERMS_KEY);\n        }\n    }\n\n    private async _loadAppMetadata(): Promise<AppMetadata> {\n        try {\n            const response = await axios.get(\n                `${this.apiEndpoint}/api/${encodeURIComponent(\n                    this.userId\n                )}/metadata`,\n                {\n                    headers: this._authenticationHeaders(),\n                }\n            );\n\n            return response.data;\n        } catch (err) {\n            if (err.response) {\n                if (err.response.status === 404) {\n                    return null;\n                } else if (err.response.status === 403) {\n                    return null;\n                } else if (err.response.status === 401) {\n                    return null;\n                }\n            }\n        }\n    }\n\n    private async _putAppMetadata(metadata: AppMetadata): Promise<AppMetadata> {\n        // TODO:\n        const response = await axios.put(\n            `${this.apiEndpoint}/api/${encodeURIComponent(\n                this.savedSessionKey\n            )}/metadata`,\n            metadata\n        );\n        return response.data;\n    }\n\n    private _authenticationHeaders(): any {\n        return {\n            Authorization: `Bearer ${this.savedSessionKey}`,\n        };\n    }\n\n    private async _getEmailRules(): Promise<RegexRule[]> {\n        const response = await axios.get(`${this.apiEndpoint}/api/emailRules`);\n        return response.data;\n    }\n\n    private async _getSmsRules(): Promise<RegexRule[]> {\n        try {\n            const response = await axios.get(\n                `${this.apiEndpoint}/api/smsRules`\n            );\n            return response.data;\n        } catch (err) {\n            if (axios.isAxiosError(err)) {\n                if (err.response.status === 404) {\n                    return [];\n                }\n            }\n            throw err;\n        }\n    }\n\n    get apiEndpoint(): string {\n        return this._apiEndpoint;\n    }\n}\n\nexport type LoginEvent = LoginRequestSent | LoginRequestNotSent | LoginComplete;\n\nexport interface LoginRequestSent {\n    type: 'login_request_sent';\n}\n\nexport interface LoginRequestNotSent {\n    type: 'login_request_not_sent';\n}\n\nexport interface LoginComplete {\n    type: 'login_complete';\n    sessionKey: string;\n}\n","import { AuthManager } from './AuthManager';\n\ndeclare const API_ENDPOINT: string;\ndeclare const GIT_TAG: string;\n\nconst authManager = new AuthManager(API_ENDPOINT, GIT_TAG);\n\nexport { authManager };\n","import '@casual-simulation/aux-vm/globalThis-polyfill';\nimport { Message } from 'comlink/dist/umd/protocol';\nimport { Observable } from 'rxjs';\n\n/**\n * Creates a new message channel and sends port2 to the iframe in a message.\n * @param iframeWindow The window to send the port to.\n */\nexport function setupChannel(iframeWindow: Window) {\n    const channel = new MessageChannel();\n\n    iframeWindow.postMessage(\n        {\n            type: 'init_port',\n            port: channel.port2,\n        },\n        '*',\n        [channel.port2]\n    );\n\n    return channel;\n}\n\n/**\n * Listens for the init_port event from the global context.\n * @param origin The origin that the channels should be recieved from.\n */\nexport function listenForChannels(origin?: string): Observable<MessagePort> {\n    return new Observable((observer) => {\n        let listener = (msg: MessageEvent) => {\n            if (msg.data.type === 'init_port') {\n                if (!origin || msg.origin === origin) {\n                    observer.next(msg.data.port);\n                }\n            }\n        };\n        globalThis.addEventListener('message', listener);\n\n        return () => {\n            globalThis.removeEventListener('message', listener);\n        };\n    });\n}\n\n/**\n * Listens for the init_port event from the global context.\n * @param origin The origin that the channel should be recieved from.\n */\nexport function listenForChannel(origin?: string): Promise<MessagePort> {\n    return new Promise<MessagePort>((resolve) => {\n        let listener = (msg: MessageEvent) => {\n            if (msg.data.type === 'init_port') {\n                if (!origin || msg.origin === origin) {\n                    globalThis.removeEventListener('message', listener);\n                    resolve(msg.data.port);\n                }\n            }\n        };\n        globalThis.addEventListener('message', listener);\n    });\n}\n\nexport function waitForLoad(iframe: HTMLIFrameElement): Promise<void> {\n    return new Promise<void>((resolve) => {\n        let listener = () => {\n            iframe.removeEventListener('load', listener);\n            resolve();\n        };\n        iframe.addEventListener('load', listener);\n    });\n}\n\n/**\n * Loads the script at the given URL into the given iframe window.\n * @param iframeWindow The iframe.\n * @param id The ID of the script.\n * @param source The source code to load.\n */\nexport function loadScript(iframeWindow: Window, id: string, source: string) {\n    return new Promise<void>((resolve, reject) => {\n        const listener = (message: MessageEvent) => {\n            if (message.source !== iframeWindow) {\n                return;\n            }\n            if (\n                message.data.type === 'script_loaded' &&\n                message.data.id === id\n            ) {\n                globalThis.removeEventListener('message', listener);\n                resolve();\n            }\n        };\n        globalThis.addEventListener('message', listener);\n        iframeWindow.postMessage(\n            {\n                type: 'load_script',\n                id,\n                source,\n            },\n            '*'\n        );\n    });\n}\n\n/**\n * Injects the given message port with the given ID into the iframe.\n * @param iframeWindow The iframe that the message port should be injected into.\n * @param id The ID of the message port.\n * @param port The port to inject.\n */\nexport function injectPort(\n    iframeWindow: Window,\n    id: string,\n    port: MessagePort\n) {\n    return new Promise<void>((resolve, reject) => {\n        const listener = (message: MessageEvent) => {\n            if (message.source !== iframeWindow) {\n                return;\n            }\n            if (\n                message.data.type === 'port_injected' &&\n                message.data.id === id\n            ) {\n                globalThis.removeEventListener('message', listener);\n                resolve();\n            }\n        };\n        globalThis.addEventListener('message', listener);\n        iframeWindow.postMessage(\n            {\n                type: 'inject_port',\n                id,\n                port,\n            },\n            '*',\n            [port]\n        );\n    });\n}\n\n/**\n * Loads the script at the given URL into the given iframe window.\n * @param iframeWindow The iframe.\n * @param id The ID of the script.\n * @param text The text to load.\n * @param element The HTML element the text should be loaded in.\n */\nexport function loadText(\n    iframeWindow: Window,\n    id: string,\n    text: string,\n    element: string\n) {\n    return new Promise<void>((resolve, reject) => {\n        const listener = (message: MessageEvent) => {\n            if (message.source !== iframeWindow) {\n                return;\n            }\n            if (message.data.type === 'text_loaded' && message.data.id === id) {\n                globalThis.removeEventListener('message', listener);\n                resolve();\n            }\n        };\n        globalThis.addEventListener('message', listener);\n        iframeWindow.postMessage(\n            {\n                type: 'load_text',\n                id,\n                text,\n                element,\n            },\n            '*'\n        );\n    });\n}\n\n/**\n * Reloads the iframe.\n * @param iframeWindow The iframe to reload.\n */\nexport function reload(iframeWindow: HTMLIFrameElement) {\n    const promise = waitForLoad(iframeWindow);\n\n    iframeWindow.contentWindow.postMessage(\n        {\n            type: 'reload',\n        },\n        '*'\n    );\n\n    return promise;\n}\n\n/**\n * Creates\n * @param options\n * @param properties\n */\nexport async function setupCustomIframe(\n    options: { vmOrigin: string },\n    properties?: Partial<HTMLIFrameElement>\n) {\n    const origin = options.vmOrigin || location.origin;\n    const iframeUrl = new URL('/aux-vm-iframe.html', origin).href;\n\n    const iframe = document.createElement('iframe');\n    iframe.src = iframeUrl;\n    iframe.style.display = 'none';\n\n    if (properties) {\n        for (let key in properties) {\n            (<any>iframe)[key] = (<any>properties)[key];\n        }\n    }\n\n    // Allow the iframe to run scripts, but do nothing else.\n    // Because we're not allowing the same origin, this prevents the VM from talking to\n    // storage like IndexedDB and therefore prevents different VMs from affecting each other.\n    // iframe.sandbox.add('allow-scripts');\n\n    // const bowserResult = Bowser.parse(navigator.userAgent);\n\n    // Safari requires the allow-same-origin option in order to load\n    // web workers using a blob.\n    // if (\n    //     bowserResult.browser.name === 'Safari' ||\n    //     bowserResult.os.name === 'iOS'\n    // ) {\n    //     console.warn('[AuxVMImpl] Adding allow-same-origin for Safari');\n    //     iframe.sandbox.add('allow-same-origin');\n    // }\n\n    let promise = waitForLoad(iframe);\n    document.body.insertBefore(iframe, document.body.firstChild);\n\n    await promise;\n\n    return iframe;\n}\n\n// /**\n//  * Loads the script into the iframe window as a portal.\n//  * @param iframeWindow The iframe.\n//  * @param id The ID of the portal.\n//  * @param source The source code to load.\n//  */\n// export function registerIFramePortal(iframeWindow: Window, id: string, source: string) {\n//     return new Promise<void>((resolve, reject) => {\n//         const listener = (message: MessageEvent) => {\n//             if (message.source !== iframeWindow) {\n//                 debugger;\n//                 return;\n//             }\n//             if (\n//                 message.data.type === 'portal_registered' &&\n//                 message.data.id === id\n//             ) {\n//                 globalThis.removeEventListener('message', listener);\n//                 resolve();\n//             }\n//         };\n//         globalThis.addEventListener('message', listener);\n//         iframeWindow.postMessage(\n//             {\n//                 type: 'register_portal',\n//                 id,\n//                 source\n//             },\n//             '*'\n//         );\n//     });\n// }\n"],"names":["toByteArray","omitBy"],"mappings":"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"}